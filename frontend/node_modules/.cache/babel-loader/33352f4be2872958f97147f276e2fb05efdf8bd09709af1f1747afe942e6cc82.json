{"ast":null,"code":"import { Trie } from \"@wry/trie\";\nimport { BREAK, Kind, OperationTypeNode, visit } from \"graphql\";\nimport { Observable, throwError } from \"rxjs\";\nimport { catchError, concat, EMPTY, filter, finalize, from, lastValueFrom, map, materialize, mergeMap, of, share, shareReplay, Subject, tap } from \"rxjs\";\nimport { canonicalStringify } from \"@apollo/client/cache\";\nimport { CombinedGraphQLErrors, graphQLResultHasProtocolErrors, registerLinkError, toErrorLike } from \"@apollo/client/errors\";\nimport { PROTOCOL_ERRORS_SYMBOL } from \"@apollo/client/errors\";\nimport { execute } from \"@apollo/client/link\";\nimport { maskFragment, maskOperation } from \"@apollo/client/masking\";\nimport { cacheSizes, DocumentTransform, isNetworkRequestInFlight, print } from \"@apollo/client/utilities\";\nimport { __DEV__ } from \"@apollo/client/utilities/environment\";\nimport { AutoCleanedWeakCache, checkDocument, filterMap, getDefaultValues, getOperationDefinition, getOperationName, graphQLResultHasError, hasDirectives, hasForcedResolvers, isDocumentNode, isNonNullObject, makeUniqueId, removeDirectivesFromDocument, toQueryResult } from \"@apollo/client/utilities/internal\";\nimport { invariant, newInvariantError } from \"@apollo/client/utilities/invariant\";\nimport { NetworkStatus } from \"./networkStatus.js\";\nimport { logMissingFieldErrors, ObservableQuery } from \"./ObservableQuery.js\";\nimport { QueryInfo } from \"./QueryInfo.js\";\nexport class QueryManager {\n  defaultOptions;\n  client;\n  /**\n   * The options that were passed to the ApolloClient constructor.\n   */\n  clientOptions;\n  assumeImmutableResults;\n  documentTransform;\n  ssrMode;\n  defaultContext;\n  dataMasking;\n  incrementalHandler;\n  localState;\n  queryDeduplication;\n  /**\n   * Whether to prioritize cache values over network results when\n   * `fetchObservableWithInfo` is called.\n   * This will essentially turn a `\"network-only\"` or `\"cache-and-network\"`\n   * fetchPolicy into a `\"cache-first\"` fetchPolicy, but without influencing\n   * the `fetchPolicy` of the `ObservableQuery`.\n   *\n   * This can e.g. be used to prioritize the cache during the first render after\n   * SSR.\n   */\n  prioritizeCacheValues = false;\n  onBroadcast;\n  mutationStore;\n  /**\n   * All ObservableQueries that currently have at least one subscriber.\n   */\n  obsQueries = new Set();\n  // Maps from queryInfo.id strings to Promise rejection functions for\n  // currently active queries and fetches.\n  // Use protected instead of private field so\n  // @apollo/experimental-nextjs-app-support can access type info.\n  fetchCancelFns = new Map();\n  constructor(options) {\n    const defaultDocumentTransform = new DocumentTransform(document => this.cache.transformDocument(document),\n    // Allow the apollo cache to manage its own transform caches\n    {\n      cache: false\n    });\n    this.client = options.client;\n    this.defaultOptions = options.defaultOptions;\n    this.queryDeduplication = options.queryDeduplication;\n    this.clientOptions = options.clientOptions;\n    this.ssrMode = options.ssrMode;\n    this.assumeImmutableResults = options.assumeImmutableResults;\n    this.dataMasking = options.dataMasking;\n    this.localState = options.localState;\n    this.incrementalHandler = options.incrementalHandler;\n    const documentTransform = options.documentTransform;\n    this.documentTransform = documentTransform ? defaultDocumentTransform.concat(documentTransform)\n    // The custom document transform may add new fragment spreads or new\n    // field selections, so we want to give the cache a chance to run\n    // again. For example, the InMemoryCache adds __typename to field\n    // selections and fragments from the fragment registry.\n    .concat(defaultDocumentTransform) : defaultDocumentTransform;\n    this.defaultContext = options.defaultContext || {};\n    if (this.onBroadcast = options.onBroadcast) {\n      this.mutationStore = {};\n    }\n  }\n  get link() {\n    return this.client.link;\n  }\n  get cache() {\n    return this.client.cache;\n  }\n  /**\n   * Call this method to terminate any active query processes, making it safe\n   * to dispose of this QueryManager instance.\n   */\n  stop() {\n    this.obsQueries.forEach(oq => oq.stop());\n    this.cancelPendingFetches(newInvariantError(83));\n  }\n  cancelPendingFetches(error) {\n    this.fetchCancelFns.forEach(cancel => cancel(error));\n    this.fetchCancelFns.clear();\n  }\n  async mutate({\n    mutation,\n    variables,\n    optimisticResponse,\n    updateQueries,\n    refetchQueries = [],\n    awaitRefetchQueries = false,\n    update: updateWithProxyFn,\n    onQueryUpdated,\n    fetchPolicy,\n    errorPolicy,\n    keepRootFields,\n    context\n  }) {\n    const queryInfo = new QueryInfo(this);\n    mutation = this.cache.transformForLink(this.transform(mutation));\n    const {\n      hasClientExports\n    } = this.getDocumentInfo(mutation);\n    variables = this.getVariables(mutation, variables);\n    if (hasClientExports) {\n      if (__DEV__) {\n        invariant(this.localState, 84, getOperationName(mutation, \"(anonymous)\"));\n      }\n      variables = await this.localState.getExportedVariables({\n        client: this.client,\n        document: mutation,\n        variables,\n        context\n      });\n    }\n    const mutationStoreValue = this.mutationStore && (this.mutationStore[queryInfo.id] = {\n      mutation,\n      variables,\n      loading: true,\n      error: null\n    });\n    const isOptimistic = optimisticResponse && queryInfo.markMutationOptimistic(optimisticResponse, {\n      document: mutation,\n      variables,\n      cacheWriteBehavior: fetchPolicy === \"no-cache\" ? 0 /* CacheWriteBehavior.FORBID */ : 2 /* CacheWriteBehavior.MERGE */,\n      errorPolicy,\n      context,\n      updateQueries,\n      update: updateWithProxyFn,\n      keepRootFields\n    });\n    this.broadcastQueries();\n    return new Promise((resolve, reject) => {\n      const cause = {};\n      return this.getObservableFromLink(mutation, {\n        ...context,\n        optimisticResponse: isOptimistic ? optimisticResponse : void 0\n      }, variables, {}, false).observable.pipe(validateDidEmitValue(), mergeMap(result => {\n        const storeResult = {\n          ...result\n        };\n        return from(queryInfo.markMutationResult(storeResult, {\n          document: mutation,\n          variables,\n          cacheWriteBehavior: fetchPolicy === \"no-cache\" ? 0 /* CacheWriteBehavior.FORBID */ : 2 /* CacheWriteBehavior.MERGE */,\n          errorPolicy,\n          context,\n          update: updateWithProxyFn,\n          updateQueries,\n          awaitRefetchQueries,\n          refetchQueries,\n          removeOptimistic: isOptimistic ? queryInfo.id : void 0,\n          onQueryUpdated,\n          keepRootFields\n        }));\n      })).pipe(map(storeResult => {\n        const hasErrors = graphQLResultHasError(storeResult);\n        if (hasErrors && errorPolicy === \"none\") {\n          throw new CombinedGraphQLErrors(storeResult);\n        }\n        if (mutationStoreValue) {\n          mutationStoreValue.loading = false;\n          mutationStoreValue.error = null;\n        }\n        return storeResult;\n      })).subscribe({\n        next: storeResult => {\n          this.broadcastQueries();\n          // Since mutations might receive multiple payloads from the\n          // ApolloLink chain (e.g. when used with @defer),\n          // we resolve with a SingleExecutionResult or after the final\n          // ExecutionPatchResult has arrived and we have assembled the\n          // multipart response into a single result.\n          if (!queryInfo.hasNext) {\n            const result = {\n              data: this.maskOperation({\n                document: mutation,\n                data: storeResult.data,\n                fetchPolicy,\n                cause\n              })\n            };\n            if (graphQLResultHasError(storeResult)) {\n              result.error = new CombinedGraphQLErrors(storeResult);\n            }\n            if (Object.keys(storeResult.extensions || {}).length) {\n              result.extensions = storeResult.extensions;\n            }\n            resolve(result);\n          }\n        },\n        error: error => {\n          if (mutationStoreValue) {\n            mutationStoreValue.loading = false;\n            mutationStoreValue.error = error;\n          }\n          if (isOptimistic) {\n            this.cache.removeOptimistic(queryInfo.id);\n          }\n          this.broadcastQueries();\n          if (errorPolicy === \"ignore\") {\n            return resolve({\n              data: undefined\n            });\n          }\n          if (errorPolicy === \"all\") {\n            return resolve({\n              data: undefined,\n              error\n            });\n          }\n          reject(error);\n        }\n      });\n    });\n  }\n  fetchQuery(options, networkStatus) {\n    checkDocument(options.query, OperationTypeNode.QUERY);\n    // do the rest asynchronously to keep the same rejection timing as\n    // checks further in `.mutate`\n    return (async () => lastValueFrom(this.fetchObservableWithInfo(options, {\n      networkStatus\n    }).observable.pipe(filterMap(value => {\n      switch (value.kind) {\n        case \"E\":\n          throw value.error;\n        case \"N\":\n          {\n            if (value.source !== \"newNetworkStatus\") return toQueryResult(value.value);\n          }\n      }\n    })), {\n      // This default is needed when a `standby` fetch policy is used to avoid\n      // an EmptyError from rejecting this promise.\n      defaultValue: {\n        data: undefined\n      }\n    }))();\n  }\n  transform(document) {\n    return this.documentTransform.transformDocument(document);\n  }\n  transformCache = new AutoCleanedWeakCache(cacheSizes[\"queryManager.getDocumentInfo\"] || 2000 /* defaultCacheSizes[\"queryManager.getDocumentInfo\"] */);\n  getDocumentInfo(document) {\n    const {\n      transformCache\n    } = this;\n    if (!transformCache.has(document)) {\n      const operationDefinition = getOperationDefinition(document);\n      const cacheEntry = {\n        // TODO These three calls (hasClientExports, shouldForceResolvers, and\n        // usesNonreactiveDirective) are performing independent full traversals\n        // of the transformed document. We should consider merging these\n        // traversals into a single pass in the future, though the work is\n        // cached after the first time.\n        hasClientExports: hasDirectives([\"client\", \"export\"], document, true),\n        hasForcedResolvers: hasForcedResolvers(document),\n        hasNonreactiveDirective: hasDirectives([\"nonreactive\"], document),\n        hasIncrementalDirective: hasDirectives([\"defer\"], document),\n        nonReactiveQuery: addNonReactiveToNamedFragments(document),\n        clientQuery: hasDirectives([\"client\"], document) ? document : null,\n        serverQuery: removeDirectivesFromDocument([{\n          name: \"client\",\n          remove: true\n        }, {\n          name: \"connection\"\n        }, {\n          name: \"nonreactive\"\n        }, {\n          name: \"unmask\"\n        }], document),\n        operationType: operationDefinition?.operation,\n        defaultVars: getDefaultValues(operationDefinition),\n        // Transform any mutation or subscription operations to query operations\n        // so we can read/write them from/to the cache.\n        asQuery: {\n          ...document,\n          definitions: document.definitions.map(def => {\n            if (def.kind === \"OperationDefinition\" && def.operation !== \"query\") {\n              return {\n                ...def,\n                operation: \"query\"\n              };\n            }\n            return def;\n          })\n        }\n      };\n      transformCache.set(document, cacheEntry);\n    }\n    const entry = transformCache.get(document);\n    if (entry.violation) {\n      throw entry.violation;\n    }\n    return entry;\n  }\n  getVariables(document, variables) {\n    const defaultVars = this.getDocumentInfo(document).defaultVars;\n    const varsWithDefaults = Object.entries(variables ?? {}).map(([key, value]) => [key, value === undefined ? defaultVars[key] : value]);\n    return {\n      ...defaultVars,\n      ...Object.fromEntries(varsWithDefaults)\n    };\n  }\n  watchQuery(options) {\n    checkDocument(options.query, OperationTypeNode.QUERY);\n    const query = this.transform(options.query);\n    // assign variable default values if supplied\n    // NOTE: We don't modify options.query here with the transformed query to\n    // ensure observable.options.query is set to the raw untransformed query.\n    options = {\n      ...options,\n      variables: this.getVariables(query, options.variables)\n    };\n    if (typeof options.notifyOnNetworkStatusChange === \"undefined\") {\n      options.notifyOnNetworkStatusChange = true;\n    }\n    const observable = new ObservableQuery({\n      queryManager: this,\n      options,\n      transformedQuery: query\n    });\n    return observable;\n  }\n  query(options) {\n    const query = this.transform(options.query);\n    return this.fetchQuery({\n      ...options,\n      query\n    }).then(value => ({\n      ...value,\n      data: this.maskOperation({\n        document: query,\n        data: value?.data,\n        fetchPolicy: options.fetchPolicy\n      })\n    }));\n  }\n  requestIdCounter = 1;\n  generateRequestId() {\n    return this.requestIdCounter++;\n  }\n  clearStore(options = {\n    discardWatches: true\n  }) {\n    // Before we have sent the reset action to the store, we can no longer\n    // rely on the results returned by in-flight requests since these may\n    // depend on values that previously existed in the data portion of the\n    // store. So, we cancel the promises and observers that we have issued\n    // so far and not yet resolved (in the case of queries).\n    this.cancelPendingFetches(newInvariantError(85));\n    this.obsQueries.forEach(observableQuery => {\n      // Set loading to true so listeners don't trigger unless they want\n      // results with partial data.\n      observableQuery.reset();\n    });\n    if (this.mutationStore) {\n      this.mutationStore = {};\n    }\n    // begin removing data from the store\n    return this.cache.reset(options);\n  }\n  getObservableQueries(include = \"active\") {\n    const queries = new Set();\n    const queryNames = new Map();\n    const queryNamesAndQueryStrings = new Map();\n    const legacyQueryOptions = new Set();\n    if (Array.isArray(include)) {\n      include.forEach(desc => {\n        if (typeof desc === \"string\") {\n          queryNames.set(desc, desc);\n          queryNamesAndQueryStrings.set(desc, false);\n        } else if (isDocumentNode(desc)) {\n          const queryString = print(this.transform(desc));\n          queryNames.set(queryString, getOperationName(desc));\n          queryNamesAndQueryStrings.set(queryString, false);\n        } else if (isNonNullObject(desc) && desc.query) {\n          legacyQueryOptions.add(desc);\n        }\n      });\n    }\n    this.obsQueries.forEach(oq => {\n      const document = print(this.transform(oq.options.query));\n      if (include === \"all\") {\n        queries.add(oq);\n        return;\n      }\n      const {\n        queryName,\n        options: {\n          fetchPolicy\n        }\n      } = oq;\n      if (include === \"active\" && fetchPolicy === \"standby\") {\n        return;\n      }\n      if (include === \"active\" || queryName && queryNamesAndQueryStrings.has(queryName) || document && queryNamesAndQueryStrings.has(document)) {\n        queries.add(oq);\n        if (queryName) queryNamesAndQueryStrings.set(queryName, true);\n        if (document) queryNamesAndQueryStrings.set(document, true);\n      }\n    });\n    if (legacyQueryOptions.size) {\n      legacyQueryOptions.forEach(options => {\n        const oq = new ObservableQuery({\n          queryManager: this,\n          options: {\n            ...options,\n            fetchPolicy: \"network-only\"\n          }\n        });\n        queries.add(oq);\n      });\n    }\n    if (__DEV__ && queryNamesAndQueryStrings.size) {\n      queryNamesAndQueryStrings.forEach((included, nameOrQueryString) => {\n        if (!included) {\n          const queryName = queryNames.get(nameOrQueryString);\n          if (queryName) {\n            __DEV__ && invariant.warn(86, queryName);\n          } else {\n            __DEV__ && invariant.warn(87);\n          }\n        }\n      });\n    }\n    return queries;\n  }\n  refetchObservableQueries(includeStandby = false) {\n    const observableQueryPromises = [];\n    this.getObservableQueries(includeStandby ? \"all\" : \"active\").forEach(observableQuery => {\n      const {\n        fetchPolicy\n      } = observableQuery.options;\n      if ((includeStandby || fetchPolicy !== \"standby\") && fetchPolicy !== \"cache-only\") {\n        observableQueryPromises.push(observableQuery.refetch());\n      }\n    });\n    this.broadcastQueries();\n    return Promise.all(observableQueryPromises);\n  }\n  startGraphQLSubscription(options) {\n    let {\n      query,\n      variables\n    } = options;\n    const {\n      fetchPolicy,\n      errorPolicy = \"none\",\n      context = {},\n      extensions = {}\n    } = options;\n    checkDocument(query, OperationTypeNode.SUBSCRIPTION);\n    query = this.transform(query);\n    variables = this.getVariables(query, variables);\n    let restart;\n    if (__DEV__) {\n      invariant(!this.getDocumentInfo(query).hasClientExports || this.localState, 88, getOperationName(query, \"(anonymous)\"));\n    }\n    const observable = (this.getDocumentInfo(query).hasClientExports ? from(this.localState.getExportedVariables({\n      client: this.client,\n      document: query,\n      variables,\n      context\n    })) : of(variables)).pipe(mergeMap(variables => {\n      const {\n        observable,\n        restart: res\n      } = this.getObservableFromLink(query, context, variables, extensions);\n      const queryInfo = new QueryInfo(this);\n      restart = res;\n      return observable.pipe(map(rawResult => {\n        queryInfo.markSubscriptionResult(rawResult, {\n          document: query,\n          variables,\n          errorPolicy,\n          cacheWriteBehavior: fetchPolicy === \"no-cache\" ? 0 /* CacheWriteBehavior.FORBID */ : 2 /* CacheWriteBehavior.MERGE */\n        });\n        const result = {\n          data: rawResult.data ?? undefined\n        };\n        if (graphQLResultHasError(rawResult)) {\n          result.error = new CombinedGraphQLErrors(rawResult);\n        } else if (graphQLResultHasProtocolErrors(rawResult)) {\n          result.error = rawResult.extensions[PROTOCOL_ERRORS_SYMBOL];\n          // Don't emit protocol errors added by HttpLink\n          delete rawResult.extensions[PROTOCOL_ERRORS_SYMBOL];\n        }\n        if (rawResult.extensions && Object.keys(rawResult.extensions).length) {\n          result.extensions = rawResult.extensions;\n        }\n        if (result.error && errorPolicy === \"none\") {\n          result.data = undefined;\n        }\n        if (errorPolicy === \"ignore\") {\n          delete result.error;\n        }\n        return result;\n      }), catchError(error => {\n        if (errorPolicy === \"ignore\") {\n          return of({\n            data: undefined\n          });\n        }\n        return of({\n          data: undefined,\n          error\n        });\n      }), filter(result => !!(result.data || result.error)));\n    }));\n    return Object.assign(observable, {\n      restart: () => restart?.()\n    });\n  }\n  broadcastQueries() {\n    if (this.onBroadcast) this.onBroadcast();\n    this.obsQueries.forEach(observableQuery => observableQuery.notify());\n  }\n  // Use protected instead of private field so\n  // @apollo/experimental-nextjs-app-support can access type info.\n  inFlightLinkObservables = new Trie(false);\n  getObservableFromLink(query, context, variables, extensions,\n  // Prefer context.queryDeduplication if specified.\n  deduplication = context?.queryDeduplication ?? this.queryDeduplication) {\n    let entry = {};\n    const {\n      serverQuery,\n      clientQuery,\n      operationType,\n      hasIncrementalDirective\n    } = this.getDocumentInfo(query);\n    const operationName = getOperationName(query);\n    const executeContext = {\n      client: this.client\n    };\n    if (serverQuery) {\n      const {\n        inFlightLinkObservables,\n        link\n      } = this;\n      try {\n        const operation = this.incrementalHandler.prepareRequest({\n          query: serverQuery,\n          variables,\n          context: {\n            ...this.defaultContext,\n            ...context,\n            queryDeduplication: deduplication\n          },\n          extensions\n        });\n        context = operation.context;\n        function withRestart(source) {\n          return new Observable(observer => {\n            function subscribe() {\n              return source.subscribe({\n                next: observer.next.bind(observer),\n                complete: observer.complete.bind(observer),\n                error: observer.error.bind(observer)\n              });\n            }\n            let subscription = subscribe();\n            entry.restart ||= () => {\n              subscription.unsubscribe();\n              subscription = subscribe();\n            };\n            return () => {\n              subscription.unsubscribe();\n              entry.restart = undefined;\n            };\n          });\n        }\n        if (deduplication) {\n          const printedServerQuery = print(serverQuery);\n          const varJson = canonicalStringify(variables);\n          entry = inFlightLinkObservables.lookup(printedServerQuery, varJson);\n          if (!entry.observable) {\n            entry.observable = execute(link, operation, executeContext).pipe(withRestart, finalize(() => {\n              if (inFlightLinkObservables.peek(printedServerQuery, varJson) === entry) {\n                inFlightLinkObservables.remove(printedServerQuery, varJson);\n              }\n            }),\n            // We don't want to replay the last emitted value for\n            // subscriptions and instead opt to wait to receive updates until\n            // the subscription emits new values.\n            operationType === OperationTypeNode.SUBSCRIPTION ? share() : shareReplay({\n              refCount: true\n            }));\n          }\n        } else {\n          entry.observable = execute(link, operation, executeContext).pipe(withRestart);\n        }\n      } catch (error) {\n        entry.observable = throwError(() => error);\n      }\n    } else {\n      entry.observable = of({\n        data: {}\n      });\n    }\n    if (clientQuery) {\n      const {\n        operation\n      } = getOperationDefinition(query);\n      if (__DEV__) {\n        invariant(this.localState, 89, operation[0].toUpperCase() + operation.slice(1), operationName ?? \"(anonymous)\");\n      }\n      invariant(!hasIncrementalDirective, 90, operation[0].toUpperCase() + operation.slice(1), operationName ?? \"(anonymous)\");\n      entry.observable = entry.observable.pipe(mergeMap(result => {\n        return from(this.localState.execute({\n          client: this.client,\n          document: clientQuery,\n          remoteResult: result,\n          context,\n          variables\n        }));\n      }));\n    }\n    return {\n      restart: () => entry.restart?.(),\n      observable: entry.observable.pipe(catchError(error => {\n        error = toErrorLike(error);\n        registerLinkError(error);\n        throw error;\n      }))\n    };\n  }\n  getResultsFromLink(options, {\n    queryInfo,\n    cacheWriteBehavior,\n    observableQuery\n  }) {\n    const requestId = queryInfo.lastRequestId = this.generateRequestId();\n    const {\n      errorPolicy\n    } = options;\n    // Performing transformForLink here gives this.cache a chance to fill in\n    // missing fragment definitions (for example) before sending this document\n    // through the link chain.\n    const linkDocument = this.cache.transformForLink(options.query);\n    return this.getObservableFromLink(linkDocument, options.context, options.variables).observable.pipe(map(incoming => {\n      // Use linkDocument rather than queryInfo.document so the\n      // operation/fragments used to write the result are the same as the\n      // ones used to obtain it from the link.\n      const result = queryInfo.markQueryResult(incoming, {\n        ...options,\n        document: linkDocument,\n        cacheWriteBehavior\n      });\n      const hasErrors = graphQLResultHasError(result);\n      if (hasErrors && errorPolicy === \"none\") {\n        queryInfo.resetLastWrite();\n        observableQuery?.[\"resetNotifications\"]();\n        throw new CombinedGraphQLErrors(result);\n      }\n      const aqr = {\n        data: result.data,\n        ...(queryInfo.hasNext ? {\n          loading: true,\n          networkStatus: NetworkStatus.streaming,\n          dataState: \"streaming\",\n          partial: true\n        } : {\n          dataState: result.data ? \"complete\" : \"empty\",\n          loading: false,\n          networkStatus: NetworkStatus.ready,\n          partial: !result.data\n        })\n      };\n      // In the case we start multiple network requests simulatenously, we\n      // want to ensure we properly set `data` if we're reporting on an old\n      // result which will not be caught by the conditional above that ends up\n      // throwing the markError result.\n      if (hasErrors) {\n        if (errorPolicy === \"none\") {\n          aqr.data = void 0;\n          aqr.dataState = \"empty\";\n        }\n        if (errorPolicy !== \"ignore\") {\n          aqr.error = new CombinedGraphQLErrors(result);\n          if (aqr.dataState !== \"streaming\") {\n            aqr.networkStatus = NetworkStatus.error;\n          }\n        }\n      }\n      return aqr;\n    }), catchError(error => {\n      // Avoid storing errors from older interrupted queries.\n      if (requestId >= queryInfo.lastRequestId && errorPolicy === \"none\") {\n        queryInfo.resetLastWrite();\n        observableQuery?.[\"resetNotifications\"]();\n        throw error;\n      }\n      const aqr = {\n        data: undefined,\n        dataState: \"empty\",\n        loading: false,\n        networkStatus: NetworkStatus.ready,\n        partial: true\n      };\n      if (errorPolicy !== \"ignore\") {\n        aqr.error = error;\n        aqr.networkStatus = NetworkStatus.error;\n      }\n      return of(aqr);\n    }));\n  }\n  fetchObservableWithInfo(options, {\n    // The initial networkStatus for this fetch, most often\n    // NetworkStatus.loading, but also possibly fetchMore, poll, refetch,\n    // or setVariables.\n    networkStatus = NetworkStatus.loading,\n    query = options.query,\n    fetchQueryOperator = x => x,\n    onCacheHit = () => {},\n    observableQuery\n  }) {\n    const variables = this.getVariables(query, options.variables);\n    const defaults = this.defaultOptions.watchQuery;\n    let {\n      fetchPolicy = defaults && defaults.fetchPolicy || \"cache-first\",\n      errorPolicy = defaults && defaults.errorPolicy || \"none\",\n      returnPartialData = false,\n      notifyOnNetworkStatusChange = true,\n      context = {}\n    } = options;\n    if (this.prioritizeCacheValues && (fetchPolicy === \"network-only\" || fetchPolicy === \"cache-and-network\")) {\n      fetchPolicy = \"cache-first\";\n    }\n    const normalized = Object.assign({}, options, {\n      query,\n      variables,\n      fetchPolicy,\n      errorPolicy,\n      returnPartialData,\n      notifyOnNetworkStatusChange,\n      context\n    });\n    const queryInfo = new QueryInfo(this, observableQuery);\n    const fromVariables = variables => {\n      // Since normalized is always a fresh copy of options, it's safe to\n      // modify its properties here, rather than creating yet another new\n      // WatchQueryOptions object.\n      normalized.variables = variables;\n      const cacheWriteBehavior = fetchPolicy === \"no-cache\" ? 0 /* CacheWriteBehavior.FORBID */\n      // Watched queries must opt into overwriting existing data on refetch,\n      // by passing refetchWritePolicy: \"overwrite\" in their WatchQueryOptions.\n      : networkStatus === NetworkStatus.refetch && normalized.refetchWritePolicy !== \"merge\" ? 1 /* CacheWriteBehavior.OVERWRITE */ : 2 /* CacheWriteBehavior.MERGE */;\n      const observableWithInfo = this.fetchQueryByPolicy(normalized, {\n        queryInfo,\n        cacheWriteBehavior,\n        onCacheHit,\n        observableQuery\n      });\n      observableWithInfo.observable = observableWithInfo.observable.pipe(fetchQueryOperator);\n      if (\n      // If we're in standby, postpone advancing options.fetchPolicy using\n      // applyNextFetchPolicy.\n      normalized.fetchPolicy !== \"standby\") {\n        observableQuery?.[\"applyNextFetchPolicy\"](\"after-fetch\", options);\n      }\n      return observableWithInfo;\n    };\n    // This cancel function needs to be set before the concast is created,\n    // in case concast creation synchronously cancels the request.\n    const cleanupCancelFn = () => {\n      this.fetchCancelFns.delete(queryInfo.id);\n    };\n    this.fetchCancelFns.set(queryInfo.id, error => {\n      fetchCancelSubject.next({\n        kind: \"E\",\n        error,\n        source: \"network\"\n      });\n    });\n    const fetchCancelSubject = new Subject();\n    let observable, containsDataFromLink;\n    // If the query has @export(as: ...) directives, then we need to\n    // process those directives asynchronously. When there are no\n    // @export directives (the common case), we deliberately avoid\n    // wrapping the result of this.fetchQueryByPolicy in a Promise,\n    // since the timing of result delivery is (unfortunately) important\n    // for backwards compatibility. TODO This code could be simpler if\n    // we deprecated and removed LocalState.\n    if (this.getDocumentInfo(normalized.query).hasClientExports) {\n      if (__DEV__) {\n        invariant(this.localState, 91, getOperationName(normalized.query, \"(anonymous)\"));\n      }\n      observable = from(this.localState.getExportedVariables({\n        client: this.client,\n        document: normalized.query,\n        variables: normalized.variables,\n        context: normalized.context\n      })).pipe(mergeMap(variables => fromVariables(variables).observable));\n      // there is just no way we can synchronously get the *right* value here,\n      // so we will assume `true`, which is the behaviour before the bug fix in\n      // #10597. This means that bug is not fixed in that case, and is probably\n      // un-fixable with reasonable effort for the edge case of @export as\n      // directives.\n      containsDataFromLink = true;\n    } else {\n      const sourcesWithInfo = fromVariables(normalized.variables);\n      containsDataFromLink = sourcesWithInfo.fromLink;\n      observable = sourcesWithInfo.observable;\n    }\n    return {\n      // Merge `observable` with `fetchCancelSubject`, in a way that completing or\n      // erroring either of them will complete the merged obserable.\n      observable: new Observable(observer => {\n        observer.add(cleanupCancelFn);\n        observable.subscribe(observer);\n        fetchCancelSubject.subscribe(observer);\n      }).pipe(share()),\n      fromLink: containsDataFromLink\n    };\n  }\n  refetchQueries({\n    updateCache,\n    include,\n    optimistic = false,\n    removeOptimistic = optimistic ? makeUniqueId(\"refetchQueries\") : void 0,\n    onQueryUpdated\n  }) {\n    const includedQueriesByOq = new Map();\n    if (include) {\n      this.getObservableQueries(include).forEach(oq => {\n        if (oq.options.fetchPolicy === \"cache-only\") {\n          return;\n        }\n        const current = oq.getCurrentResult();\n        includedQueriesByOq.set(oq, {\n          oq,\n          lastDiff: {\n            result: current?.data,\n            complete: !current?.partial\n          }\n        });\n      });\n    }\n    const results = new Map();\n    if (updateCache) {\n      const handled = new Set();\n      this.cache.batch({\n        update: updateCache,\n        // Since you can perform any combination of cache reads and/or writes in\n        // the cache.batch update function, its optimistic option can be either\n        // a boolean or a string, representing three distinct modes of\n        // operation:\n        //\n        // * false: read/write only the root layer\n        // * true: read/write the topmost layer\n        // * string: read/write a fresh optimistic layer with that ID string\n        //\n        // When typeof optimistic === \"string\", a new optimistic layer will be\n        // temporarily created within cache.batch with that string as its ID. If\n        // we then pass that same string as the removeOptimistic option, we can\n        // make cache.batch immediately remove the optimistic layer after\n        // running the updateCache function, triggering only one broadcast.\n        //\n        // However, the refetchQueries method accepts only true or false for its\n        // optimistic option (not string). We interpret true to mean a temporary\n        // optimistic layer should be created, to allow efficiently rolling back\n        // the effect of the updateCache function, which involves passing a\n        // string instead of true as the optimistic option to cache.batch, when\n        // refetchQueries receives optimistic: true.\n        //\n        // In other words, we are deliberately not supporting the use case of\n        // writing to an *existing* optimistic layer (using the refetchQueries\n        // updateCache function), since that would potentially interfere with\n        // other optimistic updates in progress. Instead, you can read/write\n        // only the root layer by passing optimistic: false to refetchQueries,\n        // or you can read/write a brand new optimistic layer that will be\n        // automatically removed by passing optimistic: true.\n        optimistic: optimistic && removeOptimistic || false,\n        // The removeOptimistic option can also be provided by itself, even if\n        // optimistic === false, to remove some previously-added optimistic\n        // layer safely and efficiently, like we do in markMutationResult.\n        //\n        // If an explicit removeOptimistic string is provided with optimistic:\n        // true, the removeOptimistic string will determine the ID of the\n        // temporary optimistic layer, in case that ever matters.\n        removeOptimistic,\n        onWatchUpdated(watch, diff, lastDiff) {\n          const oq = watch.watcher;\n          if (oq instanceof ObservableQuery && !handled.has(oq)) {\n            handled.add(oq);\n            if (onQueryUpdated) {\n              // Since we're about to handle this query now, remove it from\n              // includedQueriesById, in case it was added earlier because of\n              // options.include.\n              includedQueriesByOq.delete(oq);\n              let result = onQueryUpdated(oq, diff, lastDiff);\n              if (result === true) {\n                // The onQueryUpdated function requested the default refetching\n                // behavior by returning true.\n                result = oq.refetch().retain(\n\n                  /* create a persistent subscription on the query */);\n              }\n              // Record the result in the results Map, as long as onQueryUpdated\n              // did not return false to skip/ignore this result.\n              if (result !== false) {\n                results.set(oq, result);\n              }\n              // Allow the default cache broadcast to happen, except when\n              // onQueryUpdated returns false.\n              return result;\n            }\n            if (onQueryUpdated !== null && oq.options.fetchPolicy !== \"cache-only\") {\n              // If we don't have an onQueryUpdated function, and onQueryUpdated\n              // was not disabled by passing null, make sure this query is\n              // \"included\" like any other options.include-specified query.\n              includedQueriesByOq.set(oq, {\n                oq,\n                lastDiff,\n                diff\n              });\n            }\n          }\n        }\n      });\n    }\n    if (includedQueriesByOq.size) {\n      includedQueriesByOq.forEach(({\n        oq,\n        lastDiff,\n        diff\n      }) => {\n        let result;\n        // If onQueryUpdated is provided, we want to use it for all included\n        // queries, even the QueryOptions ones.\n        if (onQueryUpdated) {\n          if (!diff) {\n            diff = oq.getCacheDiff();\n          }\n          result = onQueryUpdated(oq, diff, lastDiff);\n        }\n        // Otherwise, we fall back to refetching.\n        if (!onQueryUpdated || result === true) {\n          result = oq.refetch().retain(\n\n            /* create a persistent subscription on the query */);\n        }\n        if (result !== false) {\n          results.set(oq, result);\n        }\n      });\n    }\n    if (removeOptimistic) {\n      // In case no updateCache callback was provided (so cache.batch was not\n      // called above, and thus did not already remove the optimistic layer),\n      // remove it here. Since this is a no-op when the layer has already been\n      // removed, we do it even if we called cache.batch above, since it's\n      // possible this.cache is an instance of some ApolloCache subclass other\n      // than InMemoryCache, and does not fully support the removeOptimistic\n      // option for cache.batch.\n      this.cache.removeOptimistic(removeOptimistic);\n    }\n    return results;\n  }\n  noCacheWarningsByCause = new WeakSet();\n  maskOperation(options) {\n    const {\n      document,\n      data\n    } = options;\n    if (__DEV__) {\n      const {\n        fetchPolicy,\n        cause = {}\n      } = options;\n      const operationType = getOperationDefinition(document)?.operation;\n      if (this.dataMasking && fetchPolicy === \"no-cache\" && !isFullyUnmaskedOperation(document) && !this.noCacheWarningsByCause.has(cause)) {\n        this.noCacheWarningsByCause.add(cause);\n        __DEV__ && invariant.warn(92, getOperationName(document, `Unnamed ${operationType ?? \"operation\"}`));\n      }\n    }\n    return this.dataMasking ? maskOperation(data, document, this.cache) : data;\n  }\n  maskFragment(options) {\n    const {\n      data,\n      fragment,\n      fragmentName\n    } = options;\n    return this.dataMasking ? maskFragment(data, fragment, this.cache, fragmentName) : data;\n  }\n  fetchQueryByPolicy({\n    query,\n    variables,\n    fetchPolicy,\n    errorPolicy,\n    returnPartialData,\n    context\n  }, {\n    cacheWriteBehavior,\n    onCacheHit,\n    queryInfo,\n    observableQuery\n  }) {\n    const readCache = () => this.cache.diff({\n      query,\n      variables,\n      returnPartialData: true,\n      optimistic: true\n    });\n    const resultsFromCache = (diff, networkStatus) => {\n      const data = diff.result;\n      if (__DEV__ && !returnPartialData && data !== null) {\n        logMissingFieldErrors(diff.missing);\n      }\n      const toResult = data => {\n        // TODO: Eventually we should move this handling into\n        // queryInfo.getDiff() directly. Since getDiff is updated to return null\n        // on returnPartialData: false, we should take advantage of that instead\n        // of having to patch it elsewhere.\n        if (!diff.complete && !returnPartialData) {\n          data = undefined;\n        }\n        return {\n          // TODO: Handle partial data\n          data: data,\n          dataState: diff.complete ? \"complete\" : data ? \"partial\" : \"empty\",\n          loading: isNetworkRequestInFlight(networkStatus),\n          networkStatus,\n          partial: !diff.complete\n        };\n      };\n      const fromData = data => {\n        return of({\n          kind: \"N\",\n          value: toResult(data),\n          source: \"cache\"\n        });\n      };\n      if (\n      // Don't attempt to run forced resolvers if we have incomplete cache\n      // data and partial isn't allowed since this result would get set to\n      // `undefined` anyways in `toResult`.\n      (diff.complete || returnPartialData) && this.getDocumentInfo(query).hasForcedResolvers) {\n        if (__DEV__) {\n          invariant(this.localState, 93, getOperationName(query, \"(anonymous)\"));\n        }\n        onCacheHit();\n        return from(this.localState.execute({\n          client: this.client,\n          document: query,\n          remoteResult: data ? {\n            data\n          } : undefined,\n          context,\n          variables,\n          onlyRunForcedResolvers: true,\n          returnPartialData: true\n        }).then(resolved => ({\n          kind: \"N\",\n          value: toResult(resolved.data || void 0),\n          source: \"cache\"\n        })));\n      }\n      // Resolves https://github.com/apollographql/apollo-client/issues/10317.\n      // If errorPolicy is 'none' and notifyOnNetworkStatusChange is true,\n      // data was incorrectly returned from the cache on refetch:\n      // if diff.missing exists, we should not return cache data.\n      if (errorPolicy === \"none\" && networkStatus === NetworkStatus.refetch && diff.missing) {\n        return fromData(void 0);\n      }\n      return fromData(data || undefined);\n    };\n    const resultsFromLink = () => this.getResultsFromLink({\n      query,\n      variables,\n      context,\n      fetchPolicy,\n      errorPolicy\n    }, {\n      cacheWriteBehavior,\n      queryInfo,\n      observableQuery\n    }).pipe(validateDidEmitValue(), materialize(), map(result => ({\n      ...result,\n      source: \"network\"\n    })));\n    switch (fetchPolicy) {\n      default:\n      case \"cache-first\":\n        {\n          const diff = readCache();\n          if (diff.complete) {\n            return {\n              fromLink: false,\n              observable: resultsFromCache(diff, NetworkStatus.ready)\n            };\n          }\n          if (returnPartialData) {\n            return {\n              fromLink: true,\n              observable: concat(resultsFromCache(diff, NetworkStatus.loading), resultsFromLink())\n            };\n          }\n          return {\n            fromLink: true,\n            observable: resultsFromLink()\n          };\n        }\n      case \"cache-and-network\":\n        {\n          const diff = readCache();\n          if (diff.complete || returnPartialData) {\n            return {\n              fromLink: true,\n              observable: concat(resultsFromCache(diff, NetworkStatus.loading), resultsFromLink())\n            };\n          }\n          return {\n            fromLink: true,\n            observable: resultsFromLink()\n          };\n        }\n      case \"cache-only\":\n        return {\n          fromLink: false,\n          observable: concat(resultsFromCache(readCache(), NetworkStatus.ready))\n        };\n      case \"network-only\":\n        return {\n          fromLink: true,\n          observable: resultsFromLink()\n        };\n      case \"no-cache\":\n        return {\n          fromLink: true,\n          observable: resultsFromLink()\n        };\n      case \"standby\":\n        return {\n          fromLink: false,\n          observable: EMPTY\n        };\n    }\n  }\n}\nfunction validateDidEmitValue() {\n  let didEmitValue = false;\n  return tap({\n    next() {\n      didEmitValue = true;\n    },\n    complete() {\n      invariant(didEmitValue, 94);\n    }\n  });\n}\nfunction isFullyUnmaskedOperation(document) {\n  let isUnmasked = true;\n  visit(document, {\n    FragmentSpread: node => {\n      isUnmasked = !!node.directives && node.directives.some(directive => directive.name.value === \"unmask\");\n      if (!isUnmasked) {\n        return BREAK;\n      }\n    }\n  });\n  return isUnmasked;\n}\nfunction addNonReactiveToNamedFragments(document) {\n  return visit(document, {\n    FragmentSpread: node => {\n      // Do not add `@nonreactive` if the fragment is marked with `@unmask`\n      // since we want to react to changes in this fragment.\n      if (node.directives?.some(directive => directive.name.value === \"unmask\")) {\n        return;\n      }\n      return {\n        ...node,\n        directives: [...(node.directives || []), {\n          kind: Kind.DIRECTIVE,\n          name: {\n            kind: Kind.NAME,\n            value: \"nonreactive\"\n          }\n        }]\n      };\n    }\n  });\n}","map":{"version":3,"names":["Trie","BREAK","Kind","OperationTypeNode","visit","Observable","throwError","catchError","concat","EMPTY","filter","finalize","from","lastValueFrom","map","materialize","mergeMap","of","share","shareReplay","Subject","tap","canonicalStringify","CombinedGraphQLErrors","graphQLResultHasProtocolErrors","registerLinkError","toErrorLike","PROTOCOL_ERRORS_SYMBOL","execute","maskFragment","maskOperation","cacheSizes","DocumentTransform","isNetworkRequestInFlight","print","__DEV__","AutoCleanedWeakCache","checkDocument","filterMap","getDefaultValues","getOperationDefinition","getOperationName","graphQLResultHasError","hasDirectives","hasForcedResolvers","isDocumentNode","isNonNullObject","makeUniqueId","removeDirectivesFromDocument","toQueryResult","invariant","newInvariantError","NetworkStatus","logMissingFieldErrors","ObservableQuery","QueryInfo","QueryManager","defaultOptions","client","clientOptions","assumeImmutableResults","documentTransform","ssrMode","defaultContext","dataMasking","incrementalHandler","localState","queryDeduplication","prioritizeCacheValues","onBroadcast","mutationStore","obsQueries","Set","fetchCancelFns","Map","constructor","options","defaultDocumentTransform","document","cache","transformDocument","link","stop","forEach","oq","cancelPendingFetches","error","cancel","clear","mutate","mutation","variables","optimisticResponse","updateQueries","refetchQueries","awaitRefetchQueries","update","updateWithProxyFn","onQueryUpdated","fetchPolicy","errorPolicy","keepRootFields","context","queryInfo","transformForLink","transform","hasClientExports","getDocumentInfo","getVariables","getExportedVariables","mutationStoreValue","id","loading","isOptimistic","markMutationOptimistic","cacheWriteBehavior","broadcastQueries","Promise","resolve","reject","cause","getObservableFromLink","observable","pipe","validateDidEmitValue","result","storeResult","markMutationResult","removeOptimistic","hasErrors","subscribe","next","hasNext","data","Object","keys","extensions","length","undefined","fetchQuery","networkStatus","query","QUERY","fetchObservableWithInfo","value","kind","source","defaultValue","transformCache","has","operationDefinition","cacheEntry","hasNonreactiveDirective","hasIncrementalDirective","nonReactiveQuery","addNonReactiveToNamedFragments","clientQuery","serverQuery","name","remove","operationType","operation","defaultVars","asQuery","definitions","def","set","entry","get","violation","varsWithDefaults","entries","key","fromEntries","watchQuery","notifyOnNetworkStatusChange","queryManager","transformedQuery","then","requestIdCounter","generateRequestId","clearStore","discardWatches","observableQuery","reset","getObservableQueries","include","queries","queryNames","queryNamesAndQueryStrings","legacyQueryOptions","Array","isArray","desc","queryString","add","queryName","size","included","nameOrQueryString","warn","refetchObservableQueries","includeStandby","observableQueryPromises","push","refetch","all","startGraphQLSubscription","SUBSCRIPTION","restart","res","rawResult","markSubscriptionResult","assign","notify","inFlightLinkObservables","deduplication","operationName","executeContext","prepareRequest","withRestart","observer","bind","complete","subscription","unsubscribe","printedServerQuery","varJson","lookup","peek","refCount","toUpperCase","slice","remoteResult","getResultsFromLink","requestId","lastRequestId","linkDocument","incoming","markQueryResult","resetLastWrite","aqr","streaming","dataState","partial","ready","fetchQueryOperator","x","onCacheHit","defaults","returnPartialData","normalized","fromVariables","refetchWritePolicy","observableWithInfo","fetchQueryByPolicy","cleanupCancelFn","delete","fetchCancelSubject","containsDataFromLink","sourcesWithInfo","fromLink","updateCache","optimistic","includedQueriesByOq","current","getCurrentResult","lastDiff","results","handled","batch","onWatchUpdated","watch","diff","watcher","retain","getCacheDiff","noCacheWarningsByCause","WeakSet","isFullyUnmaskedOperation","fragment","fragmentName","readCache","resultsFromCache","missing","toResult","fromData","onlyRunForcedResolvers","resolved","resultsFromLink","didEmitValue","isUnmasked","FragmentSpread","node","directives","some","directive","DIRECTIVE","NAME"],"sources":["/home/saurabh-shukla/Desktop/Slack Lite/frontend/node_modules/@apollo/src/core/QueryManager.ts"],"sourcesContent":["import { Trie } from \"@wry/trie\";\nimport type {\n  DirectiveNode,\n  DocumentNode,\n  FormattedExecutionResult,\n} from \"graphql\";\nimport { BREAK, Kind, OperationTypeNode, visit } from \"graphql\";\nimport { Observable, throwError } from \"rxjs\";\nimport {\n  catchError,\n  concat,\n  EMPTY,\n  filter,\n  finalize,\n  from,\n  lastValueFrom,\n  map,\n  materialize,\n  mergeMap,\n  of,\n  share,\n  shareReplay,\n  Subject,\n  tap,\n} from \"rxjs\";\n\nimport type { ApolloCache, Cache } from \"@apollo/client/cache\";\nimport { canonicalStringify } from \"@apollo/client/cache\";\nimport {\n  CombinedGraphQLErrors,\n  graphQLResultHasProtocolErrors,\n  registerLinkError,\n  toErrorLike,\n} from \"@apollo/client/errors\";\nimport { PROTOCOL_ERRORS_SYMBOL } from \"@apollo/client/errors\";\nimport type { Incremental } from \"@apollo/client/incremental\";\nimport type { ApolloLink } from \"@apollo/client/link\";\nimport { execute } from \"@apollo/client/link\";\nimport type { LocalState } from \"@apollo/client/local-state\";\nimport type { MaybeMasked } from \"@apollo/client/masking\";\nimport { maskFragment, maskOperation } from \"@apollo/client/masking\";\nimport type { DeepPartial } from \"@apollo/client/utilities\";\nimport {\n  cacheSizes,\n  DocumentTransform,\n  isNetworkRequestInFlight,\n  print,\n} from \"@apollo/client/utilities\";\nimport { __DEV__ } from \"@apollo/client/utilities/environment\";\nimport {\n  AutoCleanedWeakCache,\n  checkDocument,\n  filterMap,\n  getDefaultValues,\n  getOperationDefinition,\n  getOperationName,\n  graphQLResultHasError,\n  hasDirectives,\n  hasForcedResolvers,\n  isDocumentNode,\n  isNonNullObject,\n  makeUniqueId,\n  removeDirectivesFromDocument,\n  toQueryResult,\n} from \"@apollo/client/utilities/internal\";\nimport {\n  invariant,\n  newInvariantError,\n} from \"@apollo/client/utilities/invariant\";\n\nimport { defaultCacheSizes } from \"../utilities/caching/sizes.js\";\n\nimport type { ApolloClient } from \"./ApolloClient.js\";\nimport { NetworkStatus } from \"./networkStatus.js\";\nimport { logMissingFieldErrors, ObservableQuery } from \"./ObservableQuery.js\";\nimport { CacheWriteBehavior, QueryInfo } from \"./QueryInfo.js\";\nimport type {\n  DefaultContext,\n  InternalRefetchQueriesInclude,\n  InternalRefetchQueriesMap,\n  InternalRefetchQueriesOptions,\n  InternalRefetchQueriesResult,\n  OperationVariables,\n  QueryNotification,\n  SubscriptionObservable,\n  TypedDocumentNode,\n} from \"./types.js\";\nimport type {\n  ErrorPolicy,\n  MutationFetchPolicy,\n  WatchQueryFetchPolicy,\n} from \"./watchQueryOptions.js\";\n\ninterface MutationStoreValue {\n  mutation: DocumentNode;\n  variables: Record<string, any>;\n  loading: boolean;\n  error: Error | null;\n}\n\ninterface TransformCacheEntry {\n  hasClientExports: boolean;\n  hasForcedResolvers: boolean;\n  hasNonreactiveDirective: boolean;\n  hasIncrementalDirective: boolean;\n  nonReactiveQuery: DocumentNode;\n  clientQuery: DocumentNode | null;\n  serverQuery: DocumentNode | null;\n  defaultVars: OperationVariables;\n  asQuery: DocumentNode;\n  operationType: OperationTypeNode | undefined;\n  violation?: Error | undefined;\n}\n\ninterface MaskFragmentOptions<TData> {\n  fragment: DocumentNode;\n  data: TData;\n  fragmentName?: string;\n}\n\ninterface MaskOperationOptions<TData> {\n  document: DocumentNode;\n  data: TData;\n  /**\n   * Can be used to identify the cause to prevent warning for the same cause twice.\n   * This would be an object like e.g. an `ObervableQuery`.\n   * If the `cause` is not provided, we will warn every time.\n   */\n  cause?: object;\n  fetchPolicy?: WatchQueryFetchPolicy;\n}\n\ninterface QueryManagerOptions {\n  client: ApolloClient;\n  clientOptions: ApolloClient.Options;\n  defaultOptions: ApolloClient.DefaultOptions;\n  documentTransform: DocumentTransform | null | undefined;\n  queryDeduplication: boolean;\n  onBroadcast: undefined | (() => void);\n  ssrMode: boolean;\n  assumeImmutableResults: boolean;\n  defaultContext: Partial<DefaultContext> | undefined;\n  dataMasking: boolean;\n  localState: LocalState | undefined;\n  incrementalHandler: Incremental.Handler;\n}\n\nexport class QueryManager {\n  public defaultOptions: ApolloClient.DefaultOptions;\n\n  public readonly client: ApolloClient;\n  /**\n   * The options that were passed to the ApolloClient constructor.\n   */\n  public readonly clientOptions: ApolloClient.Options;\n  public readonly assumeImmutableResults: boolean;\n  public readonly documentTransform: DocumentTransform;\n  public readonly ssrMode: boolean;\n  public readonly defaultContext: Partial<DefaultContext>;\n  public readonly dataMasking: boolean;\n  public readonly incrementalHandler: Incremental.Handler;\n  public localState: LocalState | undefined;\n\n  private queryDeduplication: boolean;\n\n  /**\n   * Whether to prioritize cache values over network results when\n   * `fetchObservableWithInfo` is called.\n   * This will essentially turn a `\"network-only\"` or `\"cache-and-network\"`\n   * fetchPolicy into a `\"cache-first\"` fetchPolicy, but without influencing\n   * the `fetchPolicy` of the `ObservableQuery`.\n   *\n   * This can e.g. be used to prioritize the cache during the first render after\n   * SSR.\n   */\n  public prioritizeCacheValues: boolean = false;\n\n  private onBroadcast?: () => void;\n  public mutationStore?: {\n    [mutationId: string]: MutationStoreValue;\n  };\n\n  /**\n   * All ObservableQueries that currently have at least one subscriber.\n   */\n  public obsQueries = new Set<ObservableQuery<any, any>>();\n\n  // Maps from queryInfo.id strings to Promise rejection functions for\n  // currently active queries and fetches.\n  // Use protected instead of private field so\n  // @apollo/experimental-nextjs-app-support can access type info.\n  protected fetchCancelFns = new Map<string, (error: any) => any>();\n\n  constructor(options: QueryManagerOptions) {\n    const defaultDocumentTransform = new DocumentTransform(\n      (document) => this.cache.transformDocument(document),\n      // Allow the apollo cache to manage its own transform caches\n      { cache: false }\n    );\n\n    this.client = options.client;\n    this.defaultOptions = options.defaultOptions;\n    this.queryDeduplication = options.queryDeduplication;\n    this.clientOptions = options.clientOptions;\n    this.ssrMode = options.ssrMode;\n    this.assumeImmutableResults = options.assumeImmutableResults;\n    this.dataMasking = options.dataMasking;\n    this.localState = options.localState;\n    this.incrementalHandler = options.incrementalHandler;\n    const documentTransform = options.documentTransform;\n    this.documentTransform =\n      documentTransform ?\n        defaultDocumentTransform\n          .concat(documentTransform)\n          // The custom document transform may add new fragment spreads or new\n          // field selections, so we want to give the cache a chance to run\n          // again. For example, the InMemoryCache adds __typename to field\n          // selections and fragments from the fragment registry.\n          .concat(defaultDocumentTransform)\n      : defaultDocumentTransform;\n    this.defaultContext = options.defaultContext || {};\n\n    if ((this.onBroadcast = options.onBroadcast)) {\n      this.mutationStore = {};\n    }\n  }\n\n  get link() {\n    return this.client.link;\n  }\n\n  get cache() {\n    return this.client.cache;\n  }\n\n  /**\n   * Call this method to terminate any active query processes, making it safe\n   * to dispose of this QueryManager instance.\n   */\n  public stop() {\n    this.obsQueries.forEach((oq) => oq.stop());\n\n    this.cancelPendingFetches(\n      newInvariantError(\"QueryManager stopped while query was in flight\")\n    );\n  }\n\n  private cancelPendingFetches(error: Error) {\n    this.fetchCancelFns.forEach((cancel) => cancel(error));\n    this.fetchCancelFns.clear();\n  }\n\n  public async mutate<\n    TData,\n    TVariables extends OperationVariables,\n    TCache extends ApolloCache,\n  >({\n    mutation,\n    variables,\n    optimisticResponse,\n    updateQueries,\n    refetchQueries = [],\n    awaitRefetchQueries = false,\n    update: updateWithProxyFn,\n    onQueryUpdated,\n    fetchPolicy,\n    errorPolicy,\n    keepRootFields,\n    context,\n  }: ApolloClient.MutateOptions<TData, TVariables, TCache> & {\n    errorPolicy: ErrorPolicy;\n    fetchPolicy: MutationFetchPolicy;\n  }): Promise<ApolloClient.MutateResult<MaybeMasked<TData>>> {\n    const queryInfo = new QueryInfo<TData, TVariables, TCache>(this);\n\n    mutation = this.cache.transformForLink(this.transform(mutation));\n    const { hasClientExports } = this.getDocumentInfo(mutation);\n\n    variables = this.getVariables(mutation, variables);\n\n    if (hasClientExports) {\n      if (__DEV__) {\n        invariant(\n          this.localState,\n          \"Mutation '%s' contains `@client` fields with variables provided by `@export` but local state has not been configured.\",\n          getOperationName(mutation, \"(anonymous)\")\n        );\n      }\n\n      variables = await this.localState!.getExportedVariables<TVariables>({\n        client: this.client,\n        document: mutation,\n        variables,\n        context,\n      });\n    }\n\n    const mutationStoreValue =\n      this.mutationStore &&\n      (this.mutationStore[queryInfo.id] = {\n        mutation,\n        variables,\n        loading: true,\n        error: null,\n      } as MutationStoreValue);\n\n    const isOptimistic =\n      optimisticResponse &&\n      queryInfo.markMutationOptimistic(optimisticResponse, {\n        document: mutation,\n        variables,\n        cacheWriteBehavior:\n          fetchPolicy === \"no-cache\" ?\n            CacheWriteBehavior.FORBID\n          : CacheWriteBehavior.MERGE,\n        errorPolicy,\n        context,\n        updateQueries,\n        update: updateWithProxyFn,\n        keepRootFields,\n      });\n\n    this.broadcastQueries();\n\n    return new Promise((resolve, reject) => {\n      const cause = {};\n      return this.getObservableFromLink<TData>(\n        mutation,\n        {\n          ...context,\n          optimisticResponse: isOptimistic ? optimisticResponse : void 0,\n        },\n        variables,\n        {},\n        false\n      )\n        .observable.pipe(\n          validateDidEmitValue(),\n          mergeMap((result) => {\n            const storeResult: typeof result = { ...result };\n\n            return from(\n              queryInfo.markMutationResult(storeResult, {\n                document: mutation,\n                variables,\n                cacheWriteBehavior:\n                  fetchPolicy === \"no-cache\" ?\n                    CacheWriteBehavior.FORBID\n                  : CacheWriteBehavior.MERGE,\n                errorPolicy,\n                context,\n                update: updateWithProxyFn,\n                updateQueries,\n                awaitRefetchQueries,\n                refetchQueries,\n                removeOptimistic: isOptimistic ? queryInfo.id : void 0,\n                onQueryUpdated,\n                keepRootFields,\n              })\n            );\n          })\n        )\n        .pipe(\n          map((storeResult) => {\n            const hasErrors = graphQLResultHasError(storeResult);\n            if (hasErrors && errorPolicy === \"none\") {\n              throw new CombinedGraphQLErrors(storeResult);\n            }\n\n            if (mutationStoreValue) {\n              mutationStoreValue.loading = false;\n              mutationStoreValue.error = null;\n            }\n\n            return storeResult;\n          })\n        )\n        .subscribe({\n          next: (storeResult) => {\n            this.broadcastQueries();\n\n            // Since mutations might receive multiple payloads from the\n            // ApolloLink chain (e.g. when used with @defer),\n            // we resolve with a SingleExecutionResult or after the final\n            // ExecutionPatchResult has arrived and we have assembled the\n            // multipart response into a single result.\n            if (!queryInfo.hasNext) {\n              const result: ApolloClient.MutateResult<TData> = {\n                data: this.maskOperation({\n                  document: mutation,\n                  data: storeResult.data,\n                  fetchPolicy,\n                  cause,\n                }) as any,\n              };\n\n              if (graphQLResultHasError(storeResult)) {\n                result.error = new CombinedGraphQLErrors(storeResult);\n              }\n\n              if (Object.keys(storeResult.extensions || {}).length) {\n                result.extensions = storeResult.extensions;\n              }\n\n              resolve(result);\n            }\n          },\n\n          error: (error) => {\n            if (mutationStoreValue) {\n              mutationStoreValue.loading = false;\n              mutationStoreValue.error = error;\n            }\n\n            if (isOptimistic) {\n              this.cache.removeOptimistic(queryInfo.id);\n            }\n\n            this.broadcastQueries();\n\n            if (errorPolicy === \"ignore\") {\n              return resolve({ data: undefined });\n            }\n\n            if (errorPolicy === \"all\") {\n              return resolve({ data: undefined, error });\n            }\n\n            reject(error);\n          },\n        });\n    });\n  }\n\n  public fetchQuery<TData, TVariables extends OperationVariables>(\n    options: ApolloClient.WatchQueryOptions<TData, TVariables>,\n    networkStatus?: NetworkStatus\n  ): Promise<ApolloClient.QueryResult<TData>> {\n    checkDocument(options.query, OperationTypeNode.QUERY);\n\n    // do the rest asynchronously to keep the same rejection timing as\n    // checks further in `.mutate`\n    return (async () =>\n      lastValueFrom(\n        this.fetchObservableWithInfo(options, {\n          networkStatus,\n        }).observable.pipe(\n          filterMap((value) => {\n            switch (value.kind) {\n              case \"E\":\n                throw value.error;\n              case \"N\": {\n                if (value.source !== \"newNetworkStatus\")\n                  return toQueryResult(value.value);\n              }\n            }\n          })\n        ),\n        {\n          // This default is needed when a `standby` fetch policy is used to avoid\n          // an EmptyError from rejecting this promise.\n          defaultValue: { data: undefined },\n        }\n      ))();\n  }\n\n  public transform(document: DocumentNode) {\n    return this.documentTransform.transformDocument(document);\n  }\n\n  private transformCache = new AutoCleanedWeakCache<\n    DocumentNode,\n    TransformCacheEntry\n  >(\n    cacheSizes[\"queryManager.getDocumentInfo\"] ||\n      defaultCacheSizes[\"queryManager.getDocumentInfo\"]\n  );\n\n  public getDocumentInfo(document: DocumentNode) {\n    const { transformCache } = this;\n\n    if (!transformCache.has(document)) {\n      const operationDefinition = getOperationDefinition(document);\n\n      const cacheEntry: TransformCacheEntry = {\n        // TODO These three calls (hasClientExports, shouldForceResolvers, and\n        // usesNonreactiveDirective) are performing independent full traversals\n        // of the transformed document. We should consider merging these\n        // traversals into a single pass in the future, though the work is\n        // cached after the first time.\n        hasClientExports: hasDirectives([\"client\", \"export\"], document, true),\n        hasForcedResolvers: hasForcedResolvers(document),\n        hasNonreactiveDirective: hasDirectives([\"nonreactive\"], document),\n        hasIncrementalDirective: hasDirectives([\"defer\"], document),\n        nonReactiveQuery: addNonReactiveToNamedFragments(document),\n        clientQuery: hasDirectives([\"client\"], document) ? document : null,\n        serverQuery: removeDirectivesFromDocument(\n          [\n            { name: \"client\", remove: true },\n            { name: \"connection\" },\n            { name: \"nonreactive\" },\n            { name: \"unmask\" },\n          ],\n          document\n        ),\n        operationType: operationDefinition?.operation,\n        defaultVars: getDefaultValues(\n          operationDefinition\n        ) as OperationVariables,\n        // Transform any mutation or subscription operations to query operations\n        // so we can read/write them from/to the cache.\n        asQuery: {\n          ...document,\n          definitions: document.definitions.map((def) => {\n            if (\n              def.kind === \"OperationDefinition\" &&\n              def.operation !== \"query\"\n            ) {\n              return { ...def, operation: \"query\" as OperationTypeNode };\n            }\n            return def;\n          }),\n        },\n      };\n\n      transformCache.set(document, cacheEntry);\n    }\n\n    const entry = transformCache.get(document)!;\n    if (entry.violation) {\n      throw entry.violation;\n    }\n    return entry;\n  }\n\n  public getVariables<TVariables extends OperationVariables>(\n    document: DocumentNode,\n    variables?: TVariables\n  ): TVariables {\n    const defaultVars = this.getDocumentInfo(document).defaultVars;\n    const varsWithDefaults = Object.entries(variables ?? {}).map(\n      ([key, value]) => [key, value === undefined ? defaultVars[key] : value]\n    );\n\n    return {\n      ...defaultVars,\n      ...Object.fromEntries(varsWithDefaults),\n    };\n  }\n\n  public watchQuery<\n    TData,\n    TVariables extends OperationVariables = OperationVariables,\n  >(\n    options: ApolloClient.WatchQueryOptions<TData, TVariables>\n  ): ObservableQuery<TData, TVariables> {\n    checkDocument(options.query, OperationTypeNode.QUERY);\n\n    const query = this.transform(options.query);\n\n    // assign variable default values if supplied\n    // NOTE: We don't modify options.query here with the transformed query to\n    // ensure observable.options.query is set to the raw untransformed query.\n    options = {\n      ...options,\n      variables: this.getVariables(query, options.variables) as TVariables,\n    };\n\n    if (typeof options.notifyOnNetworkStatusChange === \"undefined\") {\n      options.notifyOnNetworkStatusChange = true;\n    }\n\n    const observable = new ObservableQuery<TData, TVariables>({\n      queryManager: this,\n      options,\n      transformedQuery: query,\n    });\n\n    return observable;\n  }\n\n  public query<\n    TData,\n    TVariables extends OperationVariables = OperationVariables,\n  >(\n    options: ApolloClient.QueryOptions<TData, TVariables>\n  ): Promise<ApolloClient.QueryResult<MaybeMasked<TData>>> {\n    const query = this.transform(options.query);\n\n    return this.fetchQuery<TData, TVariables>({\n      ...(options as any),\n      query,\n    }).then((value) => ({\n      ...value,\n      data: this.maskOperation({\n        document: query,\n        data: value?.data,\n        fetchPolicy: options.fetchPolicy,\n      }),\n    }));\n  }\n\n  private requestIdCounter = 1;\n  public generateRequestId() {\n    return this.requestIdCounter++;\n  }\n\n  public clearStore(\n    options: Cache.ResetOptions = {\n      discardWatches: true,\n    }\n  ): Promise<void> {\n    // Before we have sent the reset action to the store, we can no longer\n    // rely on the results returned by in-flight requests since these may\n    // depend on values that previously existed in the data portion of the\n    // store. So, we cancel the promises and observers that we have issued\n    // so far and not yet resolved (in the case of queries).\n    this.cancelPendingFetches(\n      newInvariantError(\n        \"Store reset while query was in flight (not completed in link chain)\"\n      )\n    );\n\n    this.obsQueries.forEach((observableQuery) => {\n      // Set loading to true so listeners don't trigger unless they want\n      // results with partial data.\n      observableQuery.reset();\n    });\n\n    if (this.mutationStore) {\n      this.mutationStore = {};\n    }\n\n    // begin removing data from the store\n    return this.cache.reset(options);\n  }\n\n  public getObservableQueries(\n    include: InternalRefetchQueriesInclude = \"active\"\n  ) {\n    const queries = new Set<ObservableQuery<any>>();\n    const queryNames = new Map<string, string | undefined>();\n    const queryNamesAndQueryStrings = new Map<string, boolean>();\n    const legacyQueryOptions = new Set<ApolloClient.QueryOptions>();\n\n    if (Array.isArray(include)) {\n      include.forEach((desc) => {\n        if (typeof desc === \"string\") {\n          queryNames.set(desc, desc);\n          queryNamesAndQueryStrings.set(desc, false);\n        } else if (isDocumentNode(desc)) {\n          const queryString = print(this.transform(desc));\n          queryNames.set(queryString, getOperationName(desc));\n          queryNamesAndQueryStrings.set(queryString, false);\n        } else if (isNonNullObject(desc) && desc.query) {\n          legacyQueryOptions.add(desc);\n        }\n      });\n    }\n\n    this.obsQueries.forEach((oq) => {\n      const document = print(this.transform(oq.options.query));\n      if (include === \"all\") {\n        queries.add(oq);\n        return;\n      }\n\n      const {\n        queryName,\n        options: { fetchPolicy },\n      } = oq;\n\n      if (include === \"active\" && fetchPolicy === \"standby\") {\n        return;\n      }\n\n      if (\n        include === \"active\" ||\n        (queryName && queryNamesAndQueryStrings.has(queryName)) ||\n        (document && queryNamesAndQueryStrings.has(document))\n      ) {\n        queries.add(oq);\n        if (queryName) queryNamesAndQueryStrings.set(queryName, true);\n        if (document) queryNamesAndQueryStrings.set(document, true);\n      }\n    });\n\n    if (legacyQueryOptions.size) {\n      legacyQueryOptions.forEach((options) => {\n        const oq = new ObservableQuery({\n          queryManager: this,\n          options: {\n            ...options,\n            fetchPolicy: \"network-only\",\n          },\n        });\n        queries.add(oq);\n      });\n    }\n\n    if (__DEV__ && queryNamesAndQueryStrings.size) {\n      queryNamesAndQueryStrings.forEach((included, nameOrQueryString) => {\n        if (!included) {\n          const queryName = queryNames.get(nameOrQueryString);\n\n          if (queryName) {\n            invariant.warn(\n              `Unknown query named \"%s\" requested in refetchQueries options.include array`,\n              queryName\n            );\n          } else {\n            invariant.warn(\n              `Unknown anonymous query requested in refetchQueries options.include array`\n            );\n          }\n        }\n      });\n    }\n\n    return queries;\n  }\n\n  public refetchObservableQueries(\n    includeStandby: boolean = false\n  ): Promise<ApolloClient.QueryResult<any>[]> {\n    const observableQueryPromises: Promise<ApolloClient.QueryResult<any>>[] =\n      [];\n\n    this.getObservableQueries(includeStandby ? \"all\" : \"active\").forEach(\n      (observableQuery) => {\n        const { fetchPolicy } = observableQuery.options;\n        if (\n          (includeStandby || fetchPolicy !== \"standby\") &&\n          fetchPolicy !== \"cache-only\"\n        ) {\n          observableQueryPromises.push(observableQuery.refetch());\n        }\n      }\n    );\n\n    this.broadcastQueries();\n\n    return Promise.all(observableQueryPromises);\n  }\n\n  public startGraphQLSubscription<TData = unknown>(\n    options: ApolloClient.SubscribeOptions<TData>\n  ): SubscriptionObservable<ApolloClient.SubscribeResult<TData>> {\n    let { query, variables } = options;\n    const {\n      fetchPolicy,\n      errorPolicy = \"none\",\n      context = {},\n      extensions = {},\n    } = options;\n\n    checkDocument(query, OperationTypeNode.SUBSCRIPTION);\n\n    query = this.transform(query);\n    variables = this.getVariables(query, variables);\n\n    let restart: (() => void) | undefined;\n\n    if (__DEV__) {\n      invariant(\n        !this.getDocumentInfo(query).hasClientExports || this.localState,\n        \"Subscription '%s' contains `@client` fields with variables provided by `@export` but local state has not been configured.\",\n        getOperationName(query, \"(anonymous)\")\n      );\n    }\n\n    const observable = (\n      this.getDocumentInfo(query).hasClientExports ?\n        from(\n          this.localState!.getExportedVariables({\n            client: this.client,\n            document: query,\n            variables,\n            context,\n          })\n        )\n      : of(variables)).pipe(\n      mergeMap((variables) => {\n        const { observable, restart: res } = this.getObservableFromLink<TData>(\n          query,\n          context,\n          variables,\n          extensions\n        );\n\n        const queryInfo = new QueryInfo<TData>(this);\n\n        restart = res;\n        return (observable as Observable<FormattedExecutionResult<TData>>).pipe(\n          map((rawResult): ApolloClient.SubscribeResult<TData> => {\n            queryInfo.markSubscriptionResult(rawResult, {\n              document: query,\n              variables,\n              errorPolicy,\n              cacheWriteBehavior:\n                fetchPolicy === \"no-cache\" ?\n                  CacheWriteBehavior.FORBID\n                : CacheWriteBehavior.MERGE,\n            });\n\n            const result: ApolloClient.SubscribeResult<TData> = {\n              data: rawResult.data ?? undefined,\n            };\n\n            if (graphQLResultHasError(rawResult)) {\n              result.error = new CombinedGraphQLErrors(rawResult);\n            } else if (graphQLResultHasProtocolErrors(rawResult)) {\n              result.error = rawResult.extensions[PROTOCOL_ERRORS_SYMBOL];\n              // Don't emit protocol errors added by HttpLink\n              delete rawResult.extensions[PROTOCOL_ERRORS_SYMBOL];\n            }\n\n            if (\n              rawResult.extensions &&\n              Object.keys(rawResult.extensions).length\n            ) {\n              result.extensions = rawResult.extensions;\n            }\n\n            if (result.error && errorPolicy === \"none\") {\n              result.data = undefined;\n            }\n\n            if (errorPolicy === \"ignore\") {\n              delete result.error;\n            }\n\n            return result;\n          }),\n          catchError((error) => {\n            if (errorPolicy === \"ignore\") {\n              return of({\n                data: undefined,\n              } as ApolloClient.SubscribeResult<TData>);\n            }\n\n            return of({ data: undefined, error });\n          }),\n          filter((result) => !!(result.data || result.error))\n        );\n      })\n    );\n\n    return Object.assign(observable, { restart: () => restart?.() });\n  }\n\n  public broadcastQueries() {\n    if (this.onBroadcast) this.onBroadcast();\n    this.obsQueries.forEach((observableQuery) => observableQuery.notify());\n  }\n\n  // Use protected instead of private field so\n  // @apollo/experimental-nextjs-app-support can access type info.\n  protected inFlightLinkObservables = new Trie<{\n    observable?: Observable<ApolloLink.Result<any>>;\n    restart?: () => void;\n  }>(false);\n\n  private getObservableFromLink<TData = unknown>(\n    query: DocumentNode,\n    context: DefaultContext | undefined,\n    variables?: OperationVariables,\n    extensions?: Record<string, any>,\n    // Prefer context.queryDeduplication if specified.\n    deduplication: boolean = context?.queryDeduplication ??\n      this.queryDeduplication\n  ): {\n    restart: () => void;\n    observable: Observable<ApolloLink.Result<TData>>;\n  } {\n    let entry: {\n      observable?: Observable<ApolloLink.Result<TData>>;\n      // The restart function has to be on a mutable object that way if multiple\n      // client.subscribe() calls are made before the first one subscribes to\n      // the observable, the `restart` function can be updated for all\n      // deduplicated client.subscribe() calls.\n      restart?: () => void;\n    } = {};\n\n    const { serverQuery, clientQuery, operationType, hasIncrementalDirective } =\n      this.getDocumentInfo(query);\n\n    const operationName = getOperationName(query);\n    const executeContext: ApolloLink.ExecuteContext = {\n      client: this.client,\n    };\n\n    if (serverQuery) {\n      const { inFlightLinkObservables, link } = this;\n\n      try {\n        const operation = this.incrementalHandler.prepareRequest({\n          query: serverQuery,\n          variables,\n          context: {\n            ...this.defaultContext,\n            ...context,\n            queryDeduplication: deduplication,\n          },\n          extensions,\n        });\n\n        context = operation.context;\n\n        function withRestart(source: Observable<ApolloLink.Result>) {\n          return new Observable<ApolloLink.Result>((observer) => {\n            function subscribe() {\n              return source.subscribe({\n                next: observer.next.bind(observer),\n                complete: observer.complete.bind(observer),\n                error: observer.error.bind(observer),\n              });\n            }\n            let subscription = subscribe();\n\n            entry.restart ||= () => {\n              subscription.unsubscribe();\n              subscription = subscribe();\n            };\n\n            return () => {\n              subscription.unsubscribe();\n              entry.restart = undefined;\n            };\n          });\n        }\n\n        if (deduplication) {\n          const printedServerQuery = print(serverQuery);\n          const varJson = canonicalStringify(variables);\n\n          entry = inFlightLinkObservables.lookup(printedServerQuery, varJson);\n\n          if (!entry.observable) {\n            entry.observable = execute(link, operation, executeContext).pipe(\n              withRestart,\n              finalize(() => {\n                if (\n                  inFlightLinkObservables.peek(printedServerQuery, varJson) ===\n                  entry\n                ) {\n                  inFlightLinkObservables.remove(printedServerQuery, varJson);\n                }\n              }),\n              // We don't want to replay the last emitted value for\n              // subscriptions and instead opt to wait to receive updates until\n              // the subscription emits new values.\n              operationType === OperationTypeNode.SUBSCRIPTION ?\n                share()\n              : shareReplay({ refCount: true })\n            ) as Observable<ApolloLink.Result<TData>>;\n          }\n        } else {\n          entry.observable = execute(link, operation, executeContext).pipe(\n            withRestart\n          ) as Observable<ApolloLink.Result<TData>>;\n        }\n      } catch (error) {\n        entry.observable = throwError(() => error);\n      }\n    } else {\n      entry.observable = of({ data: {} } as ApolloLink.Result<TData>);\n    }\n\n    if (clientQuery) {\n      const { operation } = getOperationDefinition(query)!;\n      if (__DEV__) {\n        invariant(\n          this.localState,\n          \"%s '%s' contains `@client` fields but local state has not been configured.\",\n          operation[0].toUpperCase() + operation.slice(1),\n          operationName ?? \"(anonymous)\"\n        );\n      }\n\n      invariant(\n        !hasIncrementalDirective,\n        \"%s '%s' contains `@client` and `@defer` directives. These cannot be used together.\",\n        operation[0].toUpperCase() + operation.slice(1),\n        operationName ?? \"(anonymous)\"\n      );\n\n      entry.observable = entry.observable.pipe(\n        mergeMap((result) => {\n          return from(\n            this.localState!.execute<TData>({\n              client: this.client,\n              document: clientQuery,\n              remoteResult: result as FormattedExecutionResult<TData>,\n              context,\n              variables,\n            })\n          );\n        })\n      );\n    }\n\n    return {\n      restart: () => entry.restart?.(),\n      observable: entry.observable.pipe(\n        catchError((error) => {\n          error = toErrorLike(error);\n          registerLinkError(error);\n          throw error;\n        })\n      ),\n    };\n  }\n\n  private getResultsFromLink<TData, TVariables extends OperationVariables>(\n    options: {\n      query: DocumentNode;\n      variables: TVariables;\n      context: DefaultContext | undefined;\n      fetchPolicy: WatchQueryFetchPolicy;\n      errorPolicy: ErrorPolicy;\n    },\n    {\n      queryInfo,\n      cacheWriteBehavior,\n      observableQuery,\n    }: {\n      queryInfo: QueryInfo<TData, TVariables>;\n      cacheWriteBehavior: CacheWriteBehavior;\n      observableQuery: ObservableQuery<TData, TVariables> | undefined;\n    }\n  ): Observable<ObservableQuery.Result<TData>> {\n    const requestId = (queryInfo.lastRequestId = this.generateRequestId());\n    const { errorPolicy } = options;\n\n    // Performing transformForLink here gives this.cache a chance to fill in\n    // missing fragment definitions (for example) before sending this document\n    // through the link chain.\n    const linkDocument = this.cache.transformForLink(options.query);\n\n    return this.getObservableFromLink<TData>(\n      linkDocument,\n      options.context,\n      options.variables\n    ).observable.pipe(\n      map((incoming) => {\n        // Use linkDocument rather than queryInfo.document so the\n        // operation/fragments used to write the result are the same as the\n        // ones used to obtain it from the link.\n        const result = queryInfo.markQueryResult(incoming, {\n          ...options,\n          document: linkDocument,\n          cacheWriteBehavior,\n        });\n        const hasErrors = graphQLResultHasError(result);\n\n        if (hasErrors && errorPolicy === \"none\") {\n          queryInfo.resetLastWrite();\n          observableQuery?.[\"resetNotifications\"]();\n          throw new CombinedGraphQLErrors(result);\n        }\n\n        const aqr = {\n          data: result.data as TData,\n          ...(queryInfo.hasNext ?\n            {\n              loading: true,\n              networkStatus: NetworkStatus.streaming,\n              dataState: \"streaming\",\n              partial: true,\n            }\n          : {\n              dataState: result.data ? \"complete\" : \"empty\",\n              loading: false,\n              networkStatus: NetworkStatus.ready,\n              partial: !result.data,\n            }),\n        } as ObservableQuery.Result<TData>;\n\n        // In the case we start multiple network requests simulatenously, we\n        // want to ensure we properly set `data` if we're reporting on an old\n        // result which will not be caught by the conditional above that ends up\n        // throwing the markError result.\n        if (hasErrors) {\n          if (errorPolicy === \"none\") {\n            aqr.data = void 0 as TData;\n            aqr.dataState = \"empty\";\n          }\n          if (errorPolicy !== \"ignore\") {\n            aqr.error = new CombinedGraphQLErrors(result);\n            if (aqr.dataState !== \"streaming\") {\n              aqr.networkStatus = NetworkStatus.error;\n            }\n          }\n        }\n\n        return aqr;\n      }),\n      catchError((error) => {\n        // Avoid storing errors from older interrupted queries.\n        if (requestId >= queryInfo.lastRequestId && errorPolicy === \"none\") {\n          queryInfo.resetLastWrite();\n          observableQuery?.[\"resetNotifications\"]();\n          throw error;\n        }\n\n        const aqr: ObservableQuery.Result<TData> = {\n          data: undefined,\n          dataState: \"empty\",\n          loading: false,\n          networkStatus: NetworkStatus.ready,\n          partial: true,\n        };\n\n        if (errorPolicy !== \"ignore\") {\n          aqr.error = error;\n          aqr.networkStatus = NetworkStatus.error;\n        }\n\n        return of(aqr);\n      })\n    );\n  }\n\n  public fetchObservableWithInfo<TData, TVariables extends OperationVariables>(\n    options: ApolloClient.WatchQueryOptions<TData, TVariables>,\n    {\n      // The initial networkStatus for this fetch, most often\n      // NetworkStatus.loading, but also possibly fetchMore, poll, refetch,\n      // or setVariables.\n      networkStatus = NetworkStatus.loading,\n      query = options.query,\n      fetchQueryOperator = (x) => x,\n      onCacheHit = () => {},\n      observableQuery,\n    }: {\n      networkStatus?: NetworkStatus;\n      query?: DocumentNode;\n      fetchQueryOperator?: <T>(source: Observable<T>) => Observable<T>;\n      onCacheHit?: () => void;\n      observableQuery?: ObservableQuery<TData, TVariables> | undefined;\n    }\n  ): ObservableAndInfo<TData> {\n    const variables = this.getVariables(query, options.variables) as TVariables;\n\n    const defaults = this.defaultOptions.watchQuery;\n    let {\n      fetchPolicy = (defaults && defaults.fetchPolicy) || \"cache-first\",\n      errorPolicy = (defaults && defaults.errorPolicy) || \"none\",\n      returnPartialData = false,\n      notifyOnNetworkStatusChange = true,\n      context = {},\n    } = options;\n\n    if (\n      this.prioritizeCacheValues &&\n      (fetchPolicy === \"network-only\" || fetchPolicy === \"cache-and-network\")\n    ) {\n      fetchPolicy = \"cache-first\";\n    }\n\n    const normalized = Object.assign({}, options, {\n      query,\n      variables,\n      fetchPolicy,\n      errorPolicy,\n      returnPartialData,\n      notifyOnNetworkStatusChange,\n      context,\n    });\n\n    const queryInfo = new QueryInfo<TData, TVariables>(this, observableQuery);\n\n    const fromVariables = (variables: TVariables) => {\n      // Since normalized is always a fresh copy of options, it's safe to\n      // modify its properties here, rather than creating yet another new\n      // WatchQueryOptions object.\n      normalized.variables = variables;\n\n      const cacheWriteBehavior =\n        fetchPolicy === \"no-cache\" ? CacheWriteBehavior.FORBID\n          // Watched queries must opt into overwriting existing data on refetch,\n          // by passing refetchWritePolicy: \"overwrite\" in their WatchQueryOptions.\n        : (\n          networkStatus === NetworkStatus.refetch &&\n          normalized.refetchWritePolicy !== \"merge\"\n        ) ?\n          CacheWriteBehavior.OVERWRITE\n        : CacheWriteBehavior.MERGE;\n      const observableWithInfo = this.fetchQueryByPolicy<TData, TVariables>(\n        normalized,\n        { queryInfo, cacheWriteBehavior, onCacheHit, observableQuery }\n      );\n      observableWithInfo.observable =\n        observableWithInfo.observable.pipe(fetchQueryOperator);\n\n      if (\n        // If we're in standby, postpone advancing options.fetchPolicy using\n        // applyNextFetchPolicy.\n        normalized.fetchPolicy !== \"standby\"\n      ) {\n        observableQuery?.[\"applyNextFetchPolicy\"](\n          \"after-fetch\",\n          options as any\n        );\n      }\n\n      return observableWithInfo;\n    };\n\n    // This cancel function needs to be set before the concast is created,\n    // in case concast creation synchronously cancels the request.\n    const cleanupCancelFn = () => {\n      this.fetchCancelFns.delete(queryInfo.id);\n    };\n    this.fetchCancelFns.set(queryInfo.id, (error) => {\n      fetchCancelSubject.next({\n        kind: \"E\",\n        error,\n        source: \"network\",\n      });\n    });\n\n    const fetchCancelSubject = new Subject<QueryNotification.Value<TData>>();\n    let observable: Observable<QueryNotification.Value<TData>>,\n      containsDataFromLink: boolean;\n\n    // If the query has @export(as: ...) directives, then we need to\n    // process those directives asynchronously. When there are no\n    // @export directives (the common case), we deliberately avoid\n    // wrapping the result of this.fetchQueryByPolicy in a Promise,\n    // since the timing of result delivery is (unfortunately) important\n    // for backwards compatibility. TODO This code could be simpler if\n    // we deprecated and removed LocalState.\n    if (this.getDocumentInfo(normalized.query).hasClientExports) {\n      if (__DEV__) {\n        invariant(\n          this.localState,\n          \"Query '%s' contains `@client` fields with variables provided by `@export` but local state has not been configured.\",\n          getOperationName(normalized.query, \"(anonymous)\")\n        );\n      }\n\n      observable = from(\n        this.localState!.getExportedVariables({\n          client: this.client,\n          document: normalized.query,\n          variables: normalized.variables,\n          context: normalized.context,\n        })\n      ).pipe(mergeMap((variables) => fromVariables(variables).observable));\n\n      // there is just no way we can synchronously get the *right* value here,\n      // so we will assume `true`, which is the behaviour before the bug fix in\n      // #10597. This means that bug is not fixed in that case, and is probably\n      // un-fixable with reasonable effort for the edge case of @export as\n      // directives.\n      containsDataFromLink = true;\n    } else {\n      const sourcesWithInfo = fromVariables(normalized.variables);\n      containsDataFromLink = sourcesWithInfo.fromLink;\n      observable = sourcesWithInfo.observable;\n    }\n\n    return {\n      // Merge `observable` with `fetchCancelSubject`, in a way that completing or\n      // erroring either of them will complete the merged obserable.\n      observable: new Observable<QueryNotification.Value<TData>>((observer) => {\n        observer.add(cleanupCancelFn);\n        observable.subscribe(observer);\n        fetchCancelSubject.subscribe(observer);\n      }).pipe(share()),\n      fromLink: containsDataFromLink,\n    };\n  }\n\n  public refetchQueries<TResult>({\n    updateCache,\n    include,\n    optimistic = false,\n    removeOptimistic = optimistic ? makeUniqueId(\"refetchQueries\") : void 0,\n    onQueryUpdated,\n  }: InternalRefetchQueriesOptions<\n    ApolloCache,\n    TResult\n  >): InternalRefetchQueriesMap<TResult> {\n    const includedQueriesByOq = new Map<\n      ObservableQuery<any>,\n      {\n        oq: ObservableQuery<any>;\n        lastDiff?: Cache.DiffResult<any>;\n        diff?: Cache.DiffResult<any>;\n      }\n    >();\n\n    if (include) {\n      this.getObservableQueries(include).forEach((oq) => {\n        if (oq.options.fetchPolicy === \"cache-only\") {\n          return;\n        }\n\n        const current = oq.getCurrentResult();\n        includedQueriesByOq.set(oq, {\n          oq,\n          lastDiff: {\n            result: current?.data,\n            complete: !current?.partial,\n          },\n        });\n      });\n    }\n\n    const results: InternalRefetchQueriesMap<TResult> = new Map();\n\n    if (updateCache) {\n      const handled = new Set<ObservableQuery<any>>();\n      this.cache.batch({\n        update: updateCache,\n\n        // Since you can perform any combination of cache reads and/or writes in\n        // the cache.batch update function, its optimistic option can be either\n        // a boolean or a string, representing three distinct modes of\n        // operation:\n        //\n        // * false: read/write only the root layer\n        // * true: read/write the topmost layer\n        // * string: read/write a fresh optimistic layer with that ID string\n        //\n        // When typeof optimistic === \"string\", a new optimistic layer will be\n        // temporarily created within cache.batch with that string as its ID. If\n        // we then pass that same string as the removeOptimistic option, we can\n        // make cache.batch immediately remove the optimistic layer after\n        // running the updateCache function, triggering only one broadcast.\n        //\n        // However, the refetchQueries method accepts only true or false for its\n        // optimistic option (not string). We interpret true to mean a temporary\n        // optimistic layer should be created, to allow efficiently rolling back\n        // the effect of the updateCache function, which involves passing a\n        // string instead of true as the optimistic option to cache.batch, when\n        // refetchQueries receives optimistic: true.\n        //\n        // In other words, we are deliberately not supporting the use case of\n        // writing to an *existing* optimistic layer (using the refetchQueries\n        // updateCache function), since that would potentially interfere with\n        // other optimistic updates in progress. Instead, you can read/write\n        // only the root layer by passing optimistic: false to refetchQueries,\n        // or you can read/write a brand new optimistic layer that will be\n        // automatically removed by passing optimistic: true.\n        optimistic: (optimistic && removeOptimistic) || false,\n\n        // The removeOptimistic option can also be provided by itself, even if\n        // optimistic === false, to remove some previously-added optimistic\n        // layer safely and efficiently, like we do in markMutationResult.\n        //\n        // If an explicit removeOptimistic string is provided with optimistic:\n        // true, the removeOptimistic string will determine the ID of the\n        // temporary optimistic layer, in case that ever matters.\n        removeOptimistic,\n\n        onWatchUpdated(watch, diff, lastDiff) {\n          const oq = watch.watcher;\n\n          if (oq instanceof ObservableQuery && !handled.has(oq)) {\n            handled.add(oq);\n            if (onQueryUpdated) {\n              // Since we're about to handle this query now, remove it from\n              // includedQueriesById, in case it was added earlier because of\n              // options.include.\n              includedQueriesByOq.delete(oq);\n\n              let result:\n                | TResult\n                | boolean\n                | Promise<ApolloClient.QueryResult<any>> = onQueryUpdated(\n                oq,\n                diff,\n                lastDiff\n              );\n\n              if (result === true) {\n                // The onQueryUpdated function requested the default refetching\n                // behavior by returning true.\n                result = oq\n                  .refetch()\n                  .retain(/* create a persistent subscription on the query */);\n              }\n\n              // Record the result in the results Map, as long as onQueryUpdated\n              // did not return false to skip/ignore this result.\n              if (result !== false) {\n                results.set(\n                  oq,\n                  result as InternalRefetchQueriesResult<TResult>\n                );\n              }\n\n              // Allow the default cache broadcast to happen, except when\n              // onQueryUpdated returns false.\n              return result;\n            }\n\n            if (\n              onQueryUpdated !== null &&\n              oq.options.fetchPolicy !== \"cache-only\"\n            ) {\n              // If we don't have an onQueryUpdated function, and onQueryUpdated\n              // was not disabled by passing null, make sure this query is\n              // \"included\" like any other options.include-specified query.\n              includedQueriesByOq.set(oq, { oq, lastDiff, diff });\n            }\n          }\n        },\n      });\n    }\n\n    if (includedQueriesByOq.size) {\n      includedQueriesByOq.forEach(({ oq, lastDiff, diff }) => {\n        let result:\n          | TResult\n          | boolean\n          | Promise<ApolloClient.QueryResult<any>>\n          | undefined;\n\n        // If onQueryUpdated is provided, we want to use it for all included\n        // queries, even the QueryOptions ones.\n        if (onQueryUpdated) {\n          if (!diff) {\n            diff = oq.getCacheDiff();\n          }\n          result = onQueryUpdated(oq, diff, lastDiff);\n        }\n\n        // Otherwise, we fall back to refetching.\n        if (!onQueryUpdated || result === true) {\n          result = oq\n            .refetch()\n            .retain(/* create a persistent subscription on the query */);\n        }\n\n        if (result !== false) {\n          results.set(oq, result as InternalRefetchQueriesResult<TResult>);\n        }\n      });\n    }\n\n    if (removeOptimistic) {\n      // In case no updateCache callback was provided (so cache.batch was not\n      // called above, and thus did not already remove the optimistic layer),\n      // remove it here. Since this is a no-op when the layer has already been\n      // removed, we do it even if we called cache.batch above, since it's\n      // possible this.cache is an instance of some ApolloCache subclass other\n      // than InMemoryCache, and does not fully support the removeOptimistic\n      // option for cache.batch.\n      this.cache.removeOptimistic(removeOptimistic);\n    }\n\n    return results;\n  }\n\n  private noCacheWarningsByCause = new WeakSet<object>();\n\n  public maskOperation<TData = unknown>(\n    options: MaskOperationOptions<TData>\n  ): MaybeMasked<TData> {\n    const { document, data } = options;\n\n    if (__DEV__) {\n      const { fetchPolicy, cause = {} } = options;\n      const operationType = getOperationDefinition(document)?.operation;\n\n      if (\n        this.dataMasking &&\n        fetchPolicy === \"no-cache\" &&\n        !isFullyUnmaskedOperation(document) &&\n        !this.noCacheWarningsByCause.has(cause)\n      ) {\n        this.noCacheWarningsByCause.add(cause);\n\n        invariant.warn(\n          '[%s]: Fragments masked by data masking are inaccessible when using fetch policy \"no-cache\". Please add `@unmask` to each fragment spread to access the data.',\n          getOperationName(document, `Unnamed ${operationType ?? \"operation\"}`)\n        );\n      }\n    }\n\n    return (\n      this.dataMasking ?\n        maskOperation(data, document, this.cache)\n      : data) as MaybeMasked<TData>;\n  }\n\n  public maskFragment<TData = unknown>(options: MaskFragmentOptions<TData>) {\n    const { data, fragment, fragmentName } = options;\n\n    return this.dataMasking ?\n        maskFragment(data, fragment, this.cache, fragmentName)\n      : data;\n  }\n\n  private fetchQueryByPolicy<TData, TVariables extends OperationVariables>(\n    {\n      query,\n      variables,\n      fetchPolicy,\n      errorPolicy,\n      returnPartialData,\n      context,\n    }: {\n      query: DocumentNode | TypedDocumentNode<TData, TVariables>;\n      variables: TVariables;\n      fetchPolicy: WatchQueryFetchPolicy;\n      errorPolicy: ErrorPolicy;\n      returnPartialData?: boolean;\n      context?: DefaultContext;\n    },\n    {\n      cacheWriteBehavior,\n      onCacheHit,\n      queryInfo,\n      observableQuery,\n    }: {\n      cacheWriteBehavior: CacheWriteBehavior;\n      onCacheHit: () => void;\n      queryInfo: QueryInfo<TData, TVariables>;\n      observableQuery: ObservableQuery<TData, TVariables> | undefined;\n    }\n  ): ObservableAndInfo<TData> {\n    const readCache = () =>\n      this.cache.diff<any>({\n        query,\n        variables,\n        returnPartialData: true,\n        optimistic: true,\n      });\n\n    const resultsFromCache = (\n      diff: Cache.DiffResult<TData>,\n      networkStatus: NetworkStatus\n    ): Observable<QueryNotification.FromCache<TData>> => {\n      const data = diff.result;\n\n      if (__DEV__ && !returnPartialData && data !== null) {\n        logMissingFieldErrors(diff.missing);\n      }\n\n      const toResult = (\n        data: TData | DeepPartial<TData> | undefined\n      ): ObservableQuery.Result<TData> => {\n        // TODO: Eventually we should move this handling into\n        // queryInfo.getDiff() directly. Since getDiff is updated to return null\n        // on returnPartialData: false, we should take advantage of that instead\n        // of having to patch it elsewhere.\n        if (!diff.complete && !returnPartialData) {\n          data = undefined;\n        }\n\n        return {\n          // TODO: Handle partial data\n          data: data as TData | undefined,\n          dataState:\n            diff.complete ? \"complete\"\n            : data ? \"partial\"\n            : \"empty\",\n          loading: isNetworkRequestInFlight(networkStatus),\n          networkStatus,\n          partial: !diff.complete,\n        } as ObservableQuery.Result<TData>;\n      };\n\n      const fromData = (\n        data: TData | DeepPartial<TData> | undefined\n      ): Observable<QueryNotification.FromCache<TData>> => {\n        return of({\n          kind: \"N\",\n          value: toResult(data),\n          source: \"cache\",\n        });\n      };\n\n      if (\n        // Don't attempt to run forced resolvers if we have incomplete cache\n        // data and partial isn't allowed since this result would get set to\n        // `undefined` anyways in `toResult`.\n        (diff.complete || returnPartialData) &&\n        this.getDocumentInfo(query).hasForcedResolvers\n      ) {\n        if (__DEV__) {\n          invariant(\n            this.localState,\n            \"Query '%s' contains `@client` fields but local state has not been configured.\",\n            getOperationName(query, \"(anonymous)\")\n          );\n        }\n        onCacheHit();\n\n        return from(\n          this.localState!.execute<TData>({\n            client: this.client,\n            document: query,\n            remoteResult: data ? { data } : undefined,\n            context,\n            variables,\n            onlyRunForcedResolvers: true,\n            returnPartialData: true,\n          }).then(\n            (resolved): QueryNotification.FromCache<TData> => ({\n              kind: \"N\",\n              value: toResult(resolved.data || void 0),\n              source: \"cache\",\n            })\n          )\n        );\n      }\n\n      // Resolves https://github.com/apollographql/apollo-client/issues/10317.\n      // If errorPolicy is 'none' and notifyOnNetworkStatusChange is true,\n      // data was incorrectly returned from the cache on refetch:\n      // if diff.missing exists, we should not return cache data.\n      if (\n        errorPolicy === \"none\" &&\n        networkStatus === NetworkStatus.refetch &&\n        diff.missing\n      ) {\n        return fromData(void 0);\n      }\n\n      return fromData(data || undefined);\n    };\n\n    const resultsFromLink = () =>\n      this.getResultsFromLink<TData, TVariables>(\n        {\n          query,\n          variables,\n          context,\n          fetchPolicy,\n          errorPolicy,\n        },\n        {\n          cacheWriteBehavior,\n          queryInfo,\n          observableQuery,\n        }\n      ).pipe(\n        validateDidEmitValue(),\n        materialize(),\n        map(\n          (result): QueryNotification.FromNetwork<TData> => ({\n            ...result,\n            source: \"network\",\n          })\n        )\n      );\n\n    switch (fetchPolicy) {\n      default:\n      case \"cache-first\": {\n        const diff = readCache();\n\n        if (diff.complete) {\n          return {\n            fromLink: false,\n            observable: resultsFromCache(diff, NetworkStatus.ready),\n          };\n        }\n\n        if (returnPartialData) {\n          return {\n            fromLink: true,\n            observable: concat(\n              resultsFromCache(diff, NetworkStatus.loading),\n              resultsFromLink()\n            ),\n          };\n        }\n\n        return { fromLink: true, observable: resultsFromLink() };\n      }\n\n      case \"cache-and-network\": {\n        const diff = readCache();\n\n        if (diff.complete || returnPartialData) {\n          return {\n            fromLink: true,\n            observable: concat(\n              resultsFromCache(diff, NetworkStatus.loading),\n              resultsFromLink()\n            ),\n          };\n        }\n\n        return { fromLink: true, observable: resultsFromLink() };\n      }\n\n      case \"cache-only\":\n        return {\n          fromLink: false,\n          observable: concat(\n            resultsFromCache(readCache(), NetworkStatus.ready)\n          ),\n        };\n\n      case \"network-only\":\n        return { fromLink: true, observable: resultsFromLink() };\n\n      case \"no-cache\":\n        return { fromLink: true, observable: resultsFromLink() };\n\n      case \"standby\":\n        return { fromLink: false, observable: EMPTY };\n    }\n  }\n}\n\nfunction validateDidEmitValue<T>() {\n  let didEmitValue = false;\n\n  return tap<T>({\n    next() {\n      didEmitValue = true;\n    },\n    complete() {\n      invariant(\n        didEmitValue,\n        \"The link chain completed without emitting a value. This is likely unintentional and should be updated to emit a value before completing.\"\n      );\n    },\n  });\n}\n\n// Return types used by fetchQueryByPolicy and other private methods above.\ninterface ObservableAndInfo<TData> {\n  // Metadata properties that can be returned in addition to the Observable.\n  fromLink: boolean;\n  observable: Observable<QueryNotification.Value<TData>>;\n}\n\nfunction isFullyUnmaskedOperation(document: DocumentNode) {\n  let isUnmasked = true;\n\n  visit(document, {\n    FragmentSpread: (node) => {\n      isUnmasked =\n        !!node.directives &&\n        node.directives.some((directive) => directive.name.value === \"unmask\");\n\n      if (!isUnmasked) {\n        return BREAK;\n      }\n    },\n  });\n\n  return isUnmasked;\n}\n\nfunction addNonReactiveToNamedFragments(document: DocumentNode) {\n  return visit(document, {\n    FragmentSpread: (node) => {\n      // Do not add `@nonreactive` if the fragment is marked with `@unmask`\n      // since we want to react to changes in this fragment.\n      if (\n        node.directives?.some((directive) => directive.name.value === \"unmask\")\n      ) {\n        return;\n      }\n\n      return {\n        ...node,\n        directives: [\n          ...(node.directives || []),\n          {\n            kind: Kind.DIRECTIVE,\n            name: { kind: Kind.NAME, value: \"nonreactive\" },\n          } satisfies DirectiveNode,\n        ],\n      };\n    },\n  });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}