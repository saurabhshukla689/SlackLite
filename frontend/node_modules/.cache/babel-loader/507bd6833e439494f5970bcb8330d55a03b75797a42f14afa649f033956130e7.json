{"ast":null,"code":"import { equal } from \"@wry/equality\";\nimport * as React from \"react\";\nimport { invariant } from \"@apollo/client/utilities/invariant\";\nimport { useDeepMemo } from \"./internal/useDeepMemo.js\";\nimport { useIsomorphicLayoutEffect } from \"./internal/useIsomorphicLayoutEffect.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\nimport { useSyncExternalStore } from \"./useSyncExternalStore.js\";\n/**\n * > Refer to the [Subscriptions](https://www.apollographql.com/docs/react/data/subscriptions/) section for a more in-depth overview of `useSubscription`.\n *\n * @example\n *\n * ```jsx\n * const COMMENTS_SUBSCRIPTION = gql`\n *   subscription OnCommentAdded($repoFullName: String!) {\n *     commentAdded(repoFullName: $repoFullName) {\n *       id\n *       content\n *     }\n *   }\n * `;\n *\n * function DontReadTheComments({ repoFullName }) {\n *   const {\n *     data: { commentAdded },\n *     loading,\n *   } = useSubscription(COMMENTS_SUBSCRIPTION, { variables: { repoFullName } });\n *   return <h4>New comment: {!loading && commentAdded.content}</h4>;\n * }\n * ```\n *\n * @remarks\n *\n * #### Consider using `onData` instead of `useEffect`\n *\n * If you want to react to incoming data, please use the `onData` option instead of `useEffect`.\n * State updates you make inside a `useEffect` hook might cause additional rerenders, and `useEffect` is mostly meant for side effects of rendering, not as an event handler.\n * State updates made in an event handler like `onData` might - depending on the React version - be batched and cause only a single rerender.\n *\n * Consider the following component:\n *\n * ```jsx\n * export function Subscriptions() {\n *   const { data, error, loading } = useSubscription(query);\n *   const [accumulatedData, setAccumulatedData] = useState([]);\n *\n *   useEffect(() => {\n *     setAccumulatedData((prev) => [...prev, data]);\n *   }, [data]);\n *\n *   return (\n *     <>\n *       {loading && <p>Loading...</p>}\n *       {JSON.stringify(accumulatedData, undefined, 2)}\n *     </>\n *   );\n * }\n * ```\n *\n * Instead of using `useEffect` here, we can re-write this component to use the `onData` callback function accepted in `useSubscription`'s `options` object:\n *\n * ```jsx\n * export function Subscriptions() {\n *   const [accumulatedData, setAccumulatedData] = useState([]);\n *   const { data, error, loading } = useSubscription(query, {\n *     onData({ data }) {\n *       setAccumulatedData((prev) => [...prev, data]);\n *     },\n *   });\n *\n *   return (\n *     <>\n *       {loading && <p>Loading...</p>}\n *       {JSON.stringify(accumulatedData, undefined, 2)}\n *     </>\n *   );\n * }\n * ```\n *\n * > ⚠️ **Note:** The `useSubscription` option `onData` is available in Apollo Client >= 3.7. In previous versions, the equivalent option is named `onSubscriptionData`.\n *\n * Now, the first message will be added to the `accumulatedData` array since `onData` is called _before_ the component re-renders. React 18 automatic batching is still in effect and results in a single re-render, but with `onData` we can guarantee each message received after the component mounts is added to `accumulatedData`.\n *\n * @param subscription - A GraphQL subscription document parsed into an AST by `gql`.\n * @param options - Options to control how the subscription is executed.\n * @returns Query result object\n */\nexport function useSubscription(subscription, ...[options = {}]) {\n  const client = useApolloClient(options.client);\n  const {\n    skip,\n    fetchPolicy,\n    errorPolicy,\n    shouldResubscribe,\n    context,\n    extensions,\n    ignoreResults\n  } = options;\n  const variables = useDeepMemo(() => options.variables, [options.variables]);\n  const recreate = () => createSubscription(client, subscription, variables, fetchPolicy, errorPolicy, context, extensions);\n  let [observable, setObservable] = React.useState(options.skip ? null : recreate);\n  const recreateRef = React.useRef(recreate);\n  useIsomorphicLayoutEffect(() => {\n    recreateRef.current = recreate;\n  });\n  if (skip) {\n    if (observable) {\n      setObservable(observable = null);\n    }\n  } else if (!observable || (client !== observable.__.client || subscription !== observable.__.query || fetchPolicy !== observable.__.fetchPolicy || errorPolicy !== observable.__.errorPolicy || !equal(variables, observable.__.variables)) && (typeof shouldResubscribe === \"function\" ? !!shouldResubscribe(options) : shouldResubscribe) !== false) {\n    setObservable(observable = recreate());\n  }\n  const optionsRef = React.useRef(options);\n  React.useEffect(() => {\n    optionsRef.current = options;\n  });\n  const fallbackLoading = !skip && !ignoreResults;\n  const fallbackResult = React.useMemo(() => ({\n    loading: fallbackLoading,\n    error: void 0,\n    data: void 0\n  }), [fallbackLoading]);\n  const ignoreResultsRef = React.useRef(ignoreResults);\n  useIsomorphicLayoutEffect(() => {\n    // We cannot reference `ignoreResults` directly in the effect below\n    // it would add a dependency to the `useEffect` deps array, which means the\n    // subscription would be recreated if `ignoreResults` changes\n    // As a result, on resubscription, the last result would be re-delivered,\n    // rendering the component one additional time, and re-triggering `onData`.\n    // The same applies to `fetchPolicy`, which results in a new `observable`\n    // being created. We cannot really avoid it in that case, but we can at least\n    // avoid it for `ignoreResults`.\n    ignoreResultsRef.current = ignoreResults;\n  });\n  const ret = useSyncExternalStore(React.useCallback(update => {\n    if (!observable) {\n      return () => {};\n    }\n    let subscriptionStopped = false;\n    const client = observable.__.client;\n    const subscription = observable.subscribe({\n      next(value) {\n        if (subscriptionStopped) {\n          return;\n        }\n        const result = {\n          loading: false,\n          data: value.data,\n          error: value.error\n        };\n        observable.__.setResult(result);\n        if (!ignoreResultsRef.current) update();\n        if (result.error) {\n          optionsRef.current.onError?.(result.error);\n        } else if (optionsRef.current.onData) {\n          optionsRef.current.onData({\n            client,\n            data: result\n          });\n        }\n      },\n      complete() {\n        observable.__.completed = true;\n        if (!subscriptionStopped && optionsRef.current.onComplete) {\n          optionsRef.current.onComplete();\n        }\n      }\n    });\n    return () => {\n      // immediately stop receiving subscription values, but do not unsubscribe\n      // until after a short delay in case another useSubscription hook is\n      // reusing the same underlying observable and is about to subscribe\n      subscriptionStopped = true;\n      setTimeout(() => subscription.unsubscribe());\n    };\n  }, [observable]), () => observable && !skip && !ignoreResults ? observable.__.result : fallbackResult, () => fallbackResult);\n  const restart = React.useCallback(() => {\n    invariant(!optionsRef.current.skip, 33);\n    if (observable?.__.completed) {\n      setObservable(recreateRef.current());\n    } else {\n      observable?.restart();\n    }\n  }, [optionsRef, recreateRef, observable]);\n  return React.useMemo(() => ({\n    ...ret,\n    restart\n  }), [ret, restart]);\n}\nfunction createSubscription(client, query, variables, fetchPolicy, errorPolicy, context, extensions) {\n  const options = {\n    query,\n    variables,\n    fetchPolicy,\n    errorPolicy,\n    context,\n    extensions\n  };\n  const __ = {\n    ...options,\n    client,\n    completed: false,\n    result: {\n      loading: true,\n      data: void 0,\n      error: void 0\n    },\n    setResult(result) {\n      __.result = result;\n    }\n  };\n  return Object.assign(client.subscribe(options), {\n    /**\n     * A tracking object to store details about the observable and the latest result of the subscription.\n     */\n    __\n  });\n}","map":{"version":3,"names":["equal","React","invariant","useDeepMemo","useIsomorphicLayoutEffect","useApolloClient","useSyncExternalStore","useSubscription","subscription","options","client","skip","fetchPolicy","errorPolicy","shouldResubscribe","context","extensions","ignoreResults","variables","recreate","createSubscription","observable","setObservable","useState","recreateRef","useRef","current","__","query","optionsRef","useEffect","fallbackLoading","fallbackResult","useMemo","loading","error","data","ignoreResultsRef","ret","useCallback","update","subscriptionStopped","subscribe","next","value","result","setResult","onError","onData","complete","completed","onComplete","setTimeout","unsubscribe","restart","Object","assign"],"sources":["/home/saurabh-shukla/Desktop/Slack Lite/frontend/node_modules/@apollo/src/react/hooks/useSubscription.ts"],"sourcesContent":["import type { TypedDocumentNode } from \"@graphql-typed-document-node/core\";\nimport { equal } from \"@wry/equality\";\nimport type { DocumentNode } from \"graphql\";\nimport * as React from \"react\";\n\nimport type {\n  ApolloClient,\n  DefaultContext,\n  ErrorLike,\n  ErrorPolicy,\n  FetchPolicy,\n  OperationVariables,\n} from \"@apollo/client\";\nimport type { MaybeMasked } from \"@apollo/client/masking\";\nimport type { DocumentationTypes as UtilityDocumentationTypes } from \"@apollo/client/utilities/internal\";\nimport type {\n  NoInfer,\n  VariablesOption,\n} from \"@apollo/client/utilities/internal\";\nimport { invariant } from \"@apollo/client/utilities/invariant\";\n\nimport { useDeepMemo } from \"./internal/useDeepMemo.js\";\nimport { useIsomorphicLayoutEffect } from \"./internal/useIsomorphicLayoutEffect.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\nimport { useSyncExternalStore } from \"./useSyncExternalStore.js\";\n\nexport declare namespace useSubscription {\n  import _self = useSubscription;\n  export namespace Base {\n    export interface Options<\n      TData = unknown,\n      TVariables extends OperationVariables = OperationVariables,\n    > {\n      /** {@inheritDoc @apollo/client!SubscriptionOptionsDocumentation#fetchPolicy:member} */\n      fetchPolicy?: FetchPolicy;\n\n      /** {@inheritDoc @apollo/client!SubscriptionOptionsDocumentation#errorPolicy:member} */\n      errorPolicy?: ErrorPolicy;\n\n      /** {@inheritDoc @apollo/client!SubscriptionOptionsDocumentation#shouldResubscribe:member} */\n      shouldResubscribe?:\n        | boolean\n        | ((options: Options<TData, TVariables>) => boolean);\n\n      /** {@inheritDoc @apollo/client!SubscriptionOptionsDocumentation#client:member} */\n      client?: ApolloClient;\n\n      /** {@inheritDoc @apollo/client!SubscriptionOptionsDocumentation#skip:member} */\n      skip?: boolean;\n\n      /** {@inheritDoc @apollo/client!SubscriptionOptionsDocumentation#context:member} */\n      context?: DefaultContext;\n\n      /** {@inheritDoc @apollo/client!SubscriptionOptionsDocumentation#extensions:member} */\n      extensions?: Record<string, any>;\n\n      /** {@inheritDoc @apollo/client!SubscriptionOptionsDocumentation#onComplete:member} */\n      onComplete?: () => void;\n\n      /** {@inheritDoc @apollo/client!SubscriptionOptionsDocumentation#onData:member} */\n      onData?: (options: OnDataOptions<TData>) => any;\n\n      /** {@inheritDoc @apollo/client!SubscriptionOptionsDocumentation#onError:member} */\n      onError?: (error: ErrorLike) => void;\n\n      /**\n       * {@inheritDoc @apollo/client!SubscriptionOptionsDocumentation#ignoreResults:member}\n       * @defaultValue `false`\n       */\n      ignoreResults?: boolean;\n    }\n  }\n\n  export type Options<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  > = Base.Options<TData, TVariables> & VariablesOption<TVariables>;\n\n  export namespace DocumentationTypes {\n    namespace useSubscription {\n      export interface Options<\n        TData = unknown,\n        TVariables extends OperationVariables = OperationVariables,\n      > extends Base.Options<TData, TVariables>,\n          UtilityDocumentationTypes.VariableOptions<TVariables> {}\n    }\n  }\n\n  export interface Result<TData = unknown> {\n    /** {@inheritDoc @apollo/client!SubscriptionResultDocumentation#loading:member} */\n    loading: boolean;\n\n    /** {@inheritDoc @apollo/client!SubscriptionResultDocumentation#data:member} */\n    data?: MaybeMasked<TData>;\n\n    /** {@inheritDoc @apollo/client!SubscriptionResultDocumentation#error:member} */\n    error?: ErrorLike;\n\n    /**\n     * A function that when called will disconnect and reconnect the connection\n     * to the subscription. If the subscription is deduplicated, this will\n     * restart the connection for all deduplicated subscriptions.\n     */\n    restart: () => void;\n  }\n\n  export namespace DocumentationTypes {\n    namespace useSubscription {\n      export interface Result<TData = unknown> extends _self.Result<TData> {}\n    }\n  }\n\n  export namespace DocumentationTypes {\n    /** {@inheritDoc @apollo/client/react!useSubscription:function(1)} */\n    export function useSubscription<\n      TData = unknown,\n      TVariables extends OperationVariables = OperationVariables,\n    >(\n      options?: useSubscription.Options<TData, TVariables>\n    ): useSubscription.Result<TData>;\n  }\n\n  export type OnDataResult<TData = unknown> = Omit<Result<TData>, \"restart\">;\n\n  export interface OnDataOptions<TData = unknown> {\n    client: ApolloClient;\n    data: OnDataResult<TData>;\n  }\n\n  export interface OnSubscriptionDataOptions<TData = unknown> {\n    client: ApolloClient;\n    subscriptionData: OnDataResult<TData>;\n  }\n}\n\n/**\n * > Refer to the [Subscriptions](https://www.apollographql.com/docs/react/data/subscriptions/) section for a more in-depth overview of `useSubscription`.\n *\n * @example\n *\n * ```jsx\n * const COMMENTS_SUBSCRIPTION = gql`\n *   subscription OnCommentAdded($repoFullName: String!) {\n *     commentAdded(repoFullName: $repoFullName) {\n *       id\n *       content\n *     }\n *   }\n * `;\n *\n * function DontReadTheComments({ repoFullName }) {\n *   const {\n *     data: { commentAdded },\n *     loading,\n *   } = useSubscription(COMMENTS_SUBSCRIPTION, { variables: { repoFullName } });\n *   return <h4>New comment: {!loading && commentAdded.content}</h4>;\n * }\n * ```\n *\n * @remarks\n *\n * #### Consider using `onData` instead of `useEffect`\n *\n * If you want to react to incoming data, please use the `onData` option instead of `useEffect`.\n * State updates you make inside a `useEffect` hook might cause additional rerenders, and `useEffect` is mostly meant for side effects of rendering, not as an event handler.\n * State updates made in an event handler like `onData` might - depending on the React version - be batched and cause only a single rerender.\n *\n * Consider the following component:\n *\n * ```jsx\n * export function Subscriptions() {\n *   const { data, error, loading } = useSubscription(query);\n *   const [accumulatedData, setAccumulatedData] = useState([]);\n *\n *   useEffect(() => {\n *     setAccumulatedData((prev) => [...prev, data]);\n *   }, [data]);\n *\n *   return (\n *     <>\n *       {loading && <p>Loading...</p>}\n *       {JSON.stringify(accumulatedData, undefined, 2)}\n *     </>\n *   );\n * }\n * ```\n *\n * Instead of using `useEffect` here, we can re-write this component to use the `onData` callback function accepted in `useSubscription`'s `options` object:\n *\n * ```jsx\n * export function Subscriptions() {\n *   const [accumulatedData, setAccumulatedData] = useState([]);\n *   const { data, error, loading } = useSubscription(query, {\n *     onData({ data }) {\n *       setAccumulatedData((prev) => [...prev, data]);\n *     },\n *   });\n *\n *   return (\n *     <>\n *       {loading && <p>Loading...</p>}\n *       {JSON.stringify(accumulatedData, undefined, 2)}\n *     </>\n *   );\n * }\n * ```\n *\n * > ⚠️ **Note:** The `useSubscription` option `onData` is available in Apollo Client >= 3.7. In previous versions, the equivalent option is named `onSubscriptionData`.\n *\n * Now, the first message will be added to the `accumulatedData` array since `onData` is called _before_ the component re-renders. React 18 automatic batching is still in effect and results in a single re-render, but with `onData` we can guarantee each message received after the component mounts is added to `accumulatedData`.\n *\n * @param subscription - A GraphQL subscription document parsed into an AST by `gql`.\n * @param options - Options to control how the subscription is executed.\n * @returns Query result object\n */\nexport function useSubscription<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  subscription: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  ...[options = {} as useSubscription.Options<TData, TVariables>]: {} extends (\n    TVariables\n  ) ?\n    [options?: useSubscription.Options<NoInfer<TData>, NoInfer<TVariables>>]\n  : [options: useSubscription.Options<NoInfer<TData>, NoInfer<TVariables>>]\n): useSubscription.Result<TData> {\n  const client = useApolloClient(options.client);\n\n  const {\n    skip,\n    fetchPolicy,\n    errorPolicy,\n    shouldResubscribe,\n    context,\n    extensions,\n    ignoreResults,\n  } = options;\n  const variables = useDeepMemo(() => options.variables, [options.variables]);\n\n  const recreate = () =>\n    createSubscription(\n      client,\n      subscription,\n      variables,\n      fetchPolicy,\n      errorPolicy,\n      context,\n      extensions\n    );\n\n  let [observable, setObservable] = React.useState(\n    options.skip ? null : recreate\n  );\n\n  const recreateRef = React.useRef(recreate);\n  useIsomorphicLayoutEffect(() => {\n    recreateRef.current = recreate;\n  });\n\n  if (skip) {\n    if (observable) {\n      setObservable((observable = null));\n    }\n  } else if (\n    !observable ||\n    ((client !== observable.__.client ||\n      subscription !== observable.__.query ||\n      fetchPolicy !== observable.__.fetchPolicy ||\n      errorPolicy !== observable.__.errorPolicy ||\n      !equal(variables, observable.__.variables)) &&\n      (typeof shouldResubscribe === \"function\" ?\n        !!shouldResubscribe(options!)\n      : shouldResubscribe) !== false)\n  ) {\n    setObservable((observable = recreate()));\n  }\n\n  const optionsRef = React.useRef(options);\n  React.useEffect(() => {\n    optionsRef.current = options;\n  });\n\n  const fallbackLoading = !skip && !ignoreResults;\n  const fallbackResult = React.useMemo(\n    () => ({\n      loading: fallbackLoading,\n      error: void 0,\n      data: void 0,\n    }),\n    [fallbackLoading]\n  );\n\n  const ignoreResultsRef = React.useRef(ignoreResults);\n  useIsomorphicLayoutEffect(() => {\n    // We cannot reference `ignoreResults` directly in the effect below\n    // it would add a dependency to the `useEffect` deps array, which means the\n    // subscription would be recreated if `ignoreResults` changes\n    // As a result, on resubscription, the last result would be re-delivered,\n    // rendering the component one additional time, and re-triggering `onData`.\n    // The same applies to `fetchPolicy`, which results in a new `observable`\n    // being created. We cannot really avoid it in that case, but we can at least\n    // avoid it for `ignoreResults`.\n    ignoreResultsRef.current = ignoreResults;\n  });\n\n  const ret = useSyncExternalStore(\n    React.useCallback(\n      (update) => {\n        if (!observable) {\n          return () => {};\n        }\n\n        let subscriptionStopped = false;\n        const client = observable.__.client;\n        const subscription = observable.subscribe({\n          next(value) {\n            if (subscriptionStopped) {\n              return;\n            }\n\n            const result = {\n              loading: false,\n              data: value.data,\n              error: value.error,\n            };\n\n            observable.__.setResult(result);\n            if (!ignoreResultsRef.current) update();\n\n            if (result.error) {\n              optionsRef.current.onError?.(result.error);\n            } else if (optionsRef.current.onData) {\n              optionsRef.current.onData({\n                client,\n                data: result,\n              });\n            }\n          },\n          complete() {\n            observable.__.completed = true;\n            if (!subscriptionStopped && optionsRef.current.onComplete) {\n              optionsRef.current.onComplete();\n            }\n          },\n        });\n\n        return () => {\n          // immediately stop receiving subscription values, but do not unsubscribe\n          // until after a short delay in case another useSubscription hook is\n          // reusing the same underlying observable and is about to subscribe\n          subscriptionStopped = true;\n\n          setTimeout(() => subscription.unsubscribe());\n        };\n      },\n      [observable]\n    ),\n    () =>\n      observable && !skip && !ignoreResults ?\n        observable.__.result\n      : fallbackResult,\n    () => fallbackResult\n  );\n\n  const restart = React.useCallback(() => {\n    invariant(\n      !optionsRef.current.skip,\n      \"A subscription that is skipped cannot be restarted.\"\n    );\n    if (observable?.__.completed) {\n      setObservable(recreateRef.current());\n    } else {\n      observable?.restart();\n    }\n  }, [optionsRef, recreateRef, observable]);\n\n  return React.useMemo(() => ({ ...ret, restart }), [ret, restart]);\n}\n\ntype SubscriptionResult<TData> = Omit<useSubscription.Result<TData>, \"restart\">;\n\nfunction createSubscription<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  client: ApolloClient,\n  query: TypedDocumentNode<TData, TVariables>,\n  variables: TVariables | undefined,\n  fetchPolicy: FetchPolicy | undefined,\n  errorPolicy: ErrorPolicy | undefined,\n  context: DefaultContext | undefined,\n  extensions: Record<string, any> | undefined\n) {\n  const options = {\n    query,\n    variables,\n    fetchPolicy,\n    errorPolicy,\n    context,\n    extensions,\n  } as ApolloClient.SubscribeOptions<TData, TVariables>;\n  const __ = {\n    ...options,\n    client,\n    completed: false,\n    result: {\n      loading: true,\n      data: void 0,\n      error: void 0,\n    } as SubscriptionResult<TData>,\n    setResult(result: SubscriptionResult<TData>) {\n      __.result = result;\n    },\n  };\n\n  return Object.assign(client.subscribe(options), {\n    /**\n     * A tracking object to store details about the observable and the latest result of the subscription.\n     */\n    __,\n  });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}