{"ast":null,"code":"import { equal } from \"@wry/equality\";\nimport { createFulfilledPromise, decoratePromise } from \"@apollo/client/utilities/internal\";\nexport class FragmentReference {\n  observable;\n  key = {};\n  promise;\n  resolve;\n  reject;\n  subscription;\n  listeners = new Set();\n  autoDisposeTimeoutId;\n  references = 0;\n  constructor(client, watchFragmentOptions, options) {\n    this.dispose = this.dispose.bind(this);\n    this.handleNext = this.handleNext.bind(this);\n    this.handleError = this.handleError.bind(this);\n    this.observable = client.watchFragment(watchFragmentOptions);\n    if (options.onDispose) {\n      this.onDispose = options.onDispose;\n    }\n    const diff = this.getDiff(client, watchFragmentOptions);\n    // Start a timer that will automatically dispose of the query if the\n    // suspended resource does not use this fragmentRef in the given time. This\n    // helps prevent memory leaks when a component has unmounted before the\n    // query has finished loading.\n    const startDisposeTimer = () => {\n      if (!this.references) {\n        this.autoDisposeTimeoutId = setTimeout(this.dispose, options.autoDisposeTimeoutMs ?? 30_000);\n      }\n    };\n    this.promise = diff.complete ? createFulfilledPromise(diff.result) : this.createPendingPromise();\n    this.subscribeToFragment();\n    this.promise.then(startDisposeTimer, startDisposeTimer);\n  }\n  listen(listener) {\n    this.listeners.add(listener);\n    return () => {\n      this.listeners.delete(listener);\n    };\n  }\n  retain() {\n    this.references++;\n    clearTimeout(this.autoDisposeTimeoutId);\n    let disposed = false;\n    return () => {\n      if (disposed) {\n        return;\n      }\n      disposed = true;\n      this.references--;\n      setTimeout(() => {\n        if (!this.references) {\n          this.dispose();\n        }\n      });\n    };\n  }\n  dispose() {\n    this.subscription.unsubscribe();\n  }\n  onDispose() {\n    // noop. overridable by options\n  }\n  subscribeToFragment() {\n    this.subscription = this.observable.subscribe(this.handleNext.bind(this), this.handleError.bind(this));\n    // call `onDispose` when the subscription is finalized, either because it is\n    // unsubscribed as a consequence of a `dispose` call or because the\n    // ObservableQuery completes because of a `ApolloClient.stop()` call.\n    this.subscription.add(this.onDispose);\n  }\n  handleNext(result) {\n    switch (this.promise.status) {\n      case \"pending\":\n        {\n          if (result.complete) {\n            return this.resolve?.(result.data);\n          }\n          this.deliver(this.promise);\n          break;\n        }\n      case \"fulfilled\":\n        {\n          // This can occur when we already have a result written to the cache and\n          // we subscribe for the first time. We create a fulfilled promise in the\n          // constructor with a value that is the same as the first emitted value\n          // so we want to skip delivering it.\n          if (equal(this.promise.value, result.data)) {\n            return;\n          }\n          this.promise = result.complete ? createFulfilledPromise(result.data) : this.createPendingPromise();\n          this.deliver(this.promise);\n        }\n    }\n  }\n  handleError(error) {\n    this.reject?.(error);\n  }\n  deliver(promise) {\n    this.listeners.forEach(listener => listener(promise));\n  }\n  createPendingPromise() {\n    return decoratePromise(new Promise((resolve, reject) => {\n      this.resolve = resolve;\n      this.reject = reject;\n    }));\n  }\n  getDiff(client, options) {\n    const {\n      cache\n    } = client;\n    const {\n      from,\n      fragment,\n      fragmentName\n    } = options;\n    const diff = cache.diff({\n      ...options,\n      query: cache[\"getFragmentDoc\"](client[\"transform\"](fragment), fragmentName),\n      returnPartialData: true,\n      id: from,\n      optimistic: true\n    });\n    return {\n      ...diff,\n      result: client[\"queryManager\"].maskFragment({\n        fragment,\n        fragmentName,\n        data: diff.result\n      })\n    };\n  }\n}","map":{"version":3,"names":["equal","createFulfilledPromise","decoratePromise","FragmentReference","observable","key","promise","resolve","reject","subscription","listeners","Set","autoDisposeTimeoutId","references","constructor","client","watchFragmentOptions","options","dispose","bind","handleNext","handleError","watchFragment","onDispose","diff","getDiff","startDisposeTimer","setTimeout","autoDisposeTimeoutMs","complete","result","createPendingPromise","subscribeToFragment","then","listen","listener","add","delete","retain","clearTimeout","disposed","unsubscribe","subscribe","status","data","deliver","value","error","forEach","Promise","cache","from","fragment","fragmentName","query","returnPartialData","id","optimistic","maskFragment"],"sources":["/home/saurabh-shukla/Desktop/Slack Lite/frontend/node_modules/@apollo/src/react/internal/cache/FragmentReference.ts"],"sourcesContent":["import { equal } from \"@wry/equality\";\nimport type { Observable, Subscription } from \"rxjs\";\n\nimport type { ApolloClient, OperationVariables } from \"@apollo/client\";\nimport type { MaybeMasked } from \"@apollo/client/masking\";\nimport type { DecoratedPromise } from \"@apollo/client/utilities/internal\";\nimport {\n  createFulfilledPromise,\n  decoratePromise,\n} from \"@apollo/client/utilities/internal\";\n\nimport type { FragmentKey } from \"./types.js\";\n\ntype FragmentRefPromise<TData> = DecoratedPromise<TData>;\ntype Listener<TData> = (promise: FragmentRefPromise<TData>) => void;\n\ninterface FragmentReferenceOptions {\n  autoDisposeTimeoutMs?: number;\n  onDispose?: () => void;\n}\n\nexport class FragmentReference<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n> {\n  public readonly observable: Observable<\n    ApolloClient.WatchFragmentResult<TData>\n  >;\n  public readonly key: FragmentKey = {};\n  public promise!: FragmentRefPromise<MaybeMasked<TData>>;\n\n  private resolve: ((result: MaybeMasked<TData>) => void) | undefined;\n  private reject: ((error: unknown) => void) | undefined;\n\n  private subscription!: Subscription;\n  private listeners = new Set<Listener<MaybeMasked<TData>>>();\n  private autoDisposeTimeoutId?: NodeJS.Timeout;\n\n  private references = 0;\n\n  constructor(\n    client: ApolloClient,\n    watchFragmentOptions: ApolloClient.WatchFragmentOptions<\n      TData,\n      TVariables\n    > & {\n      from: string;\n    },\n    options: FragmentReferenceOptions\n  ) {\n    this.dispose = this.dispose.bind(this);\n    this.handleNext = this.handleNext.bind(this);\n    this.handleError = this.handleError.bind(this);\n\n    this.observable = client.watchFragment(watchFragmentOptions);\n\n    if (options.onDispose) {\n      this.onDispose = options.onDispose;\n    }\n\n    const diff = this.getDiff(client, watchFragmentOptions);\n\n    // Start a timer that will automatically dispose of the query if the\n    // suspended resource does not use this fragmentRef in the given time. This\n    // helps prevent memory leaks when a component has unmounted before the\n    // query has finished loading.\n    const startDisposeTimer = () => {\n      if (!this.references) {\n        this.autoDisposeTimeoutId = setTimeout(\n          this.dispose,\n          options.autoDisposeTimeoutMs ?? 30_000\n        );\n      }\n    };\n\n    this.promise =\n      diff.complete ?\n        createFulfilledPromise(diff.result)\n      : this.createPendingPromise();\n    this.subscribeToFragment();\n\n    this.promise.then(startDisposeTimer, startDisposeTimer);\n  }\n\n  listen(listener: Listener<MaybeMasked<TData>>) {\n    this.listeners.add(listener);\n\n    return () => {\n      this.listeners.delete(listener);\n    };\n  }\n\n  retain() {\n    this.references++;\n    clearTimeout(this.autoDisposeTimeoutId);\n    let disposed = false;\n\n    return () => {\n      if (disposed) {\n        return;\n      }\n\n      disposed = true;\n      this.references--;\n\n      setTimeout(() => {\n        if (!this.references) {\n          this.dispose();\n        }\n      });\n    };\n  }\n\n  private dispose() {\n    this.subscription.unsubscribe();\n  }\n\n  private onDispose() {\n    // noop. overridable by options\n  }\n\n  private subscribeToFragment() {\n    this.subscription = this.observable.subscribe(\n      this.handleNext.bind(this),\n      this.handleError.bind(this)\n    );\n    // call `onDispose` when the subscription is finalized, either because it is\n    // unsubscribed as a consequence of a `dispose` call or because the\n    // ObservableQuery completes because of a `ApolloClient.stop()` call.\n    this.subscription.add(this.onDispose);\n  }\n\n  private handleNext(result: ApolloClient.WatchFragmentResult<TData>) {\n    switch (this.promise.status) {\n      case \"pending\": {\n        if (result.complete) {\n          return this.resolve?.(result.data);\n        }\n\n        this.deliver(this.promise);\n        break;\n      }\n      case \"fulfilled\": {\n        // This can occur when we already have a result written to the cache and\n        // we subscribe for the first time. We create a fulfilled promise in the\n        // constructor with a value that is the same as the first emitted value\n        // so we want to skip delivering it.\n        if (equal(this.promise.value, result.data)) {\n          return;\n        }\n\n        this.promise =\n          result.complete ?\n            createFulfilledPromise(result.data)\n          : this.createPendingPromise();\n\n        this.deliver(this.promise);\n      }\n    }\n  }\n\n  private handleError(error: unknown) {\n    this.reject?.(error);\n  }\n\n  private deliver(promise: FragmentRefPromise<MaybeMasked<TData>>) {\n    this.listeners.forEach((listener) => listener(promise));\n  }\n\n  private createPendingPromise() {\n    return decoratePromise(\n      new Promise<MaybeMasked<TData>>((resolve, reject) => {\n        this.resolve = resolve;\n        this.reject = reject;\n      })\n    );\n  }\n\n  private getDiff<TData, TVariables extends OperationVariables>(\n    client: ApolloClient,\n    options: ApolloClient.WatchFragmentOptions<TData, TVariables> & {\n      from: string;\n    }\n  ) {\n    const { cache } = client;\n    const { from, fragment, fragmentName } = options;\n\n    const diff = cache.diff<TData, TVariables>({\n      ...options,\n      query: cache[\"getFragmentDoc\"](\n        client[\"transform\"](fragment),\n        fragmentName\n      ),\n      returnPartialData: true,\n      id: from,\n      optimistic: true,\n    });\n\n    return {\n      ...diff,\n      result: client[\"queryManager\"].maskFragment({\n        fragment,\n        fragmentName,\n        data: diff.result,\n      }) as MaybeMasked<TData>,\n    };\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}