{"ast":null,"code":"import { WeakCache } from \"@wry/caches\";\nimport { wrap } from \"optimism\";\nimport { Observable } from \"rxjs\";\nimport { cacheSizes } from \"@apollo/client/utilities\";\nimport { __DEV__ } from \"@apollo/client/utilities/environment\";\nimport { equalByQuery, getApolloCacheMemoryInternals, getFragmentDefinition, getFragmentQueryDocument } from \"@apollo/client/utilities/internal\";\nimport { invariant } from \"@apollo/client/utilities/invariant\";\nexport class ApolloCache {\n  assumeImmutableResults = false;\n  // Function used to lookup a fragment when a fragment definition is not part\n  // of the GraphQL document. This is useful for caches, such as InMemoryCache,\n  // that register fragments ahead of time so they can be referenced by name.\n  lookupFragment(fragmentName) {\n    return null;\n  }\n  // Transactional API\n  // The batch method is intended to replace/subsume both performTransaction\n  // and recordOptimisticTransaction, but performTransaction came first, so we\n  // provide a default batch implementation that's just another way of calling\n  // performTransaction. Subclasses of ApolloCache (such as InMemoryCache) can\n  // override the batch method to do more interesting things with its options.\n  batch(options) {\n    const optimisticId = typeof options.optimistic === \"string\" ? options.optimistic : options.optimistic === false ? null : void 0;\n    let updateResult;\n    this.performTransaction(() => updateResult = options.update(this), optimisticId);\n    return updateResult;\n  }\n  recordOptimisticTransaction(transaction, optimisticId) {\n    this.performTransaction(transaction, optimisticId);\n  }\n  // Optional API\n  // Called once per input document, allowing the cache to make static changes\n  // to the query, such as adding __typename fields.\n  transformDocument(document) {\n    return document;\n  }\n  // Called before each ApolloLink request, allowing the cache to make dynamic\n  // changes to the query, such as filling in missing fragment definitions.\n  transformForLink(document) {\n    return document;\n  }\n  identify(object) {\n    return;\n  }\n  gc() {\n    return [];\n  }\n  modify(options) {\n    return false;\n  }\n  readQuery(options, optimistic = !!options.optimistic) {\n    return this.read({\n      ...options,\n      rootId: options.id || \"ROOT_QUERY\",\n      optimistic\n    });\n  }\n  /**\n  * Watches the cache store of the fragment according to the options specified\n  * and returns an `Observable`. We can subscribe to this\n  * `Observable` and receive updated results through an\n  * observer when the cache store changes.\n  * \n  * You must pass in a GraphQL document with a single fragment or a document\n  * with multiple fragments that represent what you are reading. If you pass\n  * in a document with multiple fragments then you must also specify a\n  * `fragmentName`.\n  * \n  * @since 3.10.0\n  * @param options - An object of type `WatchFragmentOptions` that allows\n  * the cache to identify the fragment and optionally specify whether to react\n  * to optimistic updates.\n  */\n  watchFragment(options) {\n    const {\n      fragment,\n      fragmentName,\n      from,\n      optimistic = true,\n      ...otherOptions\n    } = options;\n    const query = this.getFragmentDoc(fragment, fragmentName);\n    // While our TypeScript types do not allow for `undefined` as a valid\n    // `from`, its possible `useFragment` gives us an `undefined` since it\n    // calls` cache.identify` and provides that value to `from`. We are\n    // adding this fix here however to ensure those using plain JavaScript\n    // and using `cache.identify` themselves will avoid seeing the obscure\n    // warning.\n    const id = typeof from === \"undefined\" || typeof from === \"string\" ? from : this.identify(from);\n    if (__DEV__) {\n      const actualFragmentName = fragmentName || getFragmentDefinition(fragment).name.value;\n      if (!id) {\n        __DEV__ && invariant.warn(109, actualFragmentName);\n      }\n    }\n    const diffOptions = {\n      ...otherOptions,\n      returnPartialData: true,\n      id,\n      query,\n      optimistic\n    };\n    let latestDiff;\n    return new Observable(observer => {\n      return this.watch({\n        ...diffOptions,\n        immediate: true,\n        callback: diff => {\n          let data = diff.result;\n          // TODO: Remove this once `watchFragment` supports `null` as valid\n          // value emitted\n          if (data === null) {\n            data = {};\n          }\n          if (\n          // Always ensure we deliver the first result\n          latestDiff && equalByQuery(query, {\n            data: latestDiff.result\n          }, {\n            data\n          }, options.variables)) {\n            return;\n          }\n          const result = {\n            data,\n            dataState: diff.complete ? \"complete\" : \"partial\",\n            complete: !!diff.complete\n          };\n          if (diff.missing) {\n            result.missing = diff.missing.missing;\n          }\n          latestDiff = {\n            ...diff,\n            result: data\n          };\n          observer.next(result);\n        }\n      });\n    });\n  }\n  // Make sure we compute the same (===) fragment query document every\n  // time we receive the same fragment in readFragment.\n  getFragmentDoc = wrap(getFragmentQueryDocument, {\n    max: cacheSizes[\"cache.fragmentQueryDocuments\"] || 1000 /* defaultCacheSizes[\"cache.fragmentQueryDocuments\"] */,\n    cache: WeakCache\n  });\n  readFragment(options, optimistic = !!options.optimistic) {\n    return this.read({\n      ...options,\n      query: this.getFragmentDoc(options.fragment, options.fragmentName),\n      rootId: options.id,\n      optimistic\n    });\n  }\n  writeQuery({\n    id,\n    data,\n    ...options\n  }) {\n    return this.write(Object.assign(options, {\n      dataId: id || \"ROOT_QUERY\",\n      result: data\n    }));\n  }\n  writeFragment({\n    id,\n    data,\n    fragment,\n    fragmentName,\n    ...options\n  }) {\n    return this.write(Object.assign(options, {\n      query: this.getFragmentDoc(fragment, fragmentName),\n      dataId: id,\n      result: data\n    }));\n  }\n  updateQuery(options, update) {\n    return this.batch({\n      update(cache) {\n        const value = cache.readQuery(options);\n        const data = update(value);\n        if (data === void 0 || data === null) return value;\n        cache.writeQuery({\n          ...options,\n          data\n        });\n        return data;\n      }\n    });\n  }\n  updateFragment(options, update) {\n    return this.batch({\n      update(cache) {\n        const value = cache.readFragment(options);\n        const data = update(value);\n        if (data === void 0 || data === null) return value;\n        cache.writeFragment({\n          ...options,\n          data\n        });\n        return data;\n      }\n    });\n  }\n}\nif (__DEV__) {\n  ApolloCache.prototype.getMemoryInternals = getApolloCacheMemoryInternals;\n}","map":{"version":3,"names":["WeakCache","wrap","Observable","cacheSizes","__DEV__","equalByQuery","getApolloCacheMemoryInternals","getFragmentDefinition","getFragmentQueryDocument","invariant","ApolloCache","assumeImmutableResults","lookupFragment","fragmentName","batch","options","optimisticId","optimistic","updateResult","performTransaction","update","recordOptimisticTransaction","transaction","transformDocument","document","transformForLink","identify","object","gc","modify","readQuery","read","rootId","id","watchFragment","fragment","from","otherOptions","query","getFragmentDoc","actualFragmentName","name","value","warn","diffOptions","returnPartialData","latestDiff","observer","watch","immediate","callback","diff","data","result","variables","dataState","complete","missing","next","max","cache","readFragment","writeQuery","write","Object","assign","dataId","writeFragment","updateQuery","updateFragment","prototype","getMemoryInternals"],"sources":["/home/saurabh-shukla/Desktop/Slack Lite/frontend/node_modules/@apollo/src/cache/core/cache.ts"],"sourcesContent":["import { WeakCache } from \"@wry/caches\";\nimport type {\n  DocumentNode,\n  FragmentDefinitionNode,\n  InlineFragmentNode,\n} from \"graphql\";\nimport { wrap } from \"optimism\";\nimport { Observable } from \"rxjs\";\n\nimport type {\n  GetDataState,\n  OperationVariables,\n  TypedDocumentNode,\n} from \"@apollo/client\";\nimport type { FragmentType, Unmasked } from \"@apollo/client/masking\";\nimport type { Reference, StoreObject } from \"@apollo/client/utilities\";\nimport { cacheSizes } from \"@apollo/client/utilities\";\nimport { __DEV__ } from \"@apollo/client/utilities/environment\";\nimport type { NoInfer } from \"@apollo/client/utilities/internal\";\nimport {\n  equalByQuery,\n  getApolloCacheMemoryInternals,\n  getFragmentDefinition,\n  getFragmentQueryDocument,\n} from \"@apollo/client/utilities/internal\";\nimport { invariant } from \"@apollo/client/utilities/invariant\";\n\nimport { defaultCacheSizes } from \"../../utilities/caching/sizes.js\";\n\nimport type { Cache } from \"./types/Cache.js\";\nimport type { MissingTree } from \"./types/common.js\";\n\nexport type Transaction = (c: ApolloCache) => void;\n\nexport declare namespace ApolloCache {\n  /**\n   * Watched fragment options.\n   */\n  export interface WatchFragmentOptions<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  > {\n    /**\n     * A GraphQL fragment document parsed into an AST with the `gql`\n     * template literal.\n     *\n     * @docGroup 1. Required options\n     */\n    fragment: DocumentNode | TypedDocumentNode<TData, TVariables>;\n    /**\n     * An object containing a `__typename` and primary key fields\n     * (such as `id`) identifying the entity object from which the fragment will\n     * be retrieved, or a `{ __ref: \"...\" }` reference, or a `string` ID\n     * (uncommon).\n     *\n     * @docGroup 1. Required options\n     */\n    from: StoreObject | Reference | FragmentType<NoInfer<TData>> | string;\n    /**\n     * Any variables that the GraphQL fragment may depend on.\n     *\n     * @docGroup 2. Cache options\n     */\n    variables?: TVariables;\n    /**\n     * The name of the fragment defined in the fragment document.\n     *\n     * Required if the fragment document includes more than one fragment,\n     * optional otherwise.\n     *\n     * @docGroup 2. Cache options\n     */\n    fragmentName?: string;\n    /**\n     * If `true`, `watchFragment` returns optimistic results.\n     *\n     * The default value is `true`.\n     *\n     * @docGroup 2. Cache options\n     */\n    optimistic?: boolean;\n  }\n\n  /**\n   * Watched fragment results.\n   */\n  export type WatchFragmentResult<TData = unknown> =\n    | ({\n        complete: true;\n        missing?: never;\n      } & GetDataState<TData, \"complete\">)\n    | ({\n        complete: false;\n        missing: MissingTree;\n      } & GetDataState<TData, \"partial\">);\n}\n\nexport abstract class ApolloCache {\n  public readonly assumeImmutableResults: boolean = false;\n\n  // required to implement\n  // core API\n  public abstract read<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >(query: Cache.ReadOptions<TData, TVariables>): Unmasked<TData> | null;\n  public abstract write<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >(write: Cache.WriteOptions<TData, TVariables>): Reference | undefined;\n\n  /**\n   * Returns data read from the cache for a given query along with information\n   * about the cache result such as whether the result is complete and details\n   * about missing fields.\n   *\n   * Will return `complete` as `true` if it can fulfill the full cache result or\n   * `false` if not. When no data can be fulfilled from the cache, `null` is\n   * returned. When `returnPartialData` is `true`, non-null partial results are\n   * returned if it contains at least one field that can be fulfilled from the\n   * cache.\n   */\n  public abstract diff<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >(query: Cache.DiffOptions<TData, TVariables>): Cache.DiffResult<TData>;\n  public abstract watch<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >(watch: Cache.WatchOptions<TData, TVariables>): () => void;\n\n  // Empty the cache and restart all current watches (unless\n  // options.discardWatches is true).\n  public abstract reset(options?: Cache.ResetOptions): Promise<void>;\n\n  // Remove whole objects from the cache by passing just options.id, or\n  // specific fields by passing options.field and/or options.args. If no\n  // options.args are provided, all fields matching options.field (even\n  // those with arguments) will be removed. Returns true iff any data was\n  // removed from the cache.\n  public abstract evict(options: Cache.EvictOptions): boolean;\n\n  // initializer / offline / ssr API\n  /**\n   * Replaces existing state in the cache (if any) with the values expressed by\n   * `serializedState`.\n   *\n   * Called when hydrating a cache (server side rendering, or offline storage),\n   * and also (potentially) during hot reloads.\n   */\n  public abstract restore(serializedState: unknown): this;\n\n  /**\n   * Exposes the cache's complete state, in a serializable format for later restoration.\n   */\n  public abstract extract(optimistic?: boolean): unknown;\n\n  // Optimistic API\n\n  public abstract removeOptimistic(id: string): void;\n\n  // Used by data masking to determine if an inline fragment with a type\n  // condition matches a given typename. Also used by local resolvers to match a\n  // fragment against a typename.\n  //\n  // If not implemented by a cache subclass, data masking will effectively be\n  // disabled since we will not be able to accurately determine if a given type\n  // condition for a union or interface matches a particular type.\n  public abstract fragmentMatches(\n    fragment: InlineFragmentNode | FragmentDefinitionNode,\n    typename: string\n  ): boolean;\n\n  // Function used to lookup a fragment when a fragment definition is not part\n  // of the GraphQL document. This is useful for caches, such as InMemoryCache,\n  // that register fragments ahead of time so they can be referenced by name.\n  public lookupFragment(fragmentName: string): FragmentDefinitionNode | null {\n    return null;\n  }\n\n  // Transactional API\n\n  // The batch method is intended to replace/subsume both performTransaction\n  // and recordOptimisticTransaction, but performTransaction came first, so we\n  // provide a default batch implementation that's just another way of calling\n  // performTransaction. Subclasses of ApolloCache (such as InMemoryCache) can\n  // override the batch method to do more interesting things with its options.\n  public batch<U>(options: Cache.BatchOptions<this, U>): U {\n    const optimisticId =\n      typeof options.optimistic === \"string\" ? options.optimistic\n      : options.optimistic === false ? null\n      : void 0;\n    let updateResult: U;\n    this.performTransaction(\n      () => (updateResult = options.update(this)),\n      optimisticId\n    );\n    return updateResult!;\n  }\n\n  public abstract performTransaction(\n    transaction: Transaction,\n    // Although subclasses may implement recordOptimisticTransaction\n    // however they choose, the default implementation simply calls\n    // performTransaction with a string as the second argument, allowing\n    // performTransaction to handle both optimistic and non-optimistic\n    // (broadcast-batching) transactions. Passing null for optimisticId is\n    // also allowed, and indicates that performTransaction should apply\n    // the transaction non-optimistically (ignoring optimistic data).\n    optimisticId?: string | null\n  ): void;\n\n  public recordOptimisticTransaction(\n    transaction: Transaction,\n    optimisticId: string\n  ) {\n    this.performTransaction(transaction, optimisticId);\n  }\n\n  // Optional API\n\n  // Called once per input document, allowing the cache to make static changes\n  // to the query, such as adding __typename fields.\n  public transformDocument(document: DocumentNode): DocumentNode {\n    return document;\n  }\n\n  // Called before each ApolloLink request, allowing the cache to make dynamic\n  // changes to the query, such as filling in missing fragment definitions.\n  public transformForLink(document: DocumentNode): DocumentNode {\n    return document;\n  }\n\n  public identify(object: StoreObject | Reference): string | undefined {\n    return;\n  }\n\n  public gc(): string[] {\n    return [];\n  }\n\n  public modify<Entity extends Record<string, any> = Record<string, any>>(\n    options: Cache.ModifyOptions<Entity>\n  ): boolean {\n    return false;\n  }\n\n  /**\n   * Read data from the cache for the specified query.\n   */\n  public readQuery<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >({\n    // spread in type definitions for discoverability in the docs\n    query,\n    variables,\n    id,\n    optimistic,\n    returnPartialData,\n  }: Cache.ReadQueryOptions<TData, TVariables>): Unmasked<TData> | null;\n  /**\n   * {@inheritDoc @apollo/client!ApolloCache#readQuery:member(1)}\n   */\n  public readQuery<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >(\n    options: Cache.ReadQueryOptions<TData, TVariables>,\n    /**\n     * @deprecated Pass the `optimistic` argument as part of the first argument\n     * instead of passing it as a separate option.\n     */\n    optimistic: boolean\n  ): Unmasked<TData> | null;\n  public readQuery<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >(\n    options: Cache.ReadQueryOptions<TData, TVariables>,\n    optimistic = !!options.optimistic\n  ): Unmasked<TData> | null {\n    return this.read({\n      ...options,\n      rootId: options.id || \"ROOT_QUERY\",\n      optimistic,\n    });\n  }\n\n  /** {@inheritDoc @apollo/client!ApolloClient#watchFragment:member(1)} */\n  public watchFragment<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >(\n    options: ApolloCache.WatchFragmentOptions<TData, TVariables>\n  ): Observable<ApolloCache.WatchFragmentResult<Unmasked<TData>>> {\n    const {\n      fragment,\n      fragmentName,\n      from,\n      optimistic = true,\n      ...otherOptions\n    } = options;\n    const query = this.getFragmentDoc(fragment, fragmentName);\n    // While our TypeScript types do not allow for `undefined` as a valid\n    // `from`, its possible `useFragment` gives us an `undefined` since it\n    // calls` cache.identify` and provides that value to `from`. We are\n    // adding this fix here however to ensure those using plain JavaScript\n    // and using `cache.identify` themselves will avoid seeing the obscure\n    // warning.\n    const id =\n      typeof from === \"undefined\" || typeof from === \"string\" ?\n        from\n      : this.identify(from);\n\n    if (__DEV__) {\n      const actualFragmentName =\n        fragmentName || getFragmentDefinition(fragment).name.value;\n\n      if (!id) {\n        invariant.warn(\n          \"Could not identify object passed to `from` for '%s' fragment, either because the object is non-normalized or the key fields are missing. If you are masking this object, please ensure the key fields are requested by the parent object.\",\n          actualFragmentName\n        );\n      }\n    }\n\n    const diffOptions: Cache.DiffOptions<TData, TVariables> = {\n      ...otherOptions,\n      returnPartialData: true,\n      id,\n      query,\n      optimistic,\n    };\n\n    let latestDiff: Cache.DiffResult<TData> | undefined;\n\n    return new Observable((observer) => {\n      return this.watch<TData, TVariables>({\n        ...diffOptions,\n        immediate: true,\n        callback: (diff) => {\n          let data = diff.result;\n\n          // TODO: Remove this once `watchFragment` supports `null` as valid\n          // value emitted\n          if (data === null) {\n            data = {} as any;\n          }\n\n          if (\n            // Always ensure we deliver the first result\n            latestDiff &&\n            equalByQuery(\n              query,\n              { data: latestDiff.result },\n              { data },\n              options.variables\n            )\n          ) {\n            return;\n          }\n\n          const result = {\n            data,\n            dataState: diff.complete ? \"complete\" : \"partial\",\n            complete: !!diff.complete,\n          } as ApolloCache.WatchFragmentResult<Unmasked<TData>>;\n\n          if (diff.missing) {\n            result.missing = diff.missing.missing;\n          }\n\n          latestDiff = { ...diff, result: data } as Cache.DiffResult<TData>;\n          observer.next(result);\n        },\n      });\n    });\n  }\n\n  // Make sure we compute the same (===) fragment query document every\n  // time we receive the same fragment in readFragment.\n  private getFragmentDoc = wrap(getFragmentQueryDocument, {\n    max:\n      cacheSizes[\"cache.fragmentQueryDocuments\"] ||\n      defaultCacheSizes[\"cache.fragmentQueryDocuments\"],\n    cache: WeakCache,\n  });\n\n  /**\n   * Read data from the cache for the specified fragment.\n   */\n  public readFragment<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >({\n    // spread in type definitions for discoverability in the docs\n    fragment,\n    variables,\n    fragmentName,\n    id,\n    optimistic,\n    returnPartialData,\n  }: Cache.ReadFragmentOptions<TData, TVariables>): Unmasked<TData> | null;\n  public readFragment<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >(\n    options: Cache.ReadFragmentOptions<TData, TVariables>,\n    /**\n     * @deprecated Pass the `optimistic` argument as part of the first argument\n     * instead of passing it as a separate option.\n     */\n    optimistic: boolean\n  ): Unmasked<TData> | null;\n  public readFragment<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >(\n    options: Cache.ReadFragmentOptions<TData, TVariables>,\n    optimistic = !!options.optimistic\n  ): Unmasked<TData> | null {\n    return this.read({\n      ...options,\n      query: this.getFragmentDoc(options.fragment, options.fragmentName),\n      rootId: options.id,\n      optimistic,\n    });\n  }\n\n  /**\n   * Writes data to the root of the cache using the specified query to validate that\n   * the shape of the data you’re writing to the cache is the same as the shape of\n   * the data required by the query. Great for prepping the cache with initial data.\n   */\n  public writeQuery<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >({\n    // spread in type definitions for discoverability in the docs\n    data,\n    query,\n    variables,\n    overwrite,\n    id,\n    broadcast,\n  }: Cache.WriteQueryOptions<TData, TVariables>): Reference | undefined;\n  public writeQuery<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >({\n    id,\n    data,\n    ...options\n  }: Cache.WriteQueryOptions<TData, TVariables>): Reference | undefined {\n    return this.write(\n      Object.assign(options, {\n        dataId: id || \"ROOT_QUERY\",\n        result: data,\n      })\n    );\n  }\n\n  /**\n   * Similar to `writeQuery` (writes data to the cache) but uses the specified\n   * fragment to validate that the shape of the data you’re writing to the cache\n   * is the same as the shape of the data required by the fragment.\n   */\n  public writeFragment<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >({\n    // spread in type definitions for discoverability in the docs\n    data,\n    fragment,\n    fragmentName,\n    variables,\n    overwrite,\n    id,\n    broadcast,\n  }: Cache.WriteFragmentOptions<TData, TVariables>): Reference | undefined;\n  public writeFragment<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >({\n    id,\n    data,\n    fragment,\n    fragmentName,\n    ...options\n  }: Cache.WriteFragmentOptions<TData, TVariables>): Reference | undefined {\n    return this.write(\n      Object.assign(options, {\n        query: this.getFragmentDoc(fragment, fragmentName),\n        dataId: id,\n        result: data,\n      })\n    );\n  }\n\n  public updateQuery<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >(\n    options: Cache.UpdateQueryOptions<TData, TVariables>,\n    update: (data: Unmasked<TData> | null) => Unmasked<TData> | null | void\n  ): Unmasked<TData> | null {\n    return this.batch({\n      update(cache) {\n        const value = cache.readQuery<TData, TVariables>(options);\n        const data = update(value);\n        if (data === void 0 || data === null) return value;\n        cache.writeQuery<TData, TVariables>({ ...options, data });\n        return data;\n      },\n    });\n  }\n\n  public updateFragment<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >(\n    options: Cache.UpdateFragmentOptions<TData, TVariables>,\n    update: (data: Unmasked<TData> | null) => Unmasked<TData> | null | void\n  ): Unmasked<TData> | null {\n    return this.batch({\n      update(cache) {\n        const value = cache.readFragment<TData, TVariables>(options);\n        const data = update(value);\n        if (data === void 0 || data === null) return value;\n        cache.writeFragment<TData, TVariables>({ ...options, data });\n        return data;\n      },\n    });\n  }\n\n  /**\n   * @experimental\n   * @internal\n   * This is not a stable API - it is used in development builds to expose\n   * information to the DevTools.\n   * Use at your own risk!\n   */\n  public declare getMemoryInternals?: typeof getApolloCacheMemoryInternals;\n}\n\nif (__DEV__) {\n  ApolloCache.prototype.getMemoryInternals = getApolloCacheMemoryInternals;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}