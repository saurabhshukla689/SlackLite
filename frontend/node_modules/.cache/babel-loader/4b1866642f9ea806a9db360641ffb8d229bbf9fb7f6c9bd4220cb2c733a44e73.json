{"ast":null,"code":"import { WeakCache } from \"@wry/caches\";\nimport { Trie } from \"@wry/trie\";\nimport { wrap } from \"optimism\";\nimport { checkDocument } from \"@apollo/client/utilities/internal\";\nimport { invariant } from \"@apollo/client/utilities/invariant\";\nimport { cacheSizes } from \"../caching/sizes.js\";\nfunction identity(document) {\n  return document;\n}\n/**\n * A class for transforming GraphQL documents. See the [Document transforms\n * documentation](https://www.apollographql.com/docs/react/data/document-transforms) for more details on using them.\n *\n * @example\n *\n * ```ts\n * import { DocumentTransform } from \"@apollo/client/utilities\";\n * import { visit } from \"graphql\";\n *\n * const documentTransform = new DocumentTransform((doc) => {\n *   return visit(doc, {\n *     // ...\n *   });\n * });\n *\n * const transformedDoc = documentTransform.transformDocument(myDocument);\n * ```\n */\nexport class DocumentTransform {\n  transform;\n  cached;\n  resultCache = new WeakSet();\n  // This default implementation of getCacheKey can be overridden by providing\n  // options.getCacheKey to the DocumentTransform constructor. In general, a\n  // getCacheKey function may either return an array of keys (often including\n  // the document) to be used as a cache key, or undefined to indicate the\n  // transform for this document should not be cached.\n  getCacheKey(document) {\n    return [document];\n  }\n  /**\n   * Creates a DocumentTransform that returns the input document unchanged.\n   *\n   * @returns The input document\n   */\n  static identity() {\n    // No need to cache this transform since it just returns the document\n    // unchanged. This should save a bit of memory that would otherwise be\n    // needed to populate the `documentCache` of this transform.\n    return new DocumentTransform(identity, {\n      cache: false\n    });\n  }\n  /**\n   * Creates a DocumentTransform that conditionally applies one of two transforms.\n   *\n   * @param predicate - Function that determines which transform to apply\n   * @param left - Transform to apply when `predicate` returns `true`\n   * @param right - Transform to apply when `predicate` returns `false`. If not provided, it defaults to `DocumentTransform.identity()`.\n   * @returns A DocumentTransform that conditionally applies a document transform based on the predicate\n   *\n   * @example\n   *\n   * ```ts\n   * import { isQueryOperation } from \"@apollo/client/utilities\";\n   *\n   * const conditionalTransform = DocumentTransform.split(\n   *   (document) => isQueryOperation(document),\n   *   queryTransform,\n   *   mutationTransform\n   * );\n   * ```\n   */\n  static split(predicate, left, right = DocumentTransform.identity()) {\n    return Object.assign(new DocumentTransform(document => {\n      const documentTransform = predicate(document) ? left : right;\n      return documentTransform.transformDocument(document);\n    },\n    // Reasonably assume both `left` and `right` transforms handle their own caching\n    {\n      cache: false\n    }), {\n      left,\n      right\n    });\n  }\n  constructor(transform, options = {}) {\n    this.transform = transform;\n    if (options.getCacheKey) {\n      // Override default `getCacheKey` function, which returns [document].\n      this.getCacheKey = options.getCacheKey;\n    }\n    this.cached = options.cache !== false;\n    this.resetCache();\n  }\n  /**\n   * Resets the internal cache of this transform, if it is cached.\n   */\n  resetCache() {\n    if (this.cached) {\n      const stableCacheKeys = new Trie();\n      this.performWork = wrap(DocumentTransform.prototype.performWork.bind(this), {\n        makeCacheKey: document => {\n          const cacheKeys = this.getCacheKey(document);\n          if (cacheKeys) {\n            invariant(Array.isArray(cacheKeys), 20);\n            return stableCacheKeys.lookupArray(cacheKeys);\n          }\n        },\n        max: cacheSizes[\"documentTransform.cache\"],\n        cache: WeakCache\n      });\n    }\n  }\n  performWork(document) {\n    checkDocument(document);\n    return this.transform(document);\n  }\n  /**\n   * Transforms a GraphQL document using the configured transform function.\n   *\n   * @remarks\n   *\n   * Note that `transformDocument` caches the transformed document. Calling\n   * `transformDocument` again with the already-transformed document will\n   * immediately return it.\n   *\n   * @param document - The GraphQL document to transform\n   * @returns The transformed document\n   *\n   * @example\n   *\n   * ```ts\n   * const document = gql`\n   *   # ...\n   * `;\n   *\n   * const documentTransform = new DocumentTransform(transformFn);\n   * const transformedDocument = documentTransform.transformDocument(document);\n   * ```\n   */\n  transformDocument(document) {\n    // If a user passes an already transformed result back to this function,\n    // immediately return it.\n    if (this.resultCache.has(document)) {\n      return document;\n    }\n    const transformedDocument = this.performWork(document);\n    this.resultCache.add(transformedDocument);\n    return transformedDocument;\n  }\n  /**\n   * Combines this document transform with another document transform. The\n   * returned document transform first applies the current document transform,\n   * then applies the other document transform.\n   *\n   * @param otherTransform - The transform to apply after this one\n   * @returns A new DocumentTransform that applies both transforms in sequence\n   *\n   * @example\n   *\n   * ```ts\n   * const combinedTransform = addTypenameTransform.concat(\n   *   removeDirectivesTransform\n   * );\n   * ```\n   */\n  concat(otherTransform) {\n    return Object.assign(new DocumentTransform(document => {\n      return otherTransform.transformDocument(this.transformDocument(document));\n    },\n    // Reasonably assume both transforms handle their own caching\n    {\n      cache: false\n    }), {\n      left: this,\n      right: otherTransform\n    });\n  }\n  /**\n  * @internal\n  * Used to iterate through all transforms that are concatenations or `split` links.\n  * \n  * @deprecated This is an internal API and should not be used directly. This can be removed or changed at any time.\n  */\n  left;\n  /**\n  * @internal\n  * Used to iterate through all transforms that are concatenations or `split` links.\n  * \n  * @deprecated This is an internal API and should not be used directly. This can be removed or changed at any time.\n  */\n  right;\n}","map":{"version":3,"names":["WeakCache","Trie","wrap","checkDocument","invariant","cacheSizes","identity","document","DocumentTransform","transform","cached","resultCache","WeakSet","getCacheKey","cache","split","predicate","left","right","Object","assign","documentTransform","transformDocument","constructor","options","resetCache","stableCacheKeys","performWork","prototype","bind","makeCacheKey","cacheKeys","Array","isArray","lookupArray","max","has","transformedDocument","add","concat","otherTransform"],"sources":["/home/saurabh-shukla/Desktop/Slack Lite/frontend/node_modules/@apollo/src/utilities/graphql/DocumentTransform.ts"],"sourcesContent":["import { WeakCache } from \"@wry/caches\";\nimport { Trie } from \"@wry/trie\";\nimport type { DocumentNode } from \"graphql\";\nimport { wrap } from \"optimism\";\n\nimport { checkDocument } from \"@apollo/client/utilities/internal\";\nimport { invariant } from \"@apollo/client/utilities/invariant\";\n\nimport { cacheSizes } from \"../caching/sizes.js\";\n\nexport type DocumentTransformCacheKey = ReadonlyArray<unknown>;\n\ntype TransformFn = (document: DocumentNode) => DocumentNode;\n\ninterface DocumentTransformOptions {\n  /**\n   * Determines whether to cache the transformed GraphQL document. Caching can\n   * speed up repeated calls to the document transform for the same input\n   * document. Set to `false` to completely disable caching for the document\n   * transform. When disabled, this option takes precedence over the [`getCacheKey`](#getcachekey)\n   * option.\n   *\n   * @defaultValue `true`\n   */\n  cache?: boolean;\n  /**\n   * Defines a custom cache key for a GraphQL document that will determine whether to re-run the document transform when given the same input GraphQL document. Returns an array that defines the cache key. Return `undefined` to disable caching for that GraphQL document.\n   *\n   * > [!NOTE]\n   * > The items in the array can be any type, but each item needs to be\n   * > referentially stable to guarantee a stable cache key.\n   *\n   * @defaultValue `(document) => [document]`\n   */\n  getCacheKey?: (\n    document: DocumentNode\n  ) => DocumentTransformCacheKey | undefined;\n}\n\nfunction identity(document: DocumentNode) {\n  return document;\n}\n\n/**\n * A class for transforming GraphQL documents. See the [Document transforms\n * documentation](https://www.apollographql.com/docs/react/data/document-transforms) for more details on using them.\n *\n * @example\n *\n * ```ts\n * import { DocumentTransform } from \"@apollo/client/utilities\";\n * import { visit } from \"graphql\";\n *\n * const documentTransform = new DocumentTransform((doc) => {\n *   return visit(doc, {\n *     // ...\n *   });\n * });\n *\n * const transformedDoc = documentTransform.transformDocument(myDocument);\n * ```\n */\nexport class DocumentTransform {\n  private readonly transform: TransformFn;\n  private cached: boolean;\n\n  private readonly resultCache = new WeakSet<DocumentNode>();\n\n  // This default implementation of getCacheKey can be overridden by providing\n  // options.getCacheKey to the DocumentTransform constructor. In general, a\n  // getCacheKey function may either return an array of keys (often including\n  // the document) to be used as a cache key, or undefined to indicate the\n  // transform for this document should not be cached.\n  private getCacheKey(\n    document: DocumentNode\n  ): DocumentTransformCacheKey | undefined {\n    return [document];\n  }\n\n  /**\n   * Creates a DocumentTransform that returns the input document unchanged.\n   *\n   * @returns The input document\n   */\n  static identity() {\n    // No need to cache this transform since it just returns the document\n    // unchanged. This should save a bit of memory that would otherwise be\n    // needed to populate the `documentCache` of this transform.\n    return new DocumentTransform(identity, { cache: false });\n  }\n\n  /**\n   * Creates a DocumentTransform that conditionally applies one of two transforms.\n   *\n   * @param predicate - Function that determines which transform to apply\n   * @param left - Transform to apply when `predicate` returns `true`\n   * @param right - Transform to apply when `predicate` returns `false`. If not provided, it defaults to `DocumentTransform.identity()`.\n   * @returns A DocumentTransform that conditionally applies a document transform based on the predicate\n   *\n   * @example\n   *\n   * ```ts\n   * import { isQueryOperation } from \"@apollo/client/utilities\";\n   *\n   * const conditionalTransform = DocumentTransform.split(\n   *   (document) => isQueryOperation(document),\n   *   queryTransform,\n   *   mutationTransform\n   * );\n   * ```\n   */\n  static split(\n    predicate: (document: DocumentNode) => boolean,\n    left: DocumentTransform,\n    right: DocumentTransform = DocumentTransform.identity()\n  ) {\n    return Object.assign(\n      new DocumentTransform(\n        (document) => {\n          const documentTransform = predicate(document) ? left : right;\n\n          return documentTransform.transformDocument(document);\n        },\n        // Reasonably assume both `left` and `right` transforms handle their own caching\n        { cache: false }\n      ),\n      { left, right }\n    );\n  }\n\n  constructor(transform: TransformFn, options: DocumentTransformOptions = {}) {\n    this.transform = transform;\n\n    if (options.getCacheKey) {\n      // Override default `getCacheKey` function, which returns [document].\n      this.getCacheKey = options.getCacheKey;\n    }\n    this.cached = options.cache !== false;\n\n    this.resetCache();\n  }\n\n  /**\n   * Resets the internal cache of this transform, if it is cached.\n   */\n  resetCache() {\n    if (this.cached) {\n      const stableCacheKeys = new Trie<WeakKey>();\n      this.performWork = wrap(\n        DocumentTransform.prototype.performWork.bind(this),\n        {\n          makeCacheKey: (document) => {\n            const cacheKeys = this.getCacheKey(document);\n            if (cacheKeys) {\n              invariant(\n                Array.isArray(cacheKeys),\n                \"`getCacheKey` must return an array or undefined\"\n              );\n              return stableCacheKeys.lookupArray(cacheKeys);\n            }\n          },\n          max: cacheSizes[\"documentTransform.cache\"],\n          cache: WeakCache<any, any>,\n        }\n      );\n    }\n  }\n\n  private performWork(document: DocumentNode) {\n    checkDocument(document);\n    return this.transform(document);\n  }\n\n  /**\n   * Transforms a GraphQL document using the configured transform function.\n   *\n   * @remarks\n   *\n   * Note that `transformDocument` caches the transformed document. Calling\n   * `transformDocument` again with the already-transformed document will\n   * immediately return it.\n   *\n   * @param document - The GraphQL document to transform\n   * @returns The transformed document\n   *\n   * @example\n   *\n   * ```ts\n   * const document = gql`\n   *   # ...\n   * `;\n   *\n   * const documentTransform = new DocumentTransform(transformFn);\n   * const transformedDocument = documentTransform.transformDocument(document);\n   * ```\n   */\n  transformDocument(document: DocumentNode) {\n    // If a user passes an already transformed result back to this function,\n    // immediately return it.\n    if (this.resultCache.has(document)) {\n      return document;\n    }\n\n    const transformedDocument = this.performWork(document);\n\n    this.resultCache.add(transformedDocument);\n\n    return transformedDocument;\n  }\n\n  /**\n   * Combines this document transform with another document transform. The\n   * returned document transform first applies the current document transform,\n   * then applies the other document transform.\n   *\n   * @param otherTransform - The transform to apply after this one\n   * @returns A new DocumentTransform that applies both transforms in sequence\n   *\n   * @example\n   *\n   * ```ts\n   * const combinedTransform = addTypenameTransform.concat(\n   *   removeDirectivesTransform\n   * );\n   * ```\n   */\n  concat(otherTransform: DocumentTransform): DocumentTransform {\n    return Object.assign(\n      new DocumentTransform(\n        (document) => {\n          return otherTransform.transformDocument(\n            this.transformDocument(document)\n          );\n        },\n        // Reasonably assume both transforms handle their own caching\n        { cache: false }\n      ),\n      {\n        left: this,\n        right: otherTransform,\n      }\n    );\n  }\n\n  /**\n   * @internal\n   * Used to iterate through all transforms that are concatenations or `split` links.\n   */\n  readonly left?: DocumentTransform;\n  /**\n   * @internal\n   * Used to iterate through all transforms that are concatenations or `split` links.\n   */\n  readonly right?: DocumentTransform;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}