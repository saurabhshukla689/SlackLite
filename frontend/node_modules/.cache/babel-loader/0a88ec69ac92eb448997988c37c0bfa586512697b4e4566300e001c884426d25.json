{"ast":null,"code":"import * as React from \"react\";\nimport { wrapperSymbol } from \"@apollo/client/react/internal\";\n// direct import to avoid circular dependency\nimport { getApolloContext } from \"../../context/ApolloContext.js\";\n/**\n* @internal\n*\n* Makes an Apollo Client hook \"wrappable\".\n* That means that the Apollo Client instance can expose a \"wrapper\" that will be\n* used to wrap the original hook implementation with additional logic.\n* @example\n*\n* ```tsx\n* // this is already done in `@apollo/client` for all wrappable hooks (see `WrappableHooks`)\n* // following this pattern\n* function useQuery() {\n*   return wrapHook('useQuery', _useQuery, options.client)(query, options);\n* }\n* function _useQuery(query, options) {\n*   // original implementation\n* }\n*\n* // this is what a library like `@apollo/client-react-streaming` would do\n* class ApolloClientWithStreaming extends ApolloClient {\n*   constructor(options) {\n*     super(options);\n*     this.queryManager[Symbol.for(\"apollo.hook.wrappers\")] = {\n*       useQuery: (original) => (query, options) => {\n*         console.log(\"useQuery was called with options\", options);\n*         return original(query, options);\n*       }\n*     }\n*   }\n* }\n*\n* // this will now log the options and then call the original `useQuery`\n* const client = new ApolloClientWithStreaming({ ... });\n* useQuery(query, { client });\n* ```\n* \n* @deprecated This is an internal API and should not be used directly. This can be removed or changed at any time.\n*/\nexport function wrapHook(hookName, useHook, clientOrObsQuery) {\n  // Priority-wise, the later entries in this array wrap\n  // previous entries and could prevent them (and in the end,\n  // even the original hook) from running\n  const wrapperSources = [clientOrObsQuery[\"queryManager\"],\n  // if we are a hook (not `preloadQuery`), we are guaranteed to be inside of\n  // a React render and can use context\n  hookName.startsWith(\"use\") ?\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  React.useContext(getApolloContext()) : undefined];\n  let wrapped = useHook;\n  for (const source of wrapperSources) {\n    const wrapper = source?.[wrapperSymbol]?.[hookName];\n    if (wrapper) {\n      wrapped = wrapper(wrapped);\n    }\n  }\n  return wrapped;\n}","map":{"version":3,"names":["React","wrapperSymbol","getApolloContext","wrapHook","hookName","useHook","clientOrObsQuery","wrapperSources","startsWith","useContext","undefined","wrapped","source","wrapper"],"sources":["/home/saurabh-shukla/Desktop/Slack Lite/frontend/node_modules/@apollo/src/react/hooks/internal/wrapHook.ts"],"sourcesContent":["import * as React from \"react\";\n\nimport type { ApolloClient, InternalTypes } from \"@apollo/client\";\nimport type { ObservableQuery } from \"@apollo/client\";\nimport type { createQueryPreloader } from \"@apollo/client/react\";\nimport type {\n  useBackgroundQuery,\n  useFragment,\n  useQuery,\n  useQueryRefHandlers,\n  useReadQuery,\n  useSuspenseFragment,\n  useSuspenseQuery,\n} from \"@apollo/client/react\";\nimport { wrapperSymbol } from \"@apollo/client/react/internal\";\n\n// direct import to avoid circular dependency\nimport { getApolloContext } from \"../../context/ApolloContext.js\";\n\ntype FunctionSignature<T> =\n  T extends (...args: infer A) => infer R ? (...args: A) => R : never;\n\ninterface WrappableHooks {\n  createQueryPreloader: FunctionSignature<typeof createQueryPreloader>;\n  useQuery: FunctionSignature<typeof useQuery>;\n  useSuspenseQuery: FunctionSignature<typeof useSuspenseQuery>;\n  useSuspenseFragment: FunctionSignature<typeof useSuspenseFragment>;\n  useBackgroundQuery: FunctionSignature<typeof useBackgroundQuery>;\n  useReadQuery: FunctionSignature<typeof useReadQuery>;\n  useFragment: FunctionSignature<typeof useFragment>;\n  useQueryRefHandlers: FunctionSignature<typeof useQueryRefHandlers>;\n}\n\n/**\n * @internal\n * Can be used to correctly type the [Symbol.for(\"apollo.hook.wrappers\")] property of\n * `QueryManager`, to override/wrap hook functionality.\n */\nexport type HookWrappers = {\n  [K in keyof WrappableHooks]?: (\n    originalHook: WrappableHooks[K]\n  ) => WrappableHooks[K];\n};\n\ninterface QueryManagerWithWrappers extends InternalTypes.QueryManager {\n  [wrapperSymbol]?: HookWrappers;\n}\n\n/**\n * @internal\n *\n * Makes an Apollo Client hook \"wrappable\".\n * That means that the Apollo Client instance can expose a \"wrapper\" that will be\n * used to wrap the original hook implementation with additional logic.\n * @example\n *\n * ```tsx\n * // this is already done in `@apollo/client` for all wrappable hooks (see `WrappableHooks`)\n * // following this pattern\n * function useQuery() {\n *   return wrapHook('useQuery', _useQuery, options.client)(query, options);\n * }\n * function _useQuery(query, options) {\n *   // original implementation\n * }\n *\n * // this is what a library like `@apollo/client-react-streaming` would do\n * class ApolloClientWithStreaming extends ApolloClient {\n *   constructor(options) {\n *     super(options);\n *     this.queryManager[Symbol.for(\"apollo.hook.wrappers\")] = {\n *       useQuery: (original) => (query, options) => {\n *         console.log(\"useQuery was called with options\", options);\n *         return original(query, options);\n *       }\n *     }\n *   }\n * }\n *\n * // this will now log the options and then call the original `useQuery`\n * const client = new ApolloClientWithStreaming({ ... });\n * useQuery(query, { client });\n * ```\n */\nexport function wrapHook<Hook extends (...args: any[]) => any>(\n  hookName: keyof WrappableHooks,\n  useHook: Hook,\n  clientOrObsQuery: ObservableQuery<any> | ApolloClient\n): Hook {\n  // Priority-wise, the later entries in this array wrap\n  // previous entries and could prevent them (and in the end,\n  // even the original hook) from running\n  const wrapperSources = [\n    (\n      clientOrObsQuery as unknown as {\n        // both `ApolloClient` and `ObservableQuery` have a `queryManager` property\n        // but they're both `private`, so we have to cast around for a bit here.\n        queryManager: QueryManagerWithWrappers;\n      }\n    )[\"queryManager\"],\n    // if we are a hook (not `preloadQuery`), we are guaranteed to be inside of\n    // a React render and can use context\n    hookName.startsWith(\"use\") ?\n      // eslint-disable-next-line react-hooks/rules-of-hooks\n      React.useContext(getApolloContext())\n    : undefined,\n  ];\n\n  let wrapped = useHook;\n  for (const source of wrapperSources) {\n    const wrapper = source?.[wrapperSymbol]?.[hookName];\n    if (wrapper) {\n      wrapped = wrapper(wrapped) as Hook;\n    }\n  }\n\n  return wrapped;\n}\n"],"mappings":"AAAA,OAAO,KAAKA,KAAZ,MAAuB,OAAO;AAc9B,SAASC,aAAT,QAA8B,+BAA+B;AAE7D;AACA,SAASC,gBAAT,QAAiC,gCAAgC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAmEjE,gBAAgBC,QAAQA,CACtBC,QAA8B,EAC9BC,OAAa,EACbC,gBAAqD,EAHvD;EAKE;EACA;EACA;EACA,MAAMC,cAAR,GAAyB,CAEnBD,gBAKD,CAAC,cAAc,CAAC;EACjB;EACA;EACAF,QAAQ,CAACI,UAAU,CAAC,KAAK;EACvB;EACAR,KAAK,CAACS,UAAU,CAACP,gBAAgB,CAAvC,CAAyC,IACnCQ,SAAS,CACZ;EAED,IAAIC,OAAN,GAAgBN,OAAO;EACrB,KAAK,MAAMO,MAAb,IAAuBL,cAAc,EAAE;IACnC,MAAMM,OAAV,GAAoBD,MAAM,GAAGX,aAAa,CAAC,GAAGG,QAAQ,CAAC;IACnD,IAAIS,OAAO,EAAE;MACXF,OAAN,GAAgBE,OAAO,CAACF,OAAO,CAAS;IACpC;EACF;EAEA,OAAOA,OAAO;AAChB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}