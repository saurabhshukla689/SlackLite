{"ast":null,"code":"import { isReference } from \"@apollo/client/utilities\";\nimport { compact, createFragmentMap, DeepMerger, getFragmentDefinitions, isArray, isField, isNonNullObject, resultKeyNameFromField, shouldInclude } from \"@apollo/client/utilities/internal\";\nexport const {\n  hasOwnProperty: hasOwn\n} = Object.prototype;\nexport function defaultDataIdFromObject({\n  __typename,\n  id,\n  _id\n}, context) {\n  if (typeof __typename === \"string\") {\n    if (context) {\n      context.keyObject = id != null ? {\n        id\n      } : _id != null ? {\n        _id\n      } : void 0;\n    }\n    // If there is no object.id, fall back to object._id.\n    if (id == null && _id != null) {\n      id = _id;\n    }\n    if (id != null) {\n      return `${__typename}:${typeof id === \"number\" || typeof id === \"string\" ? id : JSON.stringify(id)}`;\n    }\n  }\n}\nconst defaultConfig = {\n  dataIdFromObject: defaultDataIdFromObject,\n  resultCaching: true\n};\nexport function normalizeConfig(config) {\n  return compact(defaultConfig, config);\n}\nexport function getTypenameFromStoreObject(store, objectOrReference) {\n  return isReference(objectOrReference) ? store.get(objectOrReference.__ref, \"__typename\") : objectOrReference && objectOrReference.__typename;\n}\nexport const TypeOrFieldNameRegExp = /^[_a-z][_0-9a-z]*/i;\nexport function fieldNameFromStoreName(storeFieldName) {\n  const match = storeFieldName.match(TypeOrFieldNameRegExp);\n  return match ? match[0] : storeFieldName;\n}\nexport function selectionSetMatchesResult(selectionSet, result, variables) {\n  if (isNonNullObject(result)) {\n    return isArray(result) ? result.every(item => selectionSetMatchesResult(selectionSet, item, variables)) : selectionSet.selections.every(field => {\n      if (isField(field) && shouldInclude(field, variables)) {\n        const key = resultKeyNameFromField(field);\n        return hasOwn.call(result, key) && (!field.selectionSet || selectionSetMatchesResult(field.selectionSet, result[key], variables));\n      }\n      // If the selection has been skipped with @skip(true) or\n      // @include(false), it should not count against the matching. If\n      // the selection is not a field, it must be a fragment (inline or\n      // named). We will determine if selectionSetMatchesResult for that\n      // fragment when we get to it, so for now we return true.\n      return true;\n    });\n  }\n  return false;\n}\nexport function storeValueIsStoreObject(value) {\n  return isNonNullObject(value) && !isReference(value) && !isArray(value);\n}\nexport function makeProcessedFieldsMerger() {\n  return new DeepMerger();\n}\nexport function extractFragmentContext(document, fragments) {\n  // FragmentMap consisting only of fragments defined directly in document, not\n  // including other fragments registered in the FragmentRegistry.\n  const fragmentMap = createFragmentMap(getFragmentDefinitions(document));\n  return {\n    fragmentMap,\n    lookupFragment(name) {\n      let def = fragmentMap[name];\n      if (!def && fragments) {\n        def = fragments.lookup(name);\n      }\n      return def || null;\n    }\n  };\n}","map":{"version":3,"names":["isReference","compact","createFragmentMap","DeepMerger","getFragmentDefinitions","isArray","isField","isNonNullObject","resultKeyNameFromField","shouldInclude","hasOwnProperty","hasOwn","Object","prototype","defaultDataIdFromObject","__typename","id","_id","context","keyObject","JSON","stringify","defaultConfig","dataIdFromObject","resultCaching","normalizeConfig","config","getTypenameFromStoreObject","store","objectOrReference","get","__ref","TypeOrFieldNameRegExp","fieldNameFromStoreName","storeFieldName","match","selectionSetMatchesResult","selectionSet","result","variables","every","item","selections","field","key","call","storeValueIsStoreObject","value","makeProcessedFieldsMerger","extractFragmentContext","document","fragments","fragmentMap","lookupFragment","name","def","lookup"],"sources":["/home/saurabh-shukla/Desktop/Slack Lite/frontend/node_modules/@apollo/src/cache/inmemory/helpers.ts"],"sourcesContent":["import type {\n  DocumentNode,\n  FragmentDefinitionNode,\n  SelectionSetNode,\n} from \"graphql\";\n\nimport type {\n  Reference,\n  StoreObject,\n  StoreValue,\n} from \"@apollo/client/utilities\";\nimport { isReference } from \"@apollo/client/utilities\";\nimport type {\n  FragmentMap,\n  FragmentMapFunction,\n} from \"@apollo/client/utilities/internal\";\nimport {\n  compact,\n  createFragmentMap,\n  DeepMerger,\n  getFragmentDefinitions,\n  isArray,\n  isField,\n  isNonNullObject,\n  resultKeyNameFromField,\n  shouldInclude,\n} from \"@apollo/client/utilities/internal\";\n\nimport type { FragmentRegistryAPI } from \"./fragmentRegistry.js\";\nimport type { KeyFieldsContext } from \"./policies.js\";\nimport type { InMemoryCacheConfig, NormalizedCache } from \"./types.js\";\n\nexport const { hasOwnProperty: hasOwn } = Object.prototype;\n\nexport function defaultDataIdFromObject(\n  { __typename, id, _id }: Readonly<StoreObject>,\n  context?: KeyFieldsContext\n): string | undefined {\n  if (typeof __typename === \"string\") {\n    if (context) {\n      context.keyObject =\n        id != null ? { id }\n        : _id != null ? { _id }\n        : void 0;\n    }\n\n    // If there is no object.id, fall back to object._id.\n    if (id == null && _id != null) {\n      id = _id;\n    }\n\n    if (id != null) {\n      return `${__typename}:${\n        typeof id === \"number\" || typeof id === \"string\" ?\n          id\n        : JSON.stringify(id)\n      }`;\n    }\n  }\n}\n\nconst defaultConfig: InMemoryCacheConfig = {\n  dataIdFromObject: defaultDataIdFromObject,\n  resultCaching: true,\n};\n\nexport function normalizeConfig(config: InMemoryCacheConfig) {\n  return compact(defaultConfig, config);\n}\n\nexport function getTypenameFromStoreObject(\n  store: NormalizedCache,\n  objectOrReference: StoreObject | Reference\n): string | undefined {\n  return isReference(objectOrReference) ?\n      (store.get(objectOrReference.__ref, \"__typename\") as string)\n    : objectOrReference && objectOrReference.__typename;\n}\n\nexport const TypeOrFieldNameRegExp = /^[_a-z][_0-9a-z]*/i;\n\nexport function fieldNameFromStoreName(storeFieldName: string): string {\n  const match = storeFieldName.match(TypeOrFieldNameRegExp);\n  return match ? match[0] : storeFieldName;\n}\n\nexport function selectionSetMatchesResult(\n  selectionSet: SelectionSetNode,\n  result: Record<string, any>,\n  variables?: Record<string, any>\n): boolean {\n  if (isNonNullObject(result)) {\n    return isArray(result) ?\n        result.every((item) =>\n          selectionSetMatchesResult(selectionSet, item, variables)\n        )\n      : selectionSet.selections.every((field) => {\n          if (isField(field) && shouldInclude(field, variables)) {\n            const key = resultKeyNameFromField(field);\n            return (\n              hasOwn.call(result, key) &&\n              (!field.selectionSet ||\n                selectionSetMatchesResult(\n                  field.selectionSet,\n                  result[key],\n                  variables\n                ))\n            );\n          }\n          // If the selection has been skipped with @skip(true) or\n          // @include(false), it should not count against the matching. If\n          // the selection is not a field, it must be a fragment (inline or\n          // named). We will determine if selectionSetMatchesResult for that\n          // fragment when we get to it, so for now we return true.\n          return true;\n        });\n  }\n  return false;\n}\n\nexport function storeValueIsStoreObject(\n  value: StoreValue\n): value is StoreObject {\n  return isNonNullObject(value) && !isReference(value) && !isArray(value);\n}\n\nexport function makeProcessedFieldsMerger() {\n  return new DeepMerger();\n}\n\nexport function extractFragmentContext(\n  document: DocumentNode,\n  fragments?: FragmentRegistryAPI\n): {\n  fragmentMap: FragmentMap;\n  lookupFragment: FragmentMapFunction;\n} {\n  // FragmentMap consisting only of fragments defined directly in document, not\n  // including other fragments registered in the FragmentRegistry.\n  const fragmentMap = createFragmentMap(getFragmentDefinitions(document));\n  return {\n    fragmentMap,\n    lookupFragment(name) {\n      let def: FragmentDefinitionNode | null = fragmentMap[name];\n      if (!def && fragments) {\n        def = fragments.lookup(name);\n      }\n      return def || null;\n    },\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}