{"ast":null,"code":"import { isNonNullObject } from \"./isNonNullObject.js\";\nconst {\n  hasOwnProperty\n} = Object.prototype;\nconst defaultReconciler = function (target, source, property) {\n  return this.merge(target[property], source[property]);\n};\n/**\n* @internal\n* \n* @deprecated This is an internal API and should not be used directly. This can be removed or changed at any time.\n*/\nexport class DeepMerger {\n  reconciler;\n  constructor(reconciler = defaultReconciler) {\n    this.reconciler = reconciler;\n  }\n  merge(target, source, ...context) {\n    if (isNonNullObject(source) && isNonNullObject(target)) {\n      Object.keys(source).forEach(sourceKey => {\n        if (hasOwnProperty.call(target, sourceKey)) {\n          const targetValue = target[sourceKey];\n          if (source[sourceKey] !== targetValue) {\n            const result = this.reconciler(target, source, sourceKey, ...context);\n            // A well-implemented reconciler may return targetValue to indicate\n            // the merge changed nothing about the structure of the target.\n            if (result !== targetValue) {\n              target = this.shallowCopyForMerge(target);\n              target[sourceKey] = result;\n            }\n          }\n        } else {\n          // If there is no collision, the target can safely share memory with\n          // the source, and the recursion can terminate here.\n          target = this.shallowCopyForMerge(target);\n          target[sourceKey] = source[sourceKey];\n        }\n      });\n      return target;\n    }\n    // If source (or target) is not an object, let source replace target.\n    return source;\n  }\n  isObject = isNonNullObject;\n  pastCopies = new Set();\n  shallowCopyForMerge(value) {\n    if (isNonNullObject(value)) {\n      if (!this.pastCopies.has(value)) {\n        if (Array.isArray(value)) {\n          value = value.slice(0);\n        } else {\n          value = {\n            __proto__: Object.getPrototypeOf(value),\n            ...value\n          };\n        }\n        this.pastCopies.add(value);\n      }\n    }\n    return value;\n  }\n}","map":{"version":3,"names":["isNonNullObject","hasOwnProperty","Object","prototype","defaultReconciler","target","source","property","merge","DeepMerger","reconciler","constructor","context","keys","forEach","sourceKey","call","targetValue","result","shallowCopyForMerge","isObject","pastCopies","Set","value","has","Array","isArray","slice","__proto__","getPrototypeOf","add"],"sources":["/home/saurabh-shukla/Desktop/Slack Lite/frontend/node_modules/@apollo/src/utilities/internal/DeepMerger.ts"],"sourcesContent":["import { isNonNullObject } from \"./isNonNullObject.js\";\n\nconst { hasOwnProperty } = Object.prototype;\n\ntype ReconcilerFunction<TContextArgs extends any[]> = (\n  this: DeepMerger<TContextArgs>,\n  target: Record<string | number, any>,\n  source: Record<string | number, any>,\n  property: string | number,\n  ...context: TContextArgs\n) => any;\n\nconst defaultReconciler: ReconcilerFunction<any[]> = function (\n  target,\n  source,\n  property\n) {\n  return this.merge(target[property], source[property]);\n};\n\n/** @internal */\nexport class DeepMerger<TContextArgs extends any[]> {\n  constructor(\n    private reconciler: ReconcilerFunction<TContextArgs> = defaultReconciler as any as ReconcilerFunction<TContextArgs>\n  ) {}\n\n  public merge(target: any, source: any, ...context: TContextArgs): any {\n    if (isNonNullObject(source) && isNonNullObject(target)) {\n      Object.keys(source).forEach((sourceKey) => {\n        if (hasOwnProperty.call(target, sourceKey)) {\n          const targetValue = target[sourceKey];\n          if (source[sourceKey] !== targetValue) {\n            const result = this.reconciler(\n              target,\n              source,\n              sourceKey,\n              ...context\n            );\n            // A well-implemented reconciler may return targetValue to indicate\n            // the merge changed nothing about the structure of the target.\n            if (result !== targetValue) {\n              target = this.shallowCopyForMerge(target);\n              target[sourceKey] = result;\n            }\n          }\n        } else {\n          // If there is no collision, the target can safely share memory with\n          // the source, and the recursion can terminate here.\n          target = this.shallowCopyForMerge(target);\n          target[sourceKey] = source[sourceKey];\n        }\n      });\n\n      return target;\n    }\n\n    // If source (or target) is not an object, let source replace target.\n    return source;\n  }\n\n  public isObject = isNonNullObject;\n\n  private pastCopies = new Set<any>();\n\n  public shallowCopyForMerge<T>(value: T): T {\n    if (isNonNullObject(value)) {\n      if (!this.pastCopies.has(value)) {\n        if (Array.isArray(value)) {\n          value = (value as any).slice(0);\n        } else {\n          value = {\n            __proto__: Object.getPrototypeOf(value),\n            ...value,\n          };\n        }\n        this.pastCopies.add(value);\n      }\n    }\n    return value;\n  }\n}\n"],"mappings":"AAAA,SAASA,eAAT,QAAgC,sBAAsB;AAEtD,MAAM;EAAEC;AAAR,IAA2BC,MAAM,CAACC,SAAS;AAU3C,MAAMC,iBAAN,GAAqD,SAAAA,CACnDC,MAAM,EACNC,MAAM,EACNC,QAAQ,EAHV;EAKE,OAAO,IAAI,CAACC,KAAK,CAACH,MAAM,CAACE,QAAQ,CAAC,EAAED,MAAM,CAACC,QAAQ,CAAC,CAAC;AACvD,CAAC;;;;;;AAGD,aAAaE,UAAb;EAEYC,UAAZ;EADEC,WAAFA,CACYD,UADZ,GAC2DN,iBAA4D,EADvH;IACY,IAAZ,CAAAM,UAAA,GAAYA,UAAU;EACjB;EAEIF,KAAKA,CAACH,MAAW,EAAEC,MAAW,EAAE,GAAGM,OAAqB,EAAjE;IACI,IAAIZ,eAAe,CAACM,MAAM,KAAKN,eAAe,CAACK,MAAM,CAAC,EAAE;MACtDH,MAAM,CAACW,IAAI,CAACP,MAAM,CAAC,CAACQ,OAAO,CAAEC,SAAS,IAA5C;QACQ,IAAId,cAAc,CAACe,IAAI,CAACX,MAAM,EAAEU,SAAS,CAAC,EAAE;UAC1C,MAAME,WAAhB,GAA8BZ,MAAM,CAACU,SAAS,CAAC;UACrC,IAAIT,MAAM,CAACS,SAAS,MAAME,WAAW,EAAE;YACrC,MAAMC,MAAlB,GAA2B,IAAI,CAACR,UAAU,CAC5BL,MAAM,EACNC,MAAM,EACNS,SAAS,EACT,GAAGH,OAAO,CACX;YACD;YACA;YACA,IAAIM,MAAhB,KAA2BD,WAAW,EAAE;cAC1BZ,MAAd,GAAuB,IAAI,CAACc,mBAAmB,CAACd,MAAM,CAAC;cACzCA,MAAM,CAACU,SAAS,IAAIG,MAAM;YAC5B;UACF;QACF,OAAO;UACL;UACA;UACAb,MAAV,GAAmB,IAAI,CAACc,mBAAmB,CAACd,MAAM,CAAC;UACzCA,MAAM,CAACU,SAAS,IAAIT,MAAM,CAACS,SAAS,CAAC;QACvC;MACF,CAAC,CAAC;MAEF,OAAOV,MAAM;IACf;IAEA;IACA,OAAOC,MAAM;EACf;EAEOc,QAAT,GAAoBpB,eAAe;EAEzBqB,UAAV,GAAuB,IAAIC,GAAG,CAA9B,CAAqC;EAE5BH,mBAAmBA,CAAII,KAAQ,EAAxC;IACI,IAAIvB,eAAe,CAACuB,KAAK,CAAC,EAAE;MAC1B,IAAI,CAAC,IAAI,CAACF,UAAU,CAACG,GAAG,CAACD,KAAK,CAAC,EAAE;QAC/B,IAAIE,KAAK,CAACC,OAAO,CAACH,KAAK,CAAC,EAAE;UACxBA,KAAV,GAAmBA,KAAa,CAACI,KAAK,CAAC,CAAC,CAAC;QACjC,OAAO;UACLJ,KAAV,GAAkB;YACNK,SAAS,EAAE1B,MAAM,CAAC2B,cAAc,CAACN,KAAK,CAAC;YACvC,GAAGA;UACf,CAAW;QACH;QACA,IAAI,CAACF,UAAU,CAACS,GAAG,CAACP,KAAK,CAAC;MAC5B;IACF;IACA,OAAOA,KAAK;EACd;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}