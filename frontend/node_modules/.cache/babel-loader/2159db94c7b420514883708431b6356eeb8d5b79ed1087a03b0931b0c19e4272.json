{"ast":null,"code":"import * as React from \"react\";\nimport { __DEV__ } from \"@apollo/client/utilities/environment\";\nimport { canUseDOM } from \"@apollo/client/utilities/internal\";\nimport { maybe } from \"@apollo/client/utilities/internal/globals\";\nimport { invariant } from \"@apollo/client/utilities/invariant\";\nlet didWarnUncachedGetSnapshot = false;\n// Prevent webpack from complaining about our feature detection of the\n// useSyncExternalStore property of the React namespace, which is expected not\n// to exist when using React 17 and earlier, and that's fine.\nconst uSESKey = \"useSyncExternalStore\";\nconst realHook = React[uSESKey];\nconst isReactNative = maybe(() => navigator.product) == \"ReactNative\";\nconst usingJSDOM =\n// Following advice found in this comment from @domenic (maintainer of jsdom):\n// https://github.com/jsdom/jsdom/issues/1537#issuecomment-229405327\n//\n// Since we control the version of Jest and jsdom used when running Apollo\n// Client tests, and that version is recent enought to include \" jsdom/x.y.z\"\n// at the end of the user agent string, I believe this case is all we need to\n// check. Testing for \"Node.js\" was recommended for backwards compatibility\n// with older version of jsdom, but we don't have that problem.\nmaybe(() => navigator.userAgent.indexOf(\"jsdom\") >= 0) || false;\n// Our tests should all continue to pass if we remove this !usingJSDOM\n// condition, thereby allowing useLayoutEffect when using jsdom. Unfortunately,\n// if we allow useLayoutEffect, then useSyncExternalStore generates many\n// warnings about useLayoutEffect doing nothing on the server. While these\n// warnings are harmless, this !usingJSDOM condition seems to be the best way to\n// prevent them (i.e. skipping useLayoutEffect when using jsdom).\nconst canUseLayoutEffect = (canUseDOM || isReactNative) && !usingJSDOM;\n// Adapted from https://www.npmjs.com/package/use-sync-external-store, with\n// Apollo Client deviations called out by \"// DEVIATION ...\" comments.\n// When/if React.useSyncExternalStore is defined, delegate fully to it.\nexport const useSyncExternalStore = realHook || ((subscribe, getSnapshot, getServerSnapshot) => {\n  // Read the current snapshot from the store on every render. Again, this\n  // breaks the rules of React, and only works here because of specific\n  // implementation details, most importantly that updates are\n  // always synchronous.\n  const value = getSnapshot();\n  if (\n  // DEVIATION: Using __DEV__\n  __DEV__ && !didWarnUncachedGetSnapshot &&\n  // DEVIATION: Not using Object.is because we know our snapshots will never\n  // be exotic primitive values like NaN, which is !== itself.\n  value !== getSnapshot()) {\n    didWarnUncachedGetSnapshot = true;\n    // DEVIATION: Using invariant.error instead of console.error directly.\n    invariant.error(34);\n  }\n  // Because updates are synchronous, we don't queue them. Instead we force a\n  // re-render whenever the subscribed state changes by updating an some\n  // arbitrary useState hook. Then, during render, we call getSnapshot to read\n  // the current value.\n  //\n  // Because we don't actually use the state returned by the useState hook, we\n  // can save a bit of memory by storing other stuff in that slot.\n  //\n  // To implement the early bailout, we need to track some things on a mutable\n  // object. Usually, we would put that in a useRef hook, but we can stash it in\n  // our useState hook instead.\n  //\n  // To force a re-render, we call forceUpdate({inst}). That works because the\n  // new object always fails an equality check.\n  const [{\n    inst\n  }, forceUpdate] = React.useState({\n    inst: {\n      value,\n      getSnapshot\n    }\n  });\n  // Track the latest getSnapshot function with a ref. This needs to be updated\n  // in the layout phase so we can access it during the tearing check that\n  // happens on subscribe.\n  if (canUseLayoutEffect) {\n    // DEVIATION: We avoid calling useLayoutEffect when !canUseLayoutEffect,\n    // which may seem like a conditional hook, but this code ends up behaving\n    // unconditionally (one way or the other) because canUseLayoutEffect is\n    // constant.\n    React.useLayoutEffect(() => {\n      Object.assign(inst, {\n        value,\n        getSnapshot\n      });\n      // Whenever getSnapshot or subscribe changes, we need to check in the\n      // commit phase if there was an interleaved mutation. In concurrent mode\n      // this can happen all the time, but even in synchronous mode, an earlier\n      // effect may have mutated the store.\n      if (checkIfSnapshotChanged(inst)) {\n        // Force a re-render.\n        forceUpdate({\n          inst\n        });\n      }\n      // React Hook React.useLayoutEffect has a missing dependency: 'inst'. Either include it or remove the dependency array.\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [subscribe, value, getSnapshot]);\n  } else {\n    Object.assign(inst, {\n      value,\n      getSnapshot\n    });\n  }\n  React.useEffect(() => {\n    // Check for changes right before subscribing. Subsequent changes will be\n    // detected in the subscription handler.\n    if (checkIfSnapshotChanged(inst)) {\n      // Force a re-render.\n      forceUpdate({\n        inst\n      });\n    }\n    // Subscribe to the store and return a clean-up function.\n    return subscribe(function handleStoreChange() {\n      // TODO: Because there is no cross-renderer API for batching updates, it's\n      // up to the consumer of this library to wrap their subscription event\n      // with unstable_batchedUpdates. Should we try to detect when this isn't\n      // the case and print a warning in development?\n      // The store changed. Check if the snapshot changed since the last time we\n      // read from the store.\n      if (checkIfSnapshotChanged(inst)) {\n        // Force a re-render.\n        forceUpdate({\n          inst\n        });\n      }\n    });\n    // React Hook React.useEffect has a missing dependency: 'inst'. Either include it or remove the dependency array.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [subscribe]);\n  return value;\n});\nfunction checkIfSnapshotChanged({\n  value,\n  getSnapshot\n}) {\n  try {\n    return value !== getSnapshot();\n  } catch {\n    return true;\n  }\n}","map":{"version":3,"names":["React","__DEV__","canUseDOM","maybe","invariant","didWarnUncachedGetSnapshot","uSESKey","realHook","isReactNative","navigator","product","usingJSDOM","userAgent","indexOf","canUseLayoutEffect","useSyncExternalStore","subscribe","getSnapshot","getServerSnapshot","value","error","inst","forceUpdate","useState","useLayoutEffect","Object","assign","checkIfSnapshotChanged","useEffect","handleStoreChange"],"sources":["/home/saurabh-shukla/Desktop/Slack Lite/frontend/node_modules/@apollo/src/react/hooks/useSyncExternalStore.ts"],"sourcesContent":["import * as React from \"react\";\n\nimport { __DEV__ } from \"@apollo/client/utilities/environment\";\nimport { canUseDOM } from \"@apollo/client/utilities/internal\";\nimport { maybe } from \"@apollo/client/utilities/internal/globals\";\nimport { invariant } from \"@apollo/client/utilities/invariant\";\n\nlet didWarnUncachedGetSnapshot = false;\n\ntype RealUseSESHookType =\n  // This import depends only on the @types/use-sync-external-store package, not\n  // the actual use-sync-external-store package, which is not installed. It\n  // might be nice to get this type from React 18, but it still needs to work\n  // when only React 17 or earlier is installed.\n  typeof import(\"use-sync-external-store\").useSyncExternalStore;\n\n// Prevent webpack from complaining about our feature detection of the\n// useSyncExternalStore property of the React namespace, which is expected not\n// to exist when using React 17 and earlier, and that's fine.\nconst uSESKey = \"useSyncExternalStore\" as keyof typeof React;\nconst realHook = React[uSESKey] as RealUseSESHookType | undefined;\n\nconst isReactNative = maybe(() => navigator.product) == \"ReactNative\";\nconst usingJSDOM: boolean =\n  // Following advice found in this comment from @domenic (maintainer of jsdom):\n  // https://github.com/jsdom/jsdom/issues/1537#issuecomment-229405327\n  //\n  // Since we control the version of Jest and jsdom used when running Apollo\n  // Client tests, and that version is recent enought to include \" jsdom/x.y.z\"\n  // at the end of the user agent string, I believe this case is all we need to\n  // check. Testing for \"Node.js\" was recommended for backwards compatibility\n  // with older version of jsdom, but we don't have that problem.\n  maybe(() => navigator.userAgent.indexOf(\"jsdom\") >= 0) || false;\n\n// Our tests should all continue to pass if we remove this !usingJSDOM\n// condition, thereby allowing useLayoutEffect when using jsdom. Unfortunately,\n// if we allow useLayoutEffect, then useSyncExternalStore generates many\n// warnings about useLayoutEffect doing nothing on the server. While these\n// warnings are harmless, this !usingJSDOM condition seems to be the best way to\n// prevent them (i.e. skipping useLayoutEffect when using jsdom).\nconst canUseLayoutEffect = (canUseDOM || isReactNative) && !usingJSDOM;\n\n// Adapted from https://www.npmjs.com/package/use-sync-external-store, with\n// Apollo Client deviations called out by \"// DEVIATION ...\" comments.\n\n// When/if React.useSyncExternalStore is defined, delegate fully to it.\nexport const useSyncExternalStore: RealUseSESHookType =\n  realHook ||\n  ((subscribe, getSnapshot, getServerSnapshot) => {\n    // Read the current snapshot from the store on every render. Again, this\n    // breaks the rules of React, and only works here because of specific\n    // implementation details, most importantly that updates are\n    // always synchronous.\n    const value = getSnapshot();\n    if (\n      // DEVIATION: Using __DEV__\n      __DEV__ &&\n      !didWarnUncachedGetSnapshot &&\n      // DEVIATION: Not using Object.is because we know our snapshots will never\n      // be exotic primitive values like NaN, which is !== itself.\n      value !== getSnapshot()\n    ) {\n      didWarnUncachedGetSnapshot = true;\n      // DEVIATION: Using invariant.error instead of console.error directly.\n      invariant.error(\n        \"The result of getSnapshot should be cached to avoid an infinite loop\"\n      );\n    }\n\n    // Because updates are synchronous, we don't queue them. Instead we force a\n    // re-render whenever the subscribed state changes by updating an some\n    // arbitrary useState hook. Then, during render, we call getSnapshot to read\n    // the current value.\n    //\n    // Because we don't actually use the state returned by the useState hook, we\n    // can save a bit of memory by storing other stuff in that slot.\n    //\n    // To implement the early bailout, we need to track some things on a mutable\n    // object. Usually, we would put that in a useRef hook, but we can stash it in\n    // our useState hook instead.\n    //\n    // To force a re-render, we call forceUpdate({inst}). That works because the\n    // new object always fails an equality check.\n    const [{ inst }, forceUpdate] = React.useState({\n      inst: { value, getSnapshot },\n    });\n\n    // Track the latest getSnapshot function with a ref. This needs to be updated\n    // in the layout phase so we can access it during the tearing check that\n    // happens on subscribe.\n    if (canUseLayoutEffect) {\n      // DEVIATION: We avoid calling useLayoutEffect when !canUseLayoutEffect,\n      // which may seem like a conditional hook, but this code ends up behaving\n      // unconditionally (one way or the other) because canUseLayoutEffect is\n      // constant.\n      React.useLayoutEffect(() => {\n        Object.assign(inst, { value, getSnapshot });\n        // Whenever getSnapshot or subscribe changes, we need to check in the\n        // commit phase if there was an interleaved mutation. In concurrent mode\n        // this can happen all the time, but even in synchronous mode, an earlier\n        // effect may have mutated the store.\n        if (checkIfSnapshotChanged(inst)) {\n          // Force a re-render.\n          forceUpdate({ inst });\n        }\n        // React Hook React.useLayoutEffect has a missing dependency: 'inst'. Either include it or remove the dependency array.\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n      }, [subscribe, value, getSnapshot]);\n    } else {\n      Object.assign(inst, { value, getSnapshot });\n    }\n\n    React.useEffect(() => {\n      // Check for changes right before subscribing. Subsequent changes will be\n      // detected in the subscription handler.\n      if (checkIfSnapshotChanged(inst)) {\n        // Force a re-render.\n        forceUpdate({ inst });\n      }\n\n      // Subscribe to the store and return a clean-up function.\n      return subscribe(function handleStoreChange() {\n        // TODO: Because there is no cross-renderer API for batching updates, it's\n        // up to the consumer of this library to wrap their subscription event\n        // with unstable_batchedUpdates. Should we try to detect when this isn't\n        // the case and print a warning in development?\n\n        // The store changed. Check if the snapshot changed since the last time we\n        // read from the store.\n        if (checkIfSnapshotChanged(inst)) {\n          // Force a re-render.\n          forceUpdate({ inst });\n        }\n      });\n      // React Hook React.useEffect has a missing dependency: 'inst'. Either include it or remove the dependency array.\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [subscribe]);\n\n    return value;\n  });\n\nfunction checkIfSnapshotChanged<Snapshot>({\n  value,\n  getSnapshot,\n}: {\n  value: Snapshot;\n  getSnapshot: () => Snapshot;\n}): boolean {\n  try {\n    return value !== getSnapshot();\n  } catch {\n    return true;\n  }\n}\n"],"mappings":"AAAA,OAAO,KAAKA,KAAZ,MAAuB,OAAO;AAE9B,SAASC,OAAT,QAAwB,sCAAsC;AAC9D,SAASC,SAAT,QAA0B,mCAAmC;AAC7D,SAASC,KAAT,QAAsB,2CAA2C;AACjE,SAASC,SAAT,QAA0B,oCAAoC;AAE9D,IAAIC,0BAAJ,GAAiC,KAAK;AAStC;AACA;AACA;AACA,MAAMC,OAAN,GAAgB,sBAA4C;AAC5D,MAAMC,QAAN,GAAiBP,KAAK,CAACM,OAAO,CAAmC;AAEjE,MAAME,aAAN,GAAsBL,KAAK,CAAC,MAAMM,SAAS,CAACC,OAAO,KAAK,aAAa;AACrE,MAAMC,UAAN;AACE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAR,KAAK,CAAC,MAAMM,SAAS,CAACG,SAAS,CAACC,OAAO,CAAC,OAAO,KAAK,CAAC,KAAK,KAAK;AAEjE;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,kBAAN,GAA2B,CAACZ,SAA5B,IAAyCM,aAAa,KAAK,CAACG,UAAU;AAEtE;AACA;AAEA;AACA,OAAO,MAAMI,oBAAb,GACER,QADF,KAEG,CAACS,SAAS,EAAEC,WAAW,EAAEC,iBAAiB,KAA7C;EACI;EACA;EACA;EACA;EACA,MAAMC,KAAV,GAAkBF,WAAW,CAA7B,CAA+B;EAC3B;EACE;EACAhB,OAAN,IACM,CAACI,0BAAP;EACM;EACA;EACAc,KAAN,KAAgBF,WAAW,CAA3B,CAA6B,EACvB;IACAZ,0BAAN,GAAmC,IAAI;IACjC;IACAD,SAAS,CAACgB,KAAhB,IAEO;EACH;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA,MAAM,CAAC;IAAEC;EAAb,CAAmB,EAAEC,WAAW,IAAItB,KAAK,CAACuB,QAAQ,CAAC;IAC7CF,IAAI,EAAE;MAAEF,KAAK;MAAEF;IAArB;EACA,CAAK,CAAC;EAEF;EACA;EACA;EACA,IAAIH,kBAAkB,EAAE;IACtB;IACA;IACA;IACA;IACAd,KAAK,CAACwB,eAAe,CAAC,MAA5B;MACQC,MAAM,CAACC,MAAM,CAACL,IAAI,EAAE;QAAEF,KAAK;QAAEF;MAArC,CAAkD,CAAC;MAC3C;MACA;MACA;MACA;MACA,IAAIU,sBAAsB,CAACN,IAAI,CAAC,EAAE;QAChC;QACAC,WAAW,CAAC;UAAED;QAAxB,CAA8B,CAAC;MACvB;MACA;MACA;IACF,CAAC,EAAE,CAACL,SAAS,EAAEG,KAAK,EAAEF,WAAW,CAAC,CAAC;EACrC,OAAO;IACLQ,MAAM,CAACC,MAAM,CAACL,IAAI,EAAE;MAAEF,KAAK;MAAEF;IAAnC,CAAgD,CAAC;EAC7C;EAEAjB,KAAK,CAAC4B,SAAS,CAAC,MAApB;IACM;IACA;IACA,IAAID,sBAAsB,CAACN,IAAI,CAAC,EAAE;MAChC;MACAC,WAAW,CAAC;QAAED;MAAtB,CAA4B,CAAC;IACvB;IAEA;IACA,OAAOL,SAAS,CAAC,SAASa,iBAAiBA,CAAA,EAAjD;MACQ;MACA;MACA;MACA;MAEA;MACA;MACA,IAAIF,sBAAsB,CAACN,IAAI,CAAC,EAAE;QAChC;QACAC,WAAW,CAAC;UAAED;QAAxB,CAA8B,CAAC;MACvB;IACF,CAAC,CAAC;IACF;IACA;EACF,CAAC,EAAE,CAACL,SAAS,CAAC,CAAC;EAEf,OAAOG,KAAK;AACd,CAAC,CAAC;AAEJ,SAASQ,sBAAsBA,CAAW;EACxCR,KAAK;EACLF;AAFF,CAMC,EAND;EAOE,IAAI;IACF,OAAOE,KAAX,KAAqBF,WAAW,CAAhC,CAAkC;EAChC,EAAE,MAAM;IACN,OAAO,IAAI;EACb;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}