{"ast":null,"code":"import * as React from \"react\";\nimport { assertWrappedQueryRef, getWrappedPromise, unwrapQueryRef, updateWrappedQueryRef, wrapQueryRef } from \"@apollo/client/react/internal\";\nimport { wrapHook } from \"./internal/index.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\n/**\n * A React hook that returns a `refetch` and `fetchMore` function for a given\n * `queryRef`.\n *\n * This is useful to get access to handlers for a `queryRef` that was created by\n * `createQueryPreloader` or when the handlers for a `queryRef` produced in\n * a different component are inaccessible.\n *\n * @example\n *\n * ```tsx\n * const MyComponent({ queryRef }) {\n *   const { refetch, fetchMore } = useQueryRefHandlers(queryRef);\n *\n *   // ...\n * }\n * ```\n *\n * @param queryRef - A `QueryRef` returned from `useBackgroundQuery`, `useLoadableQuery`, or `createQueryPreloader`.\n */\nexport function useQueryRefHandlers(queryRef) {\n  \"use no memo\";\n\n  const unwrapped = unwrapQueryRef(queryRef);\n  const clientOrObsQuery = useApolloClient(unwrapped ?\n  // passing an `ObservableQuery` is not supported by the types, but it will\n  // return any truthy value that is passed in as an override so we cast the result\n  unwrapped[\"observable\"] : undefined);\n  return wrapHook(\"useQueryRefHandlers\",\n  // eslint-disable-next-line react-compiler/react-compiler\n  useQueryRefHandlers_, clientOrObsQuery)(queryRef);\n}\nfunction useQueryRefHandlers_(queryRef) {\n  assertWrappedQueryRef(queryRef);\n  const [previousQueryRef, setPreviousQueryRef] = React.useState(queryRef);\n  const [wrappedQueryRef, setWrappedQueryRef] = React.useState(queryRef);\n  const internalQueryRef = unwrapQueryRef(queryRef);\n  // To ensure we can support React transitions, this hook needs to manage the\n  // queryRef state and apply React's state value immediately to the existing\n  // queryRef since this hook doesn't return the queryRef directly\n  if (previousQueryRef !== queryRef) {\n    setPreviousQueryRef(queryRef);\n    setWrappedQueryRef(queryRef);\n  } else {\n    updateWrappedQueryRef(queryRef, getWrappedPromise(wrappedQueryRef));\n  }\n  const refetch = React.useCallback(variables => {\n    const promise = internalQueryRef.refetch(variables);\n    setWrappedQueryRef(wrapQueryRef(internalQueryRef));\n    return promise;\n  }, [internalQueryRef]);\n  const fetchMore = React.useCallback(options => {\n    const promise = internalQueryRef.fetchMore(options);\n    setWrappedQueryRef(wrapQueryRef(internalQueryRef));\n    return promise;\n  }, [internalQueryRef]);\n  return {\n    refetch,\n    fetchMore,\n    // TODO: The internalQueryRef doesn't have TVariables' type information so we have to cast it here\n    subscribeToMore: internalQueryRef.observable.subscribeToMore\n  };\n}","map":{"version":3,"names":["React","assertWrappedQueryRef","getWrappedPromise","unwrapQueryRef","updateWrappedQueryRef","wrapQueryRef","wrapHook","useApolloClient","useQueryRefHandlers","queryRef","unwrapped","clientOrObsQuery","undefined","useQueryRefHandlers_","previousQueryRef","setPreviousQueryRef","useState","wrappedQueryRef","setWrappedQueryRef","internalQueryRef","refetch","useCallback","variables","promise","fetchMore","options","subscribeToMore","observable"],"sources":["/home/saurabh-shukla/Desktop/Slack Lite/frontend/node_modules/@apollo/src/react/hooks/useQueryRefHandlers.ts"],"sourcesContent":["import * as React from \"react\";\n\nimport type { DataState, OperationVariables } from \"@apollo/client\";\nimport type { SubscribeToMoreFunction } from \"@apollo/client\";\nimport type { ApolloClient } from \"@apollo/client\";\nimport type { ObservableQuery } from \"@apollo/client\";\nimport type { QueryRef } from \"@apollo/client/react\";\nimport type {\n  FetchMoreFunction,\n  RefetchFunction,\n} from \"@apollo/client/react/internal\";\nimport {\n  assertWrappedQueryRef,\n  getWrappedPromise,\n  unwrapQueryRef,\n  updateWrappedQueryRef,\n  wrapQueryRef,\n} from \"@apollo/client/react/internal\";\n\nimport { wrapHook } from \"./internal/index.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\n\nexport declare namespace useQueryRefHandlers {\n  export interface Result<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  > {\n    /** {@inheritDoc @apollo/client!ObservableQuery#refetch:member(1)} */\n    refetch: RefetchFunction<TData, TVariables>;\n    /** {@inheritDoc @apollo/client!ObservableQuery#fetchMore:member(1)} */\n    fetchMore: FetchMoreFunction<TData, TVariables>;\n    /** {@inheritDoc @apollo/client!ObservableQuery#subscribeToMore:member(1)} */\n    subscribeToMore: SubscribeToMoreFunction<TData, TVariables>;\n  }\n\n  export namespace DocumentationTypes {\n    /** {@inheritDoc @apollo/client/react!useQueryRefHandlers:function(1)} */\n    export function useQueryRefHandlers<\n      TData = unknown,\n      TVariables extends OperationVariables = OperationVariables,\n    >(\n      queryRef: QueryRef<TData, TVariables>\n    ): useQueryRefHandlers.Result<TData, TVariables>;\n  }\n}\n\n/**\n * A React hook that returns a `refetch` and `fetchMore` function for a given\n * `queryRef`.\n *\n * This is useful to get access to handlers for a `queryRef` that was created by\n * `createQueryPreloader` or when the handlers for a `queryRef` produced in\n * a different component are inaccessible.\n *\n * @example\n *\n * ```tsx\n * const MyComponent({ queryRef }) {\n *   const { refetch, fetchMore } = useQueryRefHandlers(queryRef);\n *\n *   // ...\n * }\n * ```\n *\n * @param queryRef - A `QueryRef` returned from `useBackgroundQuery`, `useLoadableQuery`, or `createQueryPreloader`.\n */\nexport function useQueryRefHandlers<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  queryRef: QueryRef<TData, TVariables, DataState<TData>[\"dataState\"]>\n): useQueryRefHandlers.Result<TData, TVariables> {\n  \"use no memo\";\n  const unwrapped = unwrapQueryRef(queryRef);\n  const clientOrObsQuery = useApolloClient(\n    unwrapped ?\n      // passing an `ObservableQuery` is not supported by the types, but it will\n      // return any truthy value that is passed in as an override so we cast the result\n      (unwrapped[\"observable\"] as any)\n    : undefined\n  ) as ApolloClient | ObservableQuery<TData>;\n\n  return wrapHook(\n    \"useQueryRefHandlers\",\n    // eslint-disable-next-line react-compiler/react-compiler\n    useQueryRefHandlers_,\n    clientOrObsQuery\n  )(queryRef);\n}\n\nfunction useQueryRefHandlers_<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  queryRef: QueryRef<TData, TVariables, DataState<TData>[\"dataState\"]>\n): useQueryRefHandlers.Result<TData, TVariables> {\n  assertWrappedQueryRef(queryRef);\n  const [previousQueryRef, setPreviousQueryRef] = React.useState(queryRef);\n  const [wrappedQueryRef, setWrappedQueryRef] = React.useState(queryRef);\n  const internalQueryRef = unwrapQueryRef(queryRef);\n\n  // To ensure we can support React transitions, this hook needs to manage the\n  // queryRef state and apply React's state value immediately to the existing\n  // queryRef since this hook doesn't return the queryRef directly\n  if (previousQueryRef !== queryRef) {\n    setPreviousQueryRef(queryRef);\n    setWrappedQueryRef(queryRef);\n  } else {\n    updateWrappedQueryRef(queryRef, getWrappedPromise(wrappedQueryRef));\n  }\n\n  const refetch: RefetchFunction<TData, TVariables> = React.useCallback(\n    (variables) => {\n      const promise = internalQueryRef.refetch(variables);\n\n      setWrappedQueryRef(wrapQueryRef(internalQueryRef));\n\n      return promise;\n    },\n    [internalQueryRef]\n  );\n\n  const fetchMore: FetchMoreFunction<TData, TVariables> = React.useCallback(\n    (options) => {\n      const promise = internalQueryRef.fetchMore(\n        options as ObservableQuery.FetchMoreOptions<any, any>\n      );\n\n      setWrappedQueryRef(wrapQueryRef(internalQueryRef));\n\n      return promise;\n    },\n    [internalQueryRef]\n  );\n\n  return {\n    refetch,\n    fetchMore,\n    // TODO: The internalQueryRef doesn't have TVariables' type information so we have to cast it here\n    subscribeToMore: internalQueryRef.observable\n      .subscribeToMore as SubscribeToMoreFunction<TData, TVariables>,\n  };\n}\n"],"mappings":"AAAA,OAAO,KAAKA,KAAK,MAAM,OAAO;AAW9B,SACEC,qBAAqB,EACrBC,iBAAiB,EACjBC,cAAc,EACdC,qBAAqB,EACrBC,YAAY,QACP,+BAA+B;AAEtC,SAASC,QAAQ,QAAQ,qBAAqB;AAC9C,SAASC,eAAe,QAAQ,sBAAsB;AA0BtD;;;;;;;;;;;;;;;;;;;;AAoBA,OAAM,SAAUC,mBAAmBA,CAIjCC,QAAoE;EAEpE,aAAa;;EACb,MAAMC,SAAS,GAAGP,cAAc,CAACM,QAAQ,CAAC;EAC1C,MAAME,gBAAgB,GAAGJ,eAAe,CACtCG,SAAS;EACP;EACA;EACCA,SAAS,CAAC,YAAY,CAAS,GAChCE,SAAS,CAC6B;EAE1C,OAAON,QAAQ,CACb,qBAAqB;EACrB;EACAO,oBAAoB,EACpBF,gBAAgB,CACjB,CAACF,QAAQ,CAAC;AACb;AAEA,SAASI,oBAAoBA,CAI3BJ,QAAoE;EAEpER,qBAAqB,CAACQ,QAAQ,CAAC;EAC/B,MAAM,CAACK,gBAAgB,EAAEC,mBAAmB,CAAC,GAAGf,KAAK,CAACgB,QAAQ,CAACP,QAAQ,CAAC;EACxE,MAAM,CAACQ,eAAe,EAAEC,kBAAkB,CAAC,GAAGlB,KAAK,CAACgB,QAAQ,CAACP,QAAQ,CAAC;EACtE,MAAMU,gBAAgB,GAAGhB,cAAc,CAACM,QAAQ,CAAC;EAEjD;EACA;EACA;EACA,IAAIK,gBAAgB,KAAKL,QAAQ,EAAE;IACjCM,mBAAmB,CAACN,QAAQ,CAAC;IAC7BS,kBAAkB,CAACT,QAAQ,CAAC;EAC9B,CAAC,MAAM;IACLL,qBAAqB,CAACK,QAAQ,EAAEP,iBAAiB,CAACe,eAAe,CAAC,CAAC;EACrE;EAEA,MAAMG,OAAO,GAAuCpB,KAAK,CAACqB,WAAW,CAClEC,SAAS,IAAI;IACZ,MAAMC,OAAO,GAAGJ,gBAAgB,CAACC,OAAO,CAACE,SAAS,CAAC;IAEnDJ,kBAAkB,CAACb,YAAY,CAACc,gBAAgB,CAAC,CAAC;IAElD,OAAOI,OAAO;EAChB,CAAC,EACD,CAACJ,gBAAgB,CAAC,CACnB;EAED,MAAMK,SAAS,GAAyCxB,KAAK,CAACqB,WAAW,CACtEI,OAAO,IAAI;IACV,MAAMF,OAAO,GAAGJ,gBAAgB,CAACK,SAAS,CACxCC,OAAqD,CACtD;IAEDP,kBAAkB,CAACb,YAAY,CAACc,gBAAgB,CAAC,CAAC;IAElD,OAAOI,OAAO;EAChB,CAAC,EACD,CAACJ,gBAAgB,CAAC,CACnB;EAED,OAAO;IACLC,OAAO;IACPI,SAAS;IACT;IACAE,eAAe,EAAEP,gBAAgB,CAACQ,UAAU,CACzCD;GACJ;AACH","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}