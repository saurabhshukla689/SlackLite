{"ast":null,"code":"import { __DEV__ } from \"@apollo/client/utilities/environment\";\nimport { cacheSizes } from \"../caching/sizes.js\";\nimport { AutoCleanedStrongCache } from \"./caches.js\";\nimport { registerGlobalCache } from \"./getMemoryInternals.js\";\n/**\n * Serializes a value to JSON with object keys in a consistent, sorted order.\n *\n * @remarks\n *\n * Unlike `JSON.stringify()`, this function ensures that object keys are always\n * serialized in the same alphabetical order, regardless of their original order.\n * This makes it suitable for creating consistent cache keys from objects,\n * comparing objects by their serialized representation, or generating\n * deterministic hashes of objects.\n *\n * To achieve performant sorting, this function uses a `Map` from JSON-serialized\n * arrays of keys (in any order) to sorted arrays of the same keys, with a\n * single sorted array reference shared by all permutations of the keys.\n *\n * As a drawback, this function will add a little more memory for every object\n * encountered that has different (more, less, a different order of) keys than\n * in the past.\n *\n * In a typical application, this extra memory usage should not play a\n * significant role, as `canonicalStringify` will be called for only a limited\n * number of object shapes, and the cache will not grow beyond a certain point.\n * But in some edge cases, this could be a problem. Use canonicalStringify.reset()\n * as a way to clear the memoization cache.\n *\n * @param value - The value to stringify\n * @returns JSON string with consistently ordered object keys\n *\n * @example\n *\n * ```ts\n * import { canonicalStringify } from \"@apollo/client/utilities\";\n *\n * const obj1 = { b: 2, a: 1 };\n * const obj2 = { a: 1, b: 2 };\n *\n * console.log(canonicalStringify(obj1)); // '{\"a\":1,\"b\":2}'\n * console.log(canonicalStringify(obj2)); // '{\"a\":1,\"b\":2}'\n * ```\n */\nexport const canonicalStringify = Object.assign(function canonicalStringify(value) {\n  return JSON.stringify(value, stableObjectReplacer);\n}, {\n  reset() {\n    // Clearing the sortingMap will reclaim all cached memory, without\n    // affecting the logical results of canonicalStringify, but potentially\n    // sacrificing performance until the cache is refilled.\n    sortingMap = new AutoCleanedStrongCache(cacheSizes.canonicalStringify || 1000 /* defaultCacheSizes.canonicalStringify */);\n  }\n});\nif (__DEV__) {\n  registerGlobalCache(\"canonicalStringify\", () => sortingMap.size);\n}\n// Values are JSON-serialized arrays of object keys (in any order), and values\n// are sorted arrays of the same keys.\nlet sortingMap;\ncanonicalStringify.reset();\n// The JSON.stringify function takes an optional second argument called a\n// replacer function. This function is called for each key-value pair in the\n// object being stringified, and its return value is used instead of the\n// original value. If the replacer function returns a new value, that value is\n// stringified as JSON instead of the original value of the property.\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#the_replacer_parameter\nfunction stableObjectReplacer(key, value) {\n  if (value && typeof value === \"object\") {\n    const proto = Object.getPrototypeOf(value);\n    // We don't want to mess with objects that are not \"plain\" objects, which\n    // means their prototype is either Object.prototype or null. This check also\n    // prevents needlessly rearranging the indices of arrays.\n    if (proto === Object.prototype || proto === null) {\n      const keys = Object.keys(value);\n      // If keys is already sorted, let JSON.stringify serialize the original\n      // value instead of creating a new object with keys in the same order.\n      if (keys.every(everyKeyInOrder)) return value;\n      const unsortedKey = JSON.stringify(keys);\n      let sortedKeys = sortingMap.get(unsortedKey);\n      if (!sortedKeys) {\n        keys.sort();\n        const sortedKey = JSON.stringify(keys);\n        // Checking for sortedKey in the sortingMap allows us to share the same\n        // sorted array reference for all permutations of the same set of keys.\n        sortedKeys = sortingMap.get(sortedKey) || keys;\n        sortingMap.set(unsortedKey, sortedKeys);\n        sortingMap.set(sortedKey, sortedKeys);\n      }\n      const sortedObject = Object.create(proto);\n      // Reassigning the keys in sorted order will cause JSON.stringify to\n      // serialize them in sorted order.\n      sortedKeys.forEach(key => {\n        sortedObject[key] = value[key];\n      });\n      return sortedObject;\n    }\n  }\n  return value;\n}\n// Since everything that happens in stableObjectReplacer benefits from being as\n// efficient as possible, we use a static function as the callback for\n// keys.every in order to test if the provided keys are already sorted without\n// allocating extra memory for a callback.\nfunction everyKeyInOrder(key, i, keys) {\n  return i === 0 || keys[i - 1] <= key;\n}","map":{"version":3,"names":["__DEV__","cacheSizes","AutoCleanedStrongCache","registerGlobalCache","canonicalStringify","Object","assign","value","JSON","stringify","stableObjectReplacer","reset","sortingMap","size","key","proto","getPrototypeOf","prototype","keys","every","everyKeyInOrder","unsortedKey","sortedKeys","get","sort","sortedKey","set","sortedObject","create","forEach","i"],"sources":["/home/saurabh-shukla/Desktop/Slack Lite/frontend/node_modules/@apollo/src/utilities/internal/canonicalStringify.ts"],"sourcesContent":["import { __DEV__ } from \"@apollo/client/utilities/environment\";\n\nimport { cacheSizes, defaultCacheSizes } from \"../caching/sizes.js\";\n\nimport { AutoCleanedStrongCache } from \"./caches.js\";\nimport { registerGlobalCache } from \"./getMemoryInternals.js\";\n\n/**\n * Serializes a value to JSON with object keys in a consistent, sorted order.\n *\n * @remarks\n *\n * Unlike `JSON.stringify()`, this function ensures that object keys are always\n * serialized in the same alphabetical order, regardless of their original order.\n * This makes it suitable for creating consistent cache keys from objects,\n * comparing objects by their serialized representation, or generating\n * deterministic hashes of objects.\n *\n * To achieve performant sorting, this function uses a `Map` from JSON-serialized\n * arrays of keys (in any order) to sorted arrays of the same keys, with a\n * single sorted array reference shared by all permutations of the keys.\n *\n * As a drawback, this function will add a little more memory for every object\n * encountered that has different (more, less, a different order of) keys than\n * in the past.\n *\n * In a typical application, this extra memory usage should not play a\n * significant role, as `canonicalStringify` will be called for only a limited\n * number of object shapes, and the cache will not grow beyond a certain point.\n * But in some edge cases, this could be a problem. Use canonicalStringify.reset()\n * as a way to clear the memoization cache.\n *\n * @param value - The value to stringify\n * @returns JSON string with consistently ordered object keys\n *\n * @example\n *\n * ```ts\n * import { canonicalStringify } from \"@apollo/client/utilities\";\n *\n * const obj1 = { b: 2, a: 1 };\n * const obj2 = { a: 1, b: 2 };\n *\n * console.log(canonicalStringify(obj1)); // '{\"a\":1,\"b\":2}'\n * console.log(canonicalStringify(obj2)); // '{\"a\":1,\"b\":2}'\n * ```\n */\nexport const canonicalStringify = Object.assign(\n  function canonicalStringify(value: any): string {\n    return JSON.stringify(value, stableObjectReplacer);\n  },\n  {\n    reset() {\n      // Clearing the sortingMap will reclaim all cached memory, without\n      // affecting the logical results of canonicalStringify, but potentially\n      // sacrificing performance until the cache is refilled.\n      sortingMap = new AutoCleanedStrongCache<string, readonly string[]>(\n        cacheSizes.canonicalStringify || defaultCacheSizes.canonicalStringify\n      );\n    },\n  }\n);\n\nif (__DEV__) {\n  registerGlobalCache(\"canonicalStringify\", () => sortingMap.size);\n}\n\n// Values are JSON-serialized arrays of object keys (in any order), and values\n// are sorted arrays of the same keys.\nlet sortingMap!: AutoCleanedStrongCache<string, readonly string[]>;\ncanonicalStringify.reset();\n\n// The JSON.stringify function takes an optional second argument called a\n// replacer function. This function is called for each key-value pair in the\n// object being stringified, and its return value is used instead of the\n// original value. If the replacer function returns a new value, that value is\n// stringified as JSON instead of the original value of the property.\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#the_replacer_parameter\nfunction stableObjectReplacer(key: string, value: any) {\n  if (value && typeof value === \"object\") {\n    const proto = Object.getPrototypeOf(value);\n    // We don't want to mess with objects that are not \"plain\" objects, which\n    // means their prototype is either Object.prototype or null. This check also\n    // prevents needlessly rearranging the indices of arrays.\n    if (proto === Object.prototype || proto === null) {\n      const keys = Object.keys(value);\n      // If keys is already sorted, let JSON.stringify serialize the original\n      // value instead of creating a new object with keys in the same order.\n      if (keys.every(everyKeyInOrder)) return value;\n      const unsortedKey = JSON.stringify(keys);\n      let sortedKeys = sortingMap.get(unsortedKey);\n      if (!sortedKeys) {\n        keys.sort();\n        const sortedKey = JSON.stringify(keys);\n        // Checking for sortedKey in the sortingMap allows us to share the same\n        // sorted array reference for all permutations of the same set of keys.\n        sortedKeys = sortingMap.get(sortedKey) || keys;\n        sortingMap.set(unsortedKey, sortedKeys);\n        sortingMap.set(sortedKey, sortedKeys);\n      }\n      const sortedObject = Object.create(proto);\n      // Reassigning the keys in sorted order will cause JSON.stringify to\n      // serialize them in sorted order.\n      sortedKeys.forEach((key) => {\n        sortedObject[key] = value[key];\n      });\n      return sortedObject;\n    }\n  }\n  return value;\n}\n\n// Since everything that happens in stableObjectReplacer benefits from being as\n// efficient as possible, we use a static function as the callback for\n// keys.every in order to test if the provided keys are already sorted without\n// allocating extra memory for a callback.\nfunction everyKeyInOrder(\n  key: string,\n  i: number,\n  keys: readonly string[]\n): boolean {\n  return i === 0 || keys[i - 1] <= key;\n}\n"],"mappings":"AAAA,SAASA,OAAO,QAAQ,sCAAsC;AAE9D,SAASC,UAAU,QAA2B,qBAAqB;AAEnE,SAASC,sBAAsB,QAAQ,aAAa;AACpD,SAASC,mBAAmB,QAAQ,yBAAyB;AAE7D;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAwCA,OAAO,MAAMC,kBAAkB,GAAGC,MAAM,CAACC,MAAM,CAC7C,SAASF,kBAAkBA,CAACG,KAAU;EACpC,OAAOC,IAAI,CAACC,SAAS,CAACF,KAAK,EAAEG,oBAAoB,CAAC;AACpD,CAAC,EACD;EACEC,KAAKA,CAAA;IACH;IACA;IACA;IACAC,UAAU,GAAG,IAAIV,sBAAsB,CACrCD,UAAU,CAACG,kBAAkB,mDAAwC,CACtE;EACH;CACD,CACF;AAED,IAAIJ,OAAO,EAAE;EACXG,mBAAmB,CAAC,oBAAoB,EAAE,MAAMS,UAAU,CAACC,IAAI,CAAC;AAClE;AAEA;AACA;AACA,IAAID,UAA8D;AAClER,kBAAkB,CAACO,KAAK,EAAE;AAE1B;AACA;AACA;AACA;AACA;AACA;AACA,SAASD,oBAAoBA,CAACI,GAAW,EAAEP,KAAU;EACnD,IAAIA,KAAK,IAAI,OAAOA,KAAK,KAAK,QAAQ,EAAE;IACtC,MAAMQ,KAAK,GAAGV,MAAM,CAACW,cAAc,CAACT,KAAK,CAAC;IAC1C;IACA;IACA;IACA,IAAIQ,KAAK,KAAKV,MAAM,CAACY,SAAS,IAAIF,KAAK,KAAK,IAAI,EAAE;MAChD,MAAMG,IAAI,GAAGb,MAAM,CAACa,IAAI,CAACX,KAAK,CAAC;MAC/B;MACA;MACA,IAAIW,IAAI,CAACC,KAAK,CAACC,eAAe,CAAC,EAAE,OAAOb,KAAK;MAC7C,MAAMc,WAAW,GAAGb,IAAI,CAACC,SAAS,CAACS,IAAI,CAAC;MACxC,IAAII,UAAU,GAAGV,UAAU,CAACW,GAAG,CAACF,WAAW,CAAC;MAC5C,IAAI,CAACC,UAAU,EAAE;QACfJ,IAAI,CAACM,IAAI,EAAE;QACX,MAAMC,SAAS,GAAGjB,IAAI,CAACC,SAAS,CAACS,IAAI,CAAC;QACtC;QACA;QACAI,UAAU,GAAGV,UAAU,CAACW,GAAG,CAACE,SAAS,CAAC,IAAIP,IAAI;QAC9CN,UAAU,CAACc,GAAG,CAACL,WAAW,EAAEC,UAAU,CAAC;QACvCV,UAAU,CAACc,GAAG,CAACD,SAAS,EAAEH,UAAU,CAAC;MACvC;MACA,MAAMK,YAAY,GAAGtB,MAAM,CAACuB,MAAM,CAACb,KAAK,CAAC;MACzC;MACA;MACAO,UAAU,CAACO,OAAO,CAAEf,GAAG,IAAI;QACzBa,YAAY,CAACb,GAAG,CAAC,GAAGP,KAAK,CAACO,GAAG,CAAC;MAChC,CAAC,CAAC;MACF,OAAOa,YAAY;IACrB;EACF;EACA,OAAOpB,KAAK;AACd;AAEA;AACA;AACA;AACA;AACA,SAASa,eAAeA,CACtBN,GAAW,EACXgB,CAAS,EACTZ,IAAuB;EAEvB,OAAOY,CAAC,KAAK,CAAC,IAAIZ,IAAI,CAACY,CAAC,GAAG,CAAC,CAAC,IAAIhB,GAAG;AACtC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}