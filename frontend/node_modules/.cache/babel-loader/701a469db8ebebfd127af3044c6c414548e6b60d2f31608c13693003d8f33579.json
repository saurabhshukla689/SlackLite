{"ast":null,"code":"import { equal } from \"@wry/equality\";\nimport { BehaviorSubject, Observable, share, Subject, tap } from \"rxjs\";\nimport { isNetworkRequestInFlight } from \"@apollo/client/utilities\";\nimport { __DEV__ } from \"@apollo/client/utilities/environment\";\nimport { compact, equalByQuery, filterMap, getOperationDefinition, getOperationName, getQueryDefinition, preventUnhandledRejection, toQueryResult } from \"@apollo/client/utilities/internal\";\nimport { invariant } from \"@apollo/client/utilities/invariant\";\nimport { NetworkStatus } from \"./networkStatus.js\";\nconst {\n  assign,\n  hasOwnProperty\n} = Object;\nconst uninitialized = {\n  loading: true,\n  networkStatus: NetworkStatus.loading,\n  data: undefined,\n  dataState: \"empty\",\n  partial: true\n};\nconst empty = {\n  loading: false,\n  networkStatus: NetworkStatus.ready,\n  data: undefined,\n  dataState: \"empty\",\n  partial: true\n};\nexport class ObservableQuery {\n  options;\n  queryName;\n  /**\n  * @internal will be read and written from `QueryInfo`\n  * \n  * @deprecated This is an internal API and should not be used directly. This can be removed or changed at any time.\n  */\n  _lastWrite;\n  // The `query` computed property will always reflect the document transformed\n  // by the last run query. `this.options.query` will always reflect the raw\n  // untransformed query to ensure document transforms with runtime conditionals\n  // are run on the original document.\n  get query() {\n    return this.lastQuery;\n  }\n  /**\n   * An object containing the variables that were provided for the query.\n   */\n  get variables() {\n    return this.options.variables;\n  }\n  unsubscribeFromCache;\n  input;\n  subject;\n  isTornDown;\n  queryManager;\n  subscriptions = new Set();\n  /**\n   * If an `ObservableQuery` is created with a `network-only` fetch policy,\n   * it should actually start receiving cache updates, but not before it has\n   * received the first result from the network.\n   */\n  waitForNetworkResult;\n  lastQuery;\n  linkSubscription;\n  pollingInfo;\n  get networkStatus() {\n    return this.subject.getValue().result.networkStatus;\n  }\n  constructor({\n    queryManager,\n    options,\n    transformedQuery = queryManager.transform(options.query)\n  }) {\n    this.queryManager = queryManager;\n    // active state\n    this.waitForNetworkResult = options.fetchPolicy === \"network-only\";\n    this.isTornDown = false;\n    this.subscribeToMore = this.subscribeToMore.bind(this);\n    this.maskResult = this.maskResult.bind(this);\n    const {\n      watchQuery: {\n        fetchPolicy: defaultFetchPolicy = \"cache-first\"\n      } = {}\n    } = queryManager.defaultOptions;\n    const {\n      fetchPolicy = defaultFetchPolicy,\n      // Make sure we don't store \"standby\" as the initialFetchPolicy.\n      initialFetchPolicy = fetchPolicy === \"standby\" ? defaultFetchPolicy : fetchPolicy\n    } = options;\n    this.lastQuery = transformedQuery;\n    this.options = {\n      ...options,\n      // Remember the initial options.fetchPolicy so we can revert back to this\n      // policy when variables change. This information can also be specified\n      // (or overridden) by providing options.initialFetchPolicy explicitly.\n      initialFetchPolicy,\n      // This ensures this.options.fetchPolicy always has a string value, in\n      // case options.fetchPolicy was not provided.\n      fetchPolicy,\n      variables: this.getVariablesWithDefaults(options.variables)\n    };\n    this.initializeObservablesQueue();\n    this[\"@@observable\"] = () => this;\n    if (Symbol.observable) {\n      this[Symbol.observable] = () => this;\n    }\n    const opDef = getOperationDefinition(this.query);\n    this.queryName = opDef && opDef.name && opDef.name.value;\n  }\n  initializeObservablesQueue() {\n    this.subject = new BehaviorSubject({\n      query: this.query,\n      variables: this.variables,\n      result: uninitialized,\n      meta: {}\n    });\n    const observable = this.subject.pipe(tap({\n      subscribe: () => {\n        if (!this.subject.observed) {\n          this.reobserve();\n          // TODO: See if we can rework updatePolling to better handle this.\n          // reobserve calls updatePolling but this `subscribe` callback is\n          // called before the subject is subscribed to so `updatePolling`\n          // can't accurately detect if there is an active subscription.\n          // Calling it again here ensures that it can detect if it can poll\n          setTimeout(() => this.updatePolling());\n        }\n      },\n      unsubscribe: () => {\n        if (!this.subject.observed) {\n          this.tearDownQuery();\n        }\n      }\n    }), filterMap(({\n      query,\n      variables,\n      result: current,\n      meta\n    }, context) => {\n      const {\n        shouldEmit\n      } = meta;\n      if (current === uninitialized) {\n        // reset internal state after `ObservableQuery.reset()`\n        context.previous = undefined;\n        context.previousVariables = undefined;\n      }\n      if (this.options.fetchPolicy === \"standby\" || shouldEmit === 2 /* EmitBehavior.never */) return;\n      if (shouldEmit === 1 /* EmitBehavior.force */) return emit();\n      const {\n        previous,\n        previousVariables\n      } = context;\n      if (previous) {\n        const documentInfo = this.queryManager.getDocumentInfo(query);\n        const dataMasking = this.queryManager.dataMasking;\n        const maskedQuery = dataMasking ? documentInfo.nonReactiveQuery : query;\n        const resultIsEqual = dataMasking || documentInfo.hasNonreactiveDirective ? equalByQuery(maskedQuery, previous, current, variables) : equal(previous, current);\n        if (resultIsEqual && equal(previousVariables, variables)) {\n          return;\n        }\n      }\n      if (shouldEmit === 3 /* EmitBehavior.networkStatusChange */ && (!this.options.notifyOnNetworkStatusChange || equal(previous, current))) {\n        return;\n      }\n      return emit();\n      function emit() {\n        context.previous = current;\n        context.previousVariables = variables;\n        return current;\n      }\n    }, () => ({})));\n    this.pipe = observable.pipe.bind(observable);\n    this.subscribe = observable.subscribe.bind(observable);\n    this.input = new Subject();\n    // we want to feed many streams into `this.subject`, but none of them should\n    // be able to close `this.input`\n    this.input.complete = () => {};\n    this.input.pipe(this.operator).subscribe(this.subject);\n  }\n  // We can't use Observable['subscribe'] here as the type as it conflicts with\n  // the ability to infer T from Subscribable<T>. This limits the surface area\n  // to the non-deprecated signature which works properly with type inference.\n  /**\n   * Subscribes to the `ObservableQuery`.\n   * @param observerOrNext - Either an RxJS `Observer` with some or all callback methods,\n   * or the `next` handler that is called for each value emitted from the subscribed Observable.\n   * @returns A subscription reference to the registered handlers.\n   */\n  subscribe;\n  /**\n   * Used to stitch together functional operators into a chain.\n   *\n   * @example\n   *\n   * ```ts\n   * import { filter, map } from 'rxjs';\n   *\n   * observableQuery\n   *   .pipe(\n   *     filter(...),\n   *     map(...),\n   *   )\n   *   .subscribe(x => console.log(x));\n   * ```\n   *\n   * @returns The Observable result of all the operators having been called\n   * in the order they were passed in.\n   */\n  pipe;\n  [Symbol.observable];\n  [\"@@observable\"];\n  /**\n  * @internal\n  * \n  * @deprecated This is an internal API and should not be used directly. This can be removed or changed at any time.\n  */\n  getCacheDiff({\n    optimistic = true\n  } = {}) {\n    return this.queryManager.cache.diff({\n      query: this.query,\n      variables: this.variables,\n      returnPartialData: true,\n      optimistic\n    });\n  }\n  getInitialResult(initialFetchPolicy) {\n    const fetchPolicy = this.queryManager.prioritizeCacheValues ? \"cache-first\" : initialFetchPolicy || this.options.fetchPolicy;\n    const cacheResult = () => {\n      const diff = this.getCacheDiff();\n      // TODO: queryInfo.getDiff should handle this since cache.diff returns a\n      // null when returnPartialData is false\n      const data = this.options.returnPartialData || diff.complete ? diff.result ?? undefined : undefined;\n      return this.maskResult({\n        data,\n        dataState: diff.complete ? \"complete\" : data === undefined ? \"empty\" : \"partial\",\n        loading: !diff.complete,\n        networkStatus: diff.complete ? NetworkStatus.ready : NetworkStatus.loading,\n        partial: !diff.complete\n      });\n    };\n    switch (fetchPolicy) {\n      case \"cache-only\":\n        {\n          return {\n            ...cacheResult(),\n            loading: false,\n            networkStatus: NetworkStatus.ready\n          };\n        }\n      case \"cache-first\":\n        return cacheResult();\n      case \"cache-and-network\":\n        return {\n          ...cacheResult(),\n          loading: true,\n          networkStatus: NetworkStatus.loading\n        };\n      case \"standby\":\n        return empty;\n      default:\n        return uninitialized;\n    }\n  }\n  resubscribeCache() {\n    const {\n      variables,\n      fetchPolicy\n    } = this.options;\n    const query = this.query;\n    const shouldUnsubscribe = fetchPolicy === \"standby\" || fetchPolicy === \"no-cache\" || this.waitForNetworkResult;\n    const shouldResubscribe = !isEqualQuery({\n      query,\n      variables\n    }, this.unsubscribeFromCache) && !this.waitForNetworkResult;\n    if (shouldUnsubscribe || shouldResubscribe) {\n      this.unsubscribeFromCache?.();\n    }\n    if (shouldUnsubscribe || !shouldResubscribe) {\n      return;\n    }\n    const watch = {\n      query,\n      variables,\n      optimistic: true,\n      watcher: this,\n      callback: diff => {\n        const info = this.queryManager.getDocumentInfo(query);\n        if (info.hasClientExports || info.hasForcedResolvers) {\n          // If this is not set to something different than `diff`, we will\n          // not be notified about future cache changes with an equal `diff`.\n          // That would be the case if we are working with client-only fields\n          // that are forced or with `exports` fields that might change, causing\n          // local resovlers to return a new result.\n          // This is based on an implementation detail of `InMemoryCache`, which\n          // is not optimal - but the only alternative to this would be to\n          // resubscribe to the cache asynchonouly, which would bear the risk of\n          // missing further synchronous updates.\n          watch.lastDiff = undefined;\n        }\n        if (watch.lastOwnDiff === diff) {\n          // skip cache updates that were caused by our own writes\n          return;\n        }\n        const {\n          result: previousResult\n        } = this.subject.getValue();\n        if (!diff.complete && (\n        // If we are trying to deliver an incomplete cache result, we avoid\n        // reporting it if the query has errored, otherwise we let the broadcast try\n        // and repair the partial result by refetching the query. This check avoids\n        // a situation where a query that errors and another succeeds with\n        // overlapping data does not report the partial data result to the errored\n        // query.\n        //\n        // See https://github.com/apollographql/apollo-client/issues/11400 for more\n        // information on this issue.\n        previousResult.error ||\n        // Prevent to schedule a notify directly after the `ObservableQuery`\n        // has been `reset` (which will set the `previousResult` to `uninitialized` or `empty`)\n        // as in those cases, `resetCache` will manually call `refetch` with more intentional timing.\n        previousResult === uninitialized || previousResult === empty)) {\n          return;\n        }\n        if (!equal(previousResult.data, diff.result)) {\n          this.scheduleNotify();\n        }\n      }\n    };\n    const cancelWatch = this.queryManager.cache.watch(watch);\n    this.unsubscribeFromCache = Object.assign(() => {\n      this.unsubscribeFromCache = undefined;\n      cancelWatch();\n    }, {\n      query,\n      variables\n    });\n  }\n  stableLastResult;\n  getCurrentResult() {\n    const {\n      result: current\n    } = this.subject.getValue();\n    let value =\n    // if the `current` result is in an error state, we will always return that\n    // error state, even if we have no observers\n    current.networkStatus === NetworkStatus.error ||\n    // if we have observers, we are watching the cache and\n    // this.subject.getValue() will always be up to date\n    this.hasObservers() ||\n    // if we are using a `no-cache` fetch policy in which case this\n    // `ObservableQuery` cannot have been updated from the outside - in\n    // that case, we prefer to keep the current value\n    this.options.fetchPolicy === \"no-cache\" ? current\n    // otherwise, the `current` value might be outdated due to missed\n    // external updates - calculate it again\n    : this.getInitialResult();\n    if (value === uninitialized) {\n      value = this.getInitialResult();\n    }\n    if (!equal(this.stableLastResult, value)) {\n      this.stableLastResult = value;\n    }\n    return this.stableLastResult;\n  }\n  /**\n   * Update the variables of this observable query, and fetch the new results.\n   * This method should be preferred over `setVariables` in most use cases.\n   *\n   * Returns a `ResultPromise` with an additional `.retain()` method. Calling\n   * `.retain()` keeps the network operation running even if the `ObservableQuery`\n   * no longer requires the result.\n   *\n   * Note: `refetch()` guarantees that a value will be emitted from the\n   * observable, even if the result is deep equal to the previous value.\n   *\n   * @param variables - The new set of variables. If there are missing variables,\n   * the previous values of those variables will be used.\n   */\n  refetch(variables) {\n    const {\n      fetchPolicy\n    } = this.options;\n    const reobserveOptions = {\n      // Always disable polling for refetches.\n      pollInterval: 0\n    };\n    // Unless the provided fetchPolicy always consults the network\n    // (no-cache, network-only, or cache-and-network), override it with\n    // network-only to force the refetch for this fetchQuery call.\n    if (fetchPolicy === \"no-cache\") {\n      reobserveOptions.fetchPolicy = \"no-cache\";\n    } else {\n      reobserveOptions.fetchPolicy = \"network-only\";\n    }\n    if (__DEV__ && variables && hasOwnProperty.call(variables, \"variables\")) {\n      const queryDef = getQueryDefinition(this.query);\n      const vars = queryDef.variableDefinitions;\n      if (!vars || !vars.some(v => v.variable.name.value === \"variables\")) {\n        __DEV__ && invariant.warn(77, variables, queryDef.name?.value || queryDef);\n      }\n    }\n    if (variables && !equal(this.variables, variables)) {\n      // Update the existing options with new variables\n      reobserveOptions.variables = this.options.variables = this.getVariablesWithDefaults({\n        ...this.variables,\n        ...variables\n      });\n    }\n    this._lastWrite = undefined;\n    return this._reobserve(reobserveOptions, {\n      newNetworkStatus: NetworkStatus.refetch\n    });\n  }\n  fetchMore({\n    query,\n    variables,\n    context,\n    errorPolicy,\n    updateQuery\n  }) {\n    invariant(this.options.fetchPolicy !== \"cache-only\", 78, getOperationName(this.query, \"(anonymous)\"));\n    const combinedOptions = {\n      ...compact(this.options, {\n        errorPolicy: \"none\"\n      }, {\n        query,\n        context,\n        errorPolicy\n      }),\n      variables: query ? variables : {\n        ...this.variables,\n        ...variables\n      },\n      // The fetchMore request goes immediately to the network and does\n      // not automatically write its result to the cache (hence no-cache\n      // instead of network-only), because we allow the caller of\n      // fetchMore to provide an updateQuery callback that determines how\n      // the data gets written to the cache.\n      fetchPolicy: \"no-cache\",\n      notifyOnNetworkStatusChange: this.options.notifyOnNetworkStatusChange\n    };\n    combinedOptions.query = this.transformDocument(combinedOptions.query);\n    // If a temporary query is passed to `fetchMore`, we don't want to store\n    // it as the last query result since it may be an optimized query for\n    // pagination. We will however run the transforms on the original document\n    // as well as the document passed in `fetchMoreOptions` to ensure the cache\n    // uses the most up-to-date document which may rely on runtime conditionals.\n    this.lastQuery = query ? this.transformDocument(this.options.query) : combinedOptions.query;\n    let wasUpdated = false;\n    const isCached = this.options.fetchPolicy !== \"no-cache\";\n    if (!isCached) {\n      invariant(updateQuery, 79);\n    }\n    const {\n      finalize,\n      pushNotification\n    } = this.pushOperation(NetworkStatus.fetchMore);\n    pushNotification({\n      source: \"newNetworkStatus\",\n      kind: \"N\",\n      value: {}\n    }, {\n      shouldEmit: 3 /* EmitBehavior.networkStatusChange */\n    });\n    return this.queryManager.fetchQuery(combinedOptions, NetworkStatus.fetchMore).then(fetchMoreResult => {\n      // disable the `fetchMore` override that is currently active\n      // the next updates caused by this should not be `fetchMore` anymore,\n      // but `ready` or whatever other calculated loading state is currently\n      // appropriate\n      finalize();\n      if (isCached) {\n        // Performing this cache update inside a cache.batch transaction ensures\n        // any affected cache.watch watchers are notified at most once about any\n        // updates. Most watchers will be using the QueryInfo class, which\n        // responds to notifications by calling reobserveCacheFirst to deliver\n        // fetchMore cache results back to this ObservableQuery.\n        this.queryManager.cache.batch({\n          update: cache => {\n            if (updateQuery) {\n              cache.updateQuery({\n                query: this.query,\n                variables: this.variables,\n                returnPartialData: true,\n                optimistic: false\n              }, previous => updateQuery(previous, {\n                fetchMoreResult: fetchMoreResult.data,\n                variables: combinedOptions.variables\n              }));\n            } else {\n              // If we're using a field policy instead of updateQuery, the only\n              // thing we need to do is write the new data to the cache using\n              // combinedOptions.variables (instead of this.variables, which is\n              // what this.updateQuery uses, because it works by abusing the\n              // original field value, keyed by the original variables).\n              cache.writeQuery({\n                query: combinedOptions.query,\n                variables: combinedOptions.variables,\n                data: fetchMoreResult.data\n              });\n            }\n          },\n          onWatchUpdated: watch => {\n            if (watch.watcher === this) {\n              wasUpdated = true;\n            }\n          }\n        });\n      } else {\n        // There is a possibility `lastResult` may not be set when\n        // `fetchMore` is called which would cause this to crash. This should\n        // only happen if we haven't previously reported a result. We don't\n        // quite know what the right behavior should be here since this block\n        // of code runs after the fetch result has executed on the network.\n        // We plan to let it crash in the meantime.\n        //\n        // If we get bug reports due to the `data` property access on\n        // undefined, this should give us a real-world scenario that we can\n        // use to test against and determine the right behavior. If we do end\n        // up changing this behavior, this may require, for example, an\n        // adjustment to the types on `updateQuery` since that function\n        // expects that the first argument always contains previous result\n        // data, but not `undefined`.\n        const lastResult = this.getCurrentResult();\n        const data = updateQuery(lastResult.data, {\n          fetchMoreResult: fetchMoreResult.data,\n          variables: combinedOptions.variables\n        });\n        // was reportResult\n        pushNotification({\n          kind: \"N\",\n          value: {\n            ...lastResult,\n            networkStatus: NetworkStatus.ready,\n            // will be overwritten anyways, just here for types sake\n            loading: false,\n            data: data,\n            dataState: lastResult.dataState === \"streaming\" ? \"streaming\" : \"complete\"\n          },\n          source: \"network\"\n        });\n      }\n      return this.maskResult(fetchMoreResult);\n    }).finally(() => {\n      // call `finalize` a second time in case the `.then` case above was not reached\n      finalize();\n      // In case the cache writes above did not generate a broadcast\n      // notification (which would have been intercepted by onWatchUpdated),\n      // likely because the written data were the same as what was already in\n      // the cache, we still want fetchMore to deliver its final loading:false\n      // result with the unchanged data.\n      if (isCached && !wasUpdated) {\n        pushNotification({\n          kind: \"N\",\n          source: \"newNetworkStatus\",\n          value: {}\n        }, {\n          shouldEmit: 1 /* EmitBehavior.force */\n        });\n      }\n    });\n  }\n  // XXX the subscription variables are separate from the query variables.\n  // if you want to update subscription variables, right now you have to do that separately,\n  // and you can only do it by stopping the subscription and then subscribing again with new variables.\n  /**\n   * A function that enables you to execute a [subscription](https://www.apollographql.com/docs/react/data/subscriptions/), usually to subscribe to specific fields that were included in the query.\n   *\n   * This function returns _another_ function that you can call to terminate the subscription.\n   */\n  subscribeToMore(options) {\n    const subscription = this.queryManager.startGraphQLSubscription({\n      query: options.document,\n      variables: options.variables,\n      context: options.context\n    }).subscribe({\n      next: subscriptionData => {\n        const {\n          updateQuery,\n          onError\n        } = options;\n        const {\n          error\n        } = subscriptionData;\n        if (error) {\n          if (onError) {\n            onError(error);\n          } else {\n            invariant.error(80, error);\n          }\n          return;\n        }\n        if (updateQuery) {\n          this.updateQuery((previous, updateOptions) => updateQuery(previous, {\n            subscriptionData: subscriptionData,\n            ...updateOptions\n          }));\n        }\n      }\n    });\n    this.subscriptions.add(subscription);\n    return () => {\n      if (this.subscriptions.delete(subscription)) {\n        subscription.unsubscribe();\n      }\n    };\n  }\n  /**\n  * @internal\n  * \n  * @deprecated This is an internal API and should not be used directly. This can be removed or changed at any time.\n  */\n  applyOptions(newOptions) {\n    const mergedOptions = compact(this.options, newOptions || {});\n    assign(this.options, mergedOptions);\n    this.updatePolling();\n  }\n  /**\n   * Update the variables of this observable query, and fetch the new results\n   * if they've changed. Most users should prefer `refetch` instead of\n   * `setVariables` in order to to be properly notified of results even when\n   * they come from the cache.\n   *\n   * Note: `setVariables()` guarantees that a value will be emitted from the\n   * observable, even if the result is deeply equal to the previous value.\n   *\n   * Note: the promise will resolve with the last emitted result\n   * when either the variables match the current variables or there\n   * are no subscribers to the query.\n   *\n   * @param variables - The new set of variables. If there are missing variables,\n   * the previous values of those variables will be used.\n   */\n  async setVariables(variables) {\n    variables = this.getVariablesWithDefaults(variables);\n    if (equal(this.variables, variables)) {\n      // If we have no observers, then we don't actually want to make a network\n      // request. As soon as someone observes the query, the request will kick\n      // off. For now, we just store any changes. (See #1077)\n      return toQueryResult(this.getCurrentResult());\n    }\n    this.options.variables = variables;\n    // See comment above\n    if (!this.hasObservers()) {\n      return toQueryResult(this.getCurrentResult());\n    }\n    return this._reobserve({\n      // Reset options.fetchPolicy to its original value.\n      fetchPolicy: this.options.initialFetchPolicy,\n      variables\n    }, {\n      newNetworkStatus: NetworkStatus.setVariables\n    });\n  }\n  /**\n   * A function that enables you to update the query's cached result without executing a followup GraphQL operation.\n   *\n   * See [using updateQuery and updateFragment](https://www.apollographql.com/docs/react/caching/cache-interaction/#using-updatequery-and-updatefragment) for additional information.\n   */\n  updateQuery(mapFn) {\n    const {\n      queryManager\n    } = this;\n    const {\n      result,\n      complete\n    } = this.getCacheDiff({\n      optimistic: false\n    });\n    const newResult = mapFn(result, {\n      variables: this.variables,\n      complete: !!complete,\n      previousData: result\n    });\n    if (newResult) {\n      queryManager.cache.writeQuery({\n        query: this.options.query,\n        data: newResult,\n        variables: this.variables\n      });\n      queryManager.broadcastQueries();\n    }\n  }\n  /**\n   * A function that instructs the query to begin re-executing at a specified interval (in milliseconds).\n   */\n  startPolling(pollInterval) {\n    this.options.pollInterval = pollInterval;\n    this.updatePolling();\n  }\n  /**\n   * A function that instructs the query to stop polling after a previous call to `startPolling`.\n   */\n  stopPolling() {\n    this.options.pollInterval = 0;\n    this.updatePolling();\n  }\n  // Update options.fetchPolicy according to options.nextFetchPolicy.\n  applyNextFetchPolicy(reason,\n  // It's possible to use this method to apply options.nextFetchPolicy to\n  // options.fetchPolicy even if options !== this.options, though that happens\n  // most often when the options are temporary, used for only one request and\n  // then thrown away, so nextFetchPolicy may not end up mattering.\n  options) {\n    if (options.nextFetchPolicy) {\n      const {\n        fetchPolicy = \"cache-first\",\n        initialFetchPolicy = fetchPolicy\n      } = options;\n      if (fetchPolicy === \"standby\") {\n        // Do nothing, leaving options.fetchPolicy unchanged.\n      } else if (typeof options.nextFetchPolicy === \"function\") {\n        // When someone chooses \"cache-and-network\" or \"network-only\" as their\n        // initial FetchPolicy, they often do not want future cache updates to\n        // trigger unconditional network requests, which is what repeatedly\n        // applying the \"cache-and-network\" or \"network-only\" policies would\n        // seem to imply. Instead, when the cache reports an update after the\n        // initial network request, it may be desirable for subsequent network\n        // requests to be triggered only if the cache result is incomplete. To\n        // that end, the options.nextFetchPolicy option provides an easy way to\n        // update options.fetchPolicy after the initial network request, without\n        // having to call observableQuery.reobserve.\n        options.fetchPolicy = options.nextFetchPolicy.call(options, fetchPolicy, {\n          reason,\n          options,\n          observable: this,\n          initialFetchPolicy\n        });\n      } else if (reason === \"variables-changed\") {\n        options.fetchPolicy = initialFetchPolicy;\n      } else {\n        options.fetchPolicy = options.nextFetchPolicy;\n      }\n    }\n    return options.fetchPolicy;\n  }\n  fetch(options, networkStatus, fetchQuery, operator) {\n    // TODO Make sure we update the networkStatus (and infer fetchVariables)\n    // before actually committing to the fetch.\n    const initialFetchPolicy = this.options.fetchPolicy;\n    options.context ??= {};\n    let synchronouslyEmitted = false;\n    const onCacheHit = () => {\n      synchronouslyEmitted = true;\n    };\n    const fetchQueryOperator =\n    // we cannot use `tap` here, since it allows only for a \"before subscription\"\n\n    // hook with `subscribe` and we care for \"directly before and after subscription\"\n    source => new Observable(subscriber => {\n      try {\n        return source.subscribe({\n          next(value) {\n            synchronouslyEmitted = true;\n            subscriber.next(value);\n          },\n          error: error => subscriber.error(error),\n          complete: () => subscriber.complete()\n        });\n      } finally {\n        if (!synchronouslyEmitted) {\n          operation.override = networkStatus;\n          this.input.next({\n            kind: \"N\",\n            source: \"newNetworkStatus\",\n            value: {\n              resetError: true\n            },\n            query,\n            variables,\n            meta: {\n              shouldEmit: 3 /* EmitBehavior.networkStatusChange */,\n\n              /*\n               * The moment this notification is emitted, `nextFetchPolicy`\n               * might already have switched from a `network-only` to a\n               * `cache-something` policy, so we want to ensure that the\n               * loading state emit doesn't accidentally read from the cache\n               * in those cases.\n               */\n              fetchPolicy: initialFetchPolicy\n            }\n          });\n        }\n      }\n    });\n    let {\n      observable,\n      fromLink\n    } = this.queryManager.fetchObservableWithInfo(options, {\n      networkStatus,\n      query: fetchQuery,\n      onCacheHit,\n      fetchQueryOperator,\n      observableQuery: this\n    });\n    // track query and variables from the start of the operation\n    const {\n      query,\n      variables\n    } = this;\n    const operation = {\n      abort: () => {\n        subscription.unsubscribe();\n      },\n      query,\n      variables\n    };\n    this.activeOperations.add(operation);\n    let forceFirstValueEmit = networkStatus == NetworkStatus.refetch || networkStatus == NetworkStatus.setVariables;\n    observable = observable.pipe(operator, share());\n    const subscription = observable.pipe(tap({\n      next: notification => {\n        if (notification.source === \"newNetworkStatus\" || notification.kind === \"N\" && notification.value.loading) {\n          operation.override = networkStatus;\n        } else {\n          delete operation.override;\n        }\n      },\n      finalize: () => this.activeOperations.delete(operation)\n    })).subscribe({\n      next: value => {\n        const meta = {};\n        if (forceFirstValueEmit && value.kind === \"N\" && \"loading\" in value.value && !value.value.loading) {\n          forceFirstValueEmit = false;\n          meta.shouldEmit = 1 /* EmitBehavior.force */;\n        }\n        this.input.next({\n          ...value,\n          query,\n          variables,\n          meta\n        });\n      }\n    });\n    return {\n      fromLink,\n      subscription,\n      observable\n    };\n  }\n  // Turns polling on or off based on this.options.pollInterval.\n  didWarnCacheOnlyPolling = false;\n  updatePolling() {\n    // Avoid polling in SSR mode\n    if (this.queryManager.ssrMode) {\n      return;\n    }\n    const {\n      pollingInfo,\n      options: {\n        fetchPolicy,\n        pollInterval\n      }\n    } = this;\n    if (!pollInterval || !this.hasObservers() || fetchPolicy === \"cache-only\") {\n      if (__DEV__) {\n        if (!this.didWarnCacheOnlyPolling && pollInterval && fetchPolicy === \"cache-only\") {\n          __DEV__ && invariant.warn(81, getOperationName(this.query, \"(anonymous)\"));\n          this.didWarnCacheOnlyPolling = true;\n        }\n      }\n      this.cancelPolling();\n      return;\n    }\n    if (pollingInfo?.interval === pollInterval) {\n      return;\n    }\n    const info = pollingInfo || (this.pollingInfo = {});\n    info.interval = pollInterval;\n    const maybeFetch = () => {\n      if (this.pollingInfo) {\n        if (!isNetworkRequestInFlight(this.networkStatus) && !this.options.skipPollAttempt?.()) {\n          this._reobserve({\n            // Most fetchPolicy options don't make sense to use in a polling context, as\n            // users wouldn't want to be polling the cache directly. However, network-only and\n            // no-cache are both useful for when the user wants to control whether or not the\n            // polled results are written to the cache.\n            fetchPolicy: this.options.initialFetchPolicy === \"no-cache\" ? \"no-cache\" : \"network-only\"\n          }, {\n            newNetworkStatus: NetworkStatus.poll\n          }).then(poll, poll);\n        } else {\n          poll();\n        }\n      }\n    };\n    const poll = () => {\n      const info = this.pollingInfo;\n      if (info) {\n        clearTimeout(info.timeout);\n        info.timeout = setTimeout(maybeFetch, info.interval);\n      }\n    };\n    poll();\n  }\n  // This differs from stopPolling in that it does not set pollInterval to 0\n  cancelPolling() {\n    if (this.pollingInfo) {\n      clearTimeout(this.pollingInfo.timeout);\n      delete this.pollingInfo;\n    }\n  }\n  /**\n   * Reevaluate the query, optionally against new options. New options will be\n   * merged with the current options when given.\n   *\n   * Note: `variables` can be reset back to their defaults (typically empty) by calling `reobserve` with\n   * `variables: undefined`.\n   */\n  reobserve(newOptions) {\n    return this._reobserve(newOptions);\n  }\n  _reobserve(newOptions, internalOptions) {\n    this.isTornDown = false;\n    let {\n      newNetworkStatus\n    } = internalOptions || {};\n    this.queryManager.obsQueries.add(this);\n    const useDisposableObservable =\n    // Refetching uses a disposable Observable to allow refetches using different\n    // options, without permanently altering the options of the\n    // original ObservableQuery.\n    newNetworkStatus === NetworkStatus.refetch ||\n    // Polling uses a disposable Observable so the polling options (which force\n    // fetchPolicy to be \"network-only\" or \"no-cache\") won't override the original options.\n    newNetworkStatus === NetworkStatus.poll;\n    // Save the old variables, since Object.assign may modify them below.\n    const oldVariables = this.variables;\n    const oldFetchPolicy = this.options.fetchPolicy;\n    const mergedOptions = compact(this.options, newOptions || {});\n    const options = useDisposableObservable ?\n    // Disposable Observable fetches receive a shallow copy of this.options\n    // (merged with newOptions), leaving this.options unmodified.\n    mergedOptions : assign(this.options, mergedOptions);\n    // Don't update options.query with the transformed query to avoid\n    // overwriting this.options.query when we aren't using a disposable concast.\n    // We want to ensure we can re-run the custom document transforms the next\n    // time a request is made against the original query.\n    const query = this.transformDocument(options.query);\n    this.lastQuery = query;\n    // Reevaluate variables to allow resetting variables with variables: undefined,\n    // otherwise `compact` will ignore the `variables` key in `newOptions`. We\n    // do this after we run the query transform to ensure we get default\n    // variables from the transformed query.\n    //\n    // Note: updating options.variables may mutate this.options.variables\n    // in the case of a non-disposable query. This is intentional.\n    if (newOptions && \"variables\" in newOptions) {\n      options.variables = this.getVariablesWithDefaults(newOptions.variables);\n    }\n    if (!useDisposableObservable) {\n      // We can skip calling updatePolling if we're not changing this.options.\n      this.updatePolling();\n      // Reset options.fetchPolicy to its original value when variables change,\n      // unless a new fetchPolicy was provided by newOptions.\n      if (newOptions && newOptions.variables && !equal(newOptions.variables, oldVariables) &&\n      // Don't mess with the fetchPolicy if it's currently \"standby\".\n      options.fetchPolicy !== \"standby\" && (\n      // If we're changing the fetchPolicy anyway, don't try to change it here\n      // using applyNextFetchPolicy. The explicit options.fetchPolicy wins.\n      options.fetchPolicy === oldFetchPolicy ||\n      // A `nextFetchPolicy` function has even higher priority, though,\n      // so in that case `applyNextFetchPolicy` must be called.\n      typeof options.nextFetchPolicy === \"function\")) {\n        // This might mutate options.fetchPolicy\n        this.applyNextFetchPolicy(\"variables-changed\", options);\n        if (newNetworkStatus === void 0) {\n          newNetworkStatus = NetworkStatus.setVariables;\n        }\n      }\n    }\n    const oldNetworkStatus = this.networkStatus;\n    if (!newNetworkStatus) {\n      newNetworkStatus = NetworkStatus.loading;\n      if (oldNetworkStatus !== NetworkStatus.loading && newOptions?.variables && !equal(newOptions.variables, oldVariables)) {\n        newNetworkStatus = NetworkStatus.setVariables;\n      }\n      // QueryManager does not emit any values for standby fetch policies so we\n      // want ensure that the networkStatus remains ready.\n      if (options.fetchPolicy === \"standby\") {\n        newNetworkStatus = NetworkStatus.ready;\n      }\n    }\n    if (options.fetchPolicy === \"standby\") {\n      this.cancelPolling();\n    }\n    this.resubscribeCache();\n    const {\n      promise,\n      operator: promiseOperator\n    } = getTrackingOperatorPromise(value => {\n      switch (value.kind) {\n        case \"E\":\n          throw value.error;\n        case \"N\":\n          if (value.source !== \"newNetworkStatus\" && !value.value.loading) return value.value;\n      }\n    },\n    // This default value should only be used when using a `fetchPolicy` of\n    // `standby` since that fetch policy completes without emitting a\n    // result. Since we are converting this to a QueryResult type, we\n    // omit the extra fields from ApolloQueryResult in the default value.\n    options.fetchPolicy === \"standby\" ? {\n      data: undefined\n    } : undefined);\n    const {\n      subscription,\n      observable,\n      fromLink\n    } = this.fetch(options, newNetworkStatus, query, promiseOperator);\n    if (!useDisposableObservable && (fromLink || !this.linkSubscription)) {\n      if (this.linkSubscription) {\n        this.linkSubscription.unsubscribe();\n      }\n      this.linkSubscription = subscription;\n    }\n    const ret = Object.assign(preventUnhandledRejection(promise.then(result => toQueryResult(this.maskResult(result))).finally(() => {\n      if (!this.hasObservers() && this.activeOperations.size === 0) {\n        // If `reobserve` was called on a query without any obervers,\n        // the teardown logic would never be called, so we need to\n        // call it here to ensure the query is properly torn down.\n        this.tearDownQuery();\n      }\n    })), {\n      retain: () => {\n        const subscription = observable.subscribe({});\n        const unsubscribe = () => subscription.unsubscribe();\n        promise.then(unsubscribe, unsubscribe);\n        return ret;\n      }\n    });\n    return ret;\n  }\n  hasObservers() {\n    return this.subject.observed;\n  }\n  /**\n   * Tears down the `ObservableQuery` and stops all active operations by sending a `complete` notification.\n   */\n  stop() {\n    this.subject.complete();\n    this.initializeObservablesQueue();\n    this.tearDownQuery();\n  }\n  tearDownQuery() {\n    if (this.isTornDown) return;\n    this.resetNotifications();\n    this.unsubscribeFromCache?.();\n    if (this.linkSubscription) {\n      this.linkSubscription.unsubscribe();\n      delete this.linkSubscription;\n    }\n    this.stopPolling();\n    // stop all active GraphQL subscriptions\n    this.subscriptions.forEach(sub => sub.unsubscribe());\n    this.subscriptions.clear();\n    this.queryManager.obsQueries.delete(this);\n    this.isTornDown = true;\n    this.abortActiveOperations();\n    this._lastWrite = undefined;\n  }\n  transformDocument(document) {\n    return this.queryManager.transform(document);\n  }\n  maskResult(result) {\n    const masked = this.queryManager.maskOperation({\n      document: this.query,\n      data: result.data,\n      fetchPolicy: this.options.fetchPolicy,\n      cause: this\n    });\n    // Maintain object identity as much as possible\n    return masked === result.data ? result : {\n      ...result,\n      data: masked\n    };\n  }\n  dirty = false;\n  notifyTimeout;\n  /**\n  * @internal\n  * \n  * @deprecated This is an internal API and should not be used directly. This can be removed or changed at any time.\n  */\n  resetNotifications() {\n    if (this.notifyTimeout) {\n      clearTimeout(this.notifyTimeout);\n      this.notifyTimeout = void 0;\n    }\n    this.dirty = false;\n  }\n  /**\n  * @internal\n  * \n  * @deprecated This is an internal API and should not be used directly. This can be removed or changed at any time.\n  */\n  scheduleNotify() {\n    if (this.dirty) return;\n    this.dirty = true;\n    if (!this.notifyTimeout) {\n      this.notifyTimeout = setTimeout(() => this.notify(true), 0);\n    }\n  }\n  /**\n  * @internal\n  * \n  * @deprecated This is an internal API and should not be used directly. This can be removed or changed at any time.\n  */\n  notify(scheduled = false) {\n    if (!scheduled) {\n      // For queries with client exports or forced resolvers, we don't want to\n      // synchronously reobserve the cache on broadcast,\n      // but actually wait for the `scheduleNotify` timeout triggered by the\n      // `cache.watch` callback from `resubscribeCache`.\n      const info = this.queryManager.getDocumentInfo(this.query);\n      if (info.hasClientExports || info.hasForcedResolvers) {\n        return;\n      }\n    }\n    const {\n      dirty\n    } = this;\n    this.resetNotifications();\n    if (dirty && (this.options.fetchPolicy == \"cache-only\" || this.options.fetchPolicy == \"cache-and-network\" || !this.activeOperations.size)) {\n      const diff = this.getCacheDiff();\n      if (\n      // `fromOptimisticTransaction` is not avaiable through the `cache.diff`\n      // code path, so we need to check it this way\n      equal(diff.result, this.getCacheDiff({\n        optimistic: false\n      }).result)) {\n        //If this diff did not come from an optimistic transaction\n        // make the ObservableQuery \"reobserve\" the latest data\n        // using a temporary fetch policy of \"cache-first\", so complete cache\n        // results have a chance to be delivered without triggering additional\n        // network requests, even when options.fetchPolicy is \"network-only\"\n        // or \"cache-and-network\". All other fetch policies are preserved by\n        // this method, and are handled by calling oq.reobserve(). If this\n        // reobservation is spurious, distinctUntilChanged still has a\n        // chance to catch it before delivery to ObservableQuery subscribers.\n        this.reobserveCacheFirst();\n      } else {\n        // If this diff came from an optimistic transaction, deliver the\n        // current cache data to the ObservableQuery, but don't perform a\n        // reobservation, since oq.reobserveCacheFirst might make a network\n        // request, and we never want to trigger network requests in the\n        // middle of optimistic updates.\n        this.input.next({\n          kind: \"N\",\n          value: {\n            data: diff.result,\n            dataState: diff.complete ? \"complete\" : diff.result ? \"partial\" : \"empty\",\n            networkStatus: NetworkStatus.ready,\n            loading: false,\n            error: undefined,\n            partial: !diff.complete\n          },\n          source: \"cache\",\n          query: this.query,\n          variables: this.variables,\n          meta: {}\n        });\n      }\n    }\n  }\n  activeOperations = new Set();\n  pushOperation(networkStatus) {\n    let aborted = false;\n    // track query and variables from the start of the operation\n    const {\n      query,\n      variables\n    } = this;\n    const finalize = () => {\n      this.activeOperations.delete(operation);\n    };\n    const operation = {\n      override: networkStatus,\n      abort: () => {\n        aborted = true;\n        finalize();\n      },\n      query,\n      variables\n    };\n    this.activeOperations.add(operation);\n    return {\n      finalize,\n      pushNotification: (notification, additionalMeta) => {\n        if (!aborted) {\n          this.input.next({\n            ...notification,\n            query,\n            variables,\n            meta: {\n              ...additionalMeta\n            }\n          });\n        }\n      }\n    };\n  }\n  calculateNetworkStatus(baseNetworkStatus) {\n    if (baseNetworkStatus === NetworkStatus.streaming) {\n      return baseNetworkStatus;\n    }\n    // in the future, this could be more complex logic, e.g. \"refetch\" and\n    // \"fetchMore\" having priority over \"polling\" or \"loading\" network statuses\n    // as for now we just take the \"latest\" operation that is still active,\n    // as that lines up best with previous behavior[]\n    const operation = Array.from(this.activeOperations.values()).findLast(operation => isEqualQuery(operation, this) && operation.override !== undefined);\n    return operation?.override ?? baseNetworkStatus;\n  }\n  abortActiveOperations() {\n    this.activeOperations.forEach(operation => operation.abort());\n  }\n  /**\n  * @internal\n  * Called from `clearStore`.\n  *\n  * - resets the query to its initial state\n  * - cancels all active operations and their subscriptions\n  * \n  * @deprecated This is an internal API and should not be used directly. This can be removed or changed at any time.\n  */\n  reset() {\n    // exception for cache-only queries - we reset them into a \"ready\" state\n    // as we won't trigger a refetch for them\n    const resetToEmpty = this.options.fetchPolicy === \"cache-only\";\n    this.setResult(resetToEmpty ? empty : uninitialized, {\n      shouldEmit: resetToEmpty ? 1 /* EmitBehavior.force */ : 2 /* EmitBehavior.never */\n    });\n    this.abortActiveOperations();\n  }\n  /**\n  * @internal\n  * \n  * @deprecated This is an internal API and should not be used directly. This can be removed or changed at any time.\n  */\n  setResult(result, additionalMeta) {\n    this.input.next({\n      source: \"setResult\",\n      kind: \"N\",\n      value: result,\n      query: this.query,\n      variables: this.variables,\n      meta: {\n        ...additionalMeta\n      }\n    });\n  }\n  operator = filterMap(notification => {\n    const {\n      query,\n      variables,\n      meta\n    } = notification;\n    if (notification.source === \"setResult\") {\n      return {\n        query,\n        variables,\n        result: notification.value,\n        meta\n      };\n    }\n    if (notification.kind === \"C\" || !isEqualQuery(notification, this)) {\n      return;\n    }\n    let result;\n    const previous = this.subject.getValue();\n    if (notification.source === \"cache\") {\n      result = notification.value;\n      if (result.networkStatus === NetworkStatus.ready && result.partial && (!this.options.returnPartialData || previous.result.networkStatus === NetworkStatus.error) && this.options.fetchPolicy !== \"cache-only\") {\n        return;\n      }\n    } else if (notification.source === \"network\") {\n      if (this.waitForNetworkResult) {\n        this.waitForNetworkResult = false;\n        this.resubscribeCache();\n      }\n      result = notification.kind === \"E\" ? {\n        ...(isEqualQuery(previous, notification) ? previous.result : {\n          data: undefined,\n          dataState: \"empty\",\n          partial: true\n        }),\n        error: notification.error,\n        networkStatus: NetworkStatus.error,\n        loading: false\n      } : notification.value;\n      if (notification.kind === \"E\" && result.dataState === \"streaming\") {\n        result.dataState = \"complete\";\n      }\n      if (result.error) {\n        meta.shouldEmit = 1 /* EmitBehavior.force */;\n      }\n    } else if (notification.source === \"newNetworkStatus\") {\n      const baseResult = isEqualQuery(previous, notification) ? previous.result : this.getInitialResult(meta.fetchPolicy);\n      const {\n        resetError\n      } = notification.value;\n      const error = resetError ? undefined : baseResult.error;\n      const networkStatus = error ? NetworkStatus.error : NetworkStatus.ready;\n      result = {\n        ...baseResult,\n        error,\n        networkStatus\n      };\n    }\n    // every code path until here should have either returned or set a result,\n    // but typescript needs a little help\n    invariant(result);\n    // normalize result shape\n    if (!result.error) delete result.error;\n    result.networkStatus = this.calculateNetworkStatus(result.networkStatus);\n    result.loading = isNetworkRequestInFlight(result.networkStatus);\n    result = this.maskResult(result);\n    return {\n      query,\n      variables,\n      result,\n      meta\n    };\n  });\n  // Reobserve with fetchPolicy effectively set to \"cache-first\", triggering\n  // delivery of any new data from the cache, possibly falling back to the network\n  // if any cache data are missing. This allows _complete_ cache results to be\n  // delivered without also kicking off unnecessary network requests when\n  // this.options.fetchPolicy is \"cache-and-network\" or \"network-only\". When\n  // this.options.fetchPolicy is any other policy (\"cache-first\", \"cache-only\",\n  // \"standby\", or \"no-cache\"), we call this.reobserve() as usual.\n  reobserveCacheFirst() {\n    const {\n      fetchPolicy,\n      nextFetchPolicy\n    } = this.options;\n    if (fetchPolicy === \"cache-and-network\" || fetchPolicy === \"network-only\") {\n      this.reobserve({\n        fetchPolicy: \"cache-first\",\n        // Use a temporary nextFetchPolicy function that replaces itself with the\n        // previous nextFetchPolicy value and returns the original fetchPolicy.\n        nextFetchPolicy(currentFetchPolicy, context) {\n          // Replace this nextFetchPolicy function in the options object with the\n          // original this.options.nextFetchPolicy value.\n          this.nextFetchPolicy = nextFetchPolicy;\n          // If the original nextFetchPolicy value was a function, give it a\n          // chance to decide what happens here.\n          if (typeof this.nextFetchPolicy === \"function\") {\n            return this.nextFetchPolicy(currentFetchPolicy, context);\n          }\n          // Otherwise go back to the original this.options.fetchPolicy.\n          return fetchPolicy;\n        }\n      });\n    } else {\n      this.reobserve();\n    }\n  }\n  getVariablesWithDefaults(variables) {\n    return this.queryManager.getVariables(this.query, variables);\n  }\n}\nexport function logMissingFieldErrors(missing) {\n  if (__DEV__ && missing) {\n    __DEV__ && invariant.debug(82, missing);\n  }\n}\nfunction isEqualQuery(a, b) {\n  return !!(a && b && a.query === b.query && equal(a.variables, b.variables));\n}\nfunction getTrackingOperatorPromise(filterMapCb, defaultValue) {\n  let lastValue = defaultValue,\n    resolve,\n    reject;\n  const promise = new Promise((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n  const operator = tap({\n    next(value) {\n      try {\n        const newValue = filterMapCb(value);\n        if (newValue !== undefined) {\n          lastValue = newValue;\n        }\n      } catch (error) {\n        reject(error);\n      }\n    },\n    finalize: () => {\n      if (lastValue) {\n        resolve(lastValue);\n      } else {\n        const message = \"The operation was aborted.\";\n        const name = \"AbortError\";\n        reject(typeof DOMException !== \"undefined\" ? new DOMException(message, name)\n        // some environments do not have `DOMException`, e.g. node\n        // uses a normal `Error` with a `name` property instead: https://github.com/phryneas/node/blob/d0579b64f0f6b722f8e49bf8a471dd0d0604a21e/lib/internal/errors.js#L964\n        // error.code is a legacy property that is not used anymore,\n        // and also inconsistent across environments (in supporting\n        // browsers it is `20`, in node `'ABORT_ERR'`) so we omit that.\n        : Object.assign(new Error(message), {\n          name\n        }));\n      }\n    }\n  });\n  return {\n    promise,\n    operator\n  };\n}","map":{"version":3,"names":["equal","BehaviorSubject","Observable","share","Subject","tap","isNetworkRequestInFlight","__DEV__","compact","equalByQuery","filterMap","getOperationDefinition","getOperationName","getQueryDefinition","preventUnhandledRejection","toQueryResult","invariant","NetworkStatus","assign","hasOwnProperty","Object","uninitialized","loading","networkStatus","data","undefined","dataState","partial","empty","ready","ObservableQuery","options","queryName","_lastWrite","query","lastQuery","variables","unsubscribeFromCache","input","subject","isTornDown","queryManager","subscriptions","Set","waitForNetworkResult","linkSubscription","pollingInfo","getValue","result","constructor","transformedQuery","transform","fetchPolicy","subscribeToMore","bind","maskResult","watchQuery","defaultFetchPolicy","defaultOptions","initialFetchPolicy","getVariablesWithDefaults","initializeObservablesQueue","Symbol","observable","opDef","name","value","meta","pipe","subscribe","observed","reobserve","setTimeout","updatePolling","unsubscribe","tearDownQuery","current","context","shouldEmit","previous","previousVariables","emit","documentInfo","getDocumentInfo","dataMasking","maskedQuery","nonReactiveQuery","resultIsEqual","hasNonreactiveDirective","notifyOnNetworkStatusChange","complete","operator","getCacheDiff","optimistic","cache","diff","returnPartialData","getInitialResult","prioritizeCacheValues","cacheResult","resubscribeCache","shouldUnsubscribe","shouldResubscribe","isEqualQuery","watch","watcher","callback","info","hasClientExports","hasForcedResolvers","lastDiff","lastOwnDiff","previousResult","error","scheduleNotify","cancelWatch","stableLastResult","getCurrentResult","hasObservers","refetch","reobserveOptions","pollInterval","call","queryDef","vars","variableDefinitions","some","v","variable","warn","_reobserve","newNetworkStatus","fetchMore","errorPolicy","updateQuery","combinedOptions","transformDocument","wasUpdated","isCached","finalize","pushNotification","pushOperation","source","kind","fetchQuery","then","fetchMoreResult","batch","update","writeQuery","onWatchUpdated","lastResult","finally","subscription","startGraphQLSubscription","document","next","subscriptionData","onError","updateOptions","add","delete","applyOptions","newOptions","mergedOptions","setVariables","mapFn","newResult","previousData","broadcastQueries","startPolling","stopPolling","applyNextFetchPolicy","reason","nextFetchPolicy","fetch","synchronouslyEmitted","onCacheHit","fetchQueryOperator","subscriber","operation","override","resetError","fromLink","fetchObservableWithInfo","observableQuery","abort","activeOperations","forceFirstValueEmit","notification","didWarnCacheOnlyPolling","ssrMode","cancelPolling","interval","maybeFetch","skipPollAttempt","poll","clearTimeout","timeout","internalOptions","obsQueries","useDisposableObservable","oldVariables","oldFetchPolicy","oldNetworkStatus","promise","promiseOperator","getTrackingOperatorPromise","ret","size","retain","stop","resetNotifications","forEach","sub","clear","abortActiveOperations","masked","maskOperation","cause","dirty","notifyTimeout","notify","scheduled","reobserveCacheFirst","aborted","additionalMeta","calculateNetworkStatus","baseNetworkStatus","streaming","Array","from","values","findLast","reset","resetToEmpty","setResult","baseResult","currentFetchPolicy","getVariables","logMissingFieldErrors","missing","debug","a","b","filterMapCb","defaultValue","lastValue","resolve","reject","Promise","res","rej","newValue","message","DOMException","Error"],"sources":["/home/saurabh-shukla/Desktop/Slack Lite/frontend/node_modules/@apollo/src/core/ObservableQuery.ts"],"sourcesContent":["import { equal } from \"@wry/equality\";\nimport type { DocumentNode } from \"graphql\";\nimport type {\n  InteropObservable,\n  MonoTypeOperatorFunction,\n  Observer,\n  OperatorFunction,\n  Subscribable,\n  Subscription,\n} from \"rxjs\";\nimport { BehaviorSubject, Observable, share, Subject, tap } from \"rxjs\";\n\nimport type { Cache, MissingFieldError } from \"@apollo/client/cache\";\nimport type { MissingTree } from \"@apollo/client/cache\";\nimport type { MaybeMasked, Unmasked } from \"@apollo/client/masking\";\nimport type { DeepPartial } from \"@apollo/client/utilities\";\nimport { isNetworkRequestInFlight } from \"@apollo/client/utilities\";\nimport { __DEV__ } from \"@apollo/client/utilities/environment\";\nimport {\n  compact,\n  equalByQuery,\n  filterMap,\n  getOperationDefinition,\n  getOperationName,\n  getQueryDefinition,\n  preventUnhandledRejection,\n  toQueryResult,\n} from \"@apollo/client/utilities/internal\";\nimport { invariant } from \"@apollo/client/utilities/invariant\";\n\nimport type { ApolloClient } from \"./ApolloClient.js\";\nimport { NetworkStatus } from \"./networkStatus.js\";\nimport type { QueryManager } from \"./QueryManager.js\";\nimport type {\n  DataState,\n  DefaultContext,\n  ErrorLike,\n  GetDataState,\n  OperationVariables,\n  QueryNotification,\n  TypedDocumentNode,\n} from \"./types.js\";\nimport type {\n  ErrorPolicy,\n  NextFetchPolicyContext,\n  RefetchWritePolicy,\n  SubscribeToMoreUpdateQueryFn,\n  UpdateQueryMapFn,\n  UpdateQueryOptions,\n  WatchQueryFetchPolicy,\n} from \"./watchQueryOptions.js\";\n\nconst { assign, hasOwnProperty } = Object;\n\ninterface TrackedOperation {\n  /**\n   * This NetworkStatus will be used to override the current networkStatus\n   */\n  override?: NetworkStatus;\n  /**\n   * Will abort tracking the operation from this ObservableQuery and remove it from `activeOperations`\n   */\n  abort: () => void;\n  /**\n   * `query` that was used by the `ObservableQuery` as the \"main query\" at the time the operation was started\n   * This is not necessarily the same query as the query the operation itself is doing.\n   */\n  query: DocumentNode;\n  variables: OperationVariables;\n}\n\nconst uninitialized: ObservableQuery.Result<any> = {\n  loading: true,\n  networkStatus: NetworkStatus.loading,\n  data: undefined,\n  dataState: \"empty\",\n  partial: true,\n};\n\nconst empty: ObservableQuery.Result<any> = {\n  loading: false,\n  networkStatus: NetworkStatus.ready,\n  data: undefined,\n  dataState: \"empty\",\n  partial: true,\n};\n\nconst enum EmitBehavior {\n  /**\n   * Emit will be calculated by the normal rules. (`undefined` will be treated the same as this)\n   */\n  default = 0,\n  /**\n   * This result should always be emitted, even if the result is equal to the\n   * previous result. (e.g. the first value after a `refetch`)\n   */\n  force = 1,\n  /**\n   * Never emit this result, it is only used to update `currentResult`.\n   */\n  never = 2,\n  /**\n   * This is a result carrying only a \"network status change\"/loading state update,\n   * emit according to the `notifyOnNetworkStatusChange` option.\n   */\n  networkStatusChange = 3,\n}\ninterface Meta {\n  shouldEmit?: EmitBehavior;\n  /** can be used to override `ObservableQuery.options.fetchPolicy` for this notification */\n  fetchPolicy?: WatchQueryFetchPolicy;\n}\n\nexport declare namespace ObservableQuery {\n  export type Options<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  > = {\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#fetchPolicy:member} */\n    fetchPolicy: WatchQueryFetchPolicy;\n\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#nextFetchPolicy:member} */\n    nextFetchPolicy?:\n      | WatchQueryFetchPolicy\n      | ((\n          this: ApolloClient.WatchQueryOptions<TData, TVariables>,\n          currentFetchPolicy: WatchQueryFetchPolicy,\n          context: NextFetchPolicyContext<TData, TVariables>\n        ) => WatchQueryFetchPolicy);\n\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#initialFetchPolicy:member} */\n    initialFetchPolicy: WatchQueryFetchPolicy;\n\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#refetchWritePolicy:member} */\n    refetchWritePolicy?: RefetchWritePolicy;\n\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#errorPolicy:member} */\n    errorPolicy?: ErrorPolicy;\n\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#context:member} */\n    context?: DefaultContext;\n\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#pollInterval:member} */\n    pollInterval?: number;\n\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#notifyOnNetworkStatusChange:member} */\n    notifyOnNetworkStatusChange?: boolean;\n\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#returnPartialData:member} */\n    returnPartialData?: boolean;\n\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#skipPollAttempt:member} */\n    skipPollAttempt?: () => boolean;\n\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#query:member} */\n    query: DocumentNode | TypedDocumentNode<TData, TVariables>;\n\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#variables:member} */\n    variables: TVariables;\n  };\n\n  export type FetchMoreOptions<\n    TData,\n    TVariables extends OperationVariables,\n    TFetchData = TData,\n    TFetchVars extends OperationVariables = TVariables,\n  > = {\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#query:member} */\n    query?: DocumentNode | TypedDocumentNode<TFetchData, TFetchVars>;\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#variables:member} */\n    variables?: Partial<NoInfer<TFetchVars>>;\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#errorPolicy:member} */\n    errorPolicy?: ErrorPolicy;\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#context:member} */\n    context?: DefaultContext;\n    updateQuery?: (\n      previousQueryResult: Unmasked<TData>,\n      options: {\n        fetchMoreResult: Unmasked<TFetchData>;\n        variables: TFetchVars;\n      }\n    ) => Unmasked<TData>;\n  };\n\n  export interface SubscribeToMoreOptions<\n    // eslint-disable-next-line local-rules/tdata-tvariables-order\n    TData = unknown,\n    TSubscriptionVariables extends OperationVariables = OperationVariables,\n    TSubscriptionData = TData,\n    TVariables extends OperationVariables = TSubscriptionVariables,\n  > {\n    document:\n      | DocumentNode\n      | TypedDocumentNode<TSubscriptionData, TSubscriptionVariables>;\n    variables?: TSubscriptionVariables;\n    updateQuery?: SubscribeToMoreUpdateQueryFn<\n      TData,\n      TVariables,\n      TSubscriptionData\n    >;\n    onError?: (error: ErrorLike) => void;\n    context?: DefaultContext;\n  }\n\n  /**\n   * @internal\n   * This describes the `WatchOptions` used by `ObservableQuery` to\n   * subscribe to the cache.\n   */\n  interface CacheWatchOptions<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  > extends Cache.WatchOptions<TData, TVariables> {\n    /**\n     * @internal\n     * We cannot suppress the broadcast completely, since that would\n     * result in external updates to be lost if we go from\n     * (external A) -> (own B) -> (external C) when A and C have the same\n     * value.\n     * Without the `own B` being broadcast, the `cache.watch` would swallow\n     * C.\n     * So instead we track the last \"own diff\" and suppress further processing\n     * in the callback.\n     */\n    lastOwnDiff?: Cache.DiffResult<TData>;\n  }\n\n  export type Result<\n    TData,\n    TStates extends\n      DataState<TData>[\"dataState\"] = DataState<TData>[\"dataState\"],\n  > = {\n    /** {@inheritDoc @apollo/client!QueryResultDocumentation#error:member} */\n    error?: ErrorLike;\n    /** {@inheritDoc @apollo/client!QueryResultDocumentation#loading:member} */\n    loading: boolean;\n    /** {@inheritDoc @apollo/client!QueryResultDocumentation#networkStatus:member} */\n    networkStatus: NetworkStatus;\n    /** {@inheritDoc @apollo/client!QueryResultDocumentation#partial:member} */\n    partial: boolean;\n  } & GetDataState<TData, TStates>;\n\n  /**\n   * Promise returned by `reobserve` and `refetch` methods.\n   *\n   * By default, if the `ObservableQuery` is not interested in the result\n   * of this operation anymore, the network operation will be cancelled.\n   *\n   * This has an additional `retain` method that can be used to keep the\n   * network operation running until it is finished nonetheless.\n   */\n  interface ResultPromise<T> extends Promise<T> {\n    /**\n     * Kepp the network operation running until it is finished, even if\n     * `ObservableQuery` unsubscribed from the operation.\n     */\n    retain(): this;\n  }\n\n  export namespace DocumentationTypes {\n    type OperatorFunctionChain<From, To> = [];\n    interface ObservableMethods<TData, OperatorResult> {\n      /** {@inheritDoc @apollo/client!ObservableQuery#pipe:member} */\n      pipe(\n        ...operators: OperatorFunctionChain<\n          ObservableQuery.Result<TData>,\n          OperatorResult\n        >\n      ): Observable<OperatorResult>;\n\n      /** {@inheritDoc @apollo/client!ObservableQuery#subscribe:member} */\n      subscribe(\n        observerOrNext:\n          | Partial<Observer<ObservableQuery.Result<MaybeMasked<TData>>>>\n          | ((value: ObservableQuery.Result<MaybeMasked<TData>>) => void)\n      ): Subscription;\n    }\n  }\n}\n\ninterface SubjectValue<TData, TVariables extends OperationVariables> {\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>;\n  variables: TVariables;\n  result: ObservableQuery.Result<TData>;\n  meta: Meta;\n}\n\nexport class ObservableQuery<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >\n  implements\n    Subscribable<ObservableQuery.Result<MaybeMasked<TData>>>,\n    InteropObservable<ObservableQuery.Result<MaybeMasked<TData>>>\n{\n  public readonly options: ObservableQuery.Options<TData, TVariables>;\n  public readonly queryName?: string;\n\n  /** @internal will be read and written from `QueryInfo` */\n  public _lastWrite?: unknown;\n\n  // The `query` computed property will always reflect the document transformed\n  // by the last run query. `this.options.query` will always reflect the raw\n  // untransformed query to ensure document transforms with runtime conditionals\n  // are run on the original document.\n  public get query(): TypedDocumentNode<TData, TVariables> {\n    return this.lastQuery;\n  }\n\n  /**\n   * An object containing the variables that were provided for the query.\n   */\n  public get variables(): TVariables {\n    return this.options.variables;\n  }\n\n  private unsubscribeFromCache?: {\n    (): void;\n    query: TypedDocumentNode<TData, TVariables>;\n    variables: TVariables;\n  };\n  private input!: Subject<\n    QueryNotification.Value<TData> & {\n      query: DocumentNode | TypedDocumentNode<TData, TVariables>;\n      variables: TVariables;\n      meta: Meta;\n    }\n  >;\n  private subject!: BehaviorSubject<\n    SubjectValue<MaybeMasked<TData>, TVariables>\n  >;\n\n  private isTornDown: boolean;\n  private queryManager: QueryManager;\n  private subscriptions = new Set<Subscription>();\n\n  /**\n   * If an `ObservableQuery` is created with a `network-only` fetch policy,\n   * it should actually start receiving cache updates, but not before it has\n   * received the first result from the network.\n   */\n  private waitForNetworkResult: boolean;\n  private lastQuery: DocumentNode;\n\n  private linkSubscription?: Subscription;\n\n  private pollingInfo?: {\n    interval: number;\n    timeout: ReturnType<typeof setTimeout>;\n  };\n\n  private get networkStatus(): NetworkStatus {\n    return this.subject.getValue().result.networkStatus;\n  }\n\n  constructor({\n    queryManager,\n    options,\n    transformedQuery = queryManager.transform(options.query),\n  }: {\n    queryManager: QueryManager;\n    options: ApolloClient.WatchQueryOptions<TData, TVariables>;\n    transformedQuery?: DocumentNode | TypedDocumentNode<TData, TVariables>;\n    queryId?: string;\n  }) {\n    this.queryManager = queryManager;\n\n    // active state\n    this.waitForNetworkResult = options.fetchPolicy === \"network-only\";\n    this.isTornDown = false;\n\n    this.subscribeToMore = this.subscribeToMore.bind(this);\n    this.maskResult = this.maskResult.bind(this);\n\n    const {\n      watchQuery: { fetchPolicy: defaultFetchPolicy = \"cache-first\" } = {},\n    } = queryManager.defaultOptions;\n\n    const {\n      fetchPolicy = defaultFetchPolicy,\n      // Make sure we don't store \"standby\" as the initialFetchPolicy.\n      initialFetchPolicy = fetchPolicy === \"standby\" ? defaultFetchPolicy : (\n        fetchPolicy\n      ),\n    } = options;\n\n    this.lastQuery = transformedQuery;\n\n    this.options = {\n      ...options,\n\n      // Remember the initial options.fetchPolicy so we can revert back to this\n      // policy when variables change. This information can also be specified\n      // (or overridden) by providing options.initialFetchPolicy explicitly.\n      initialFetchPolicy,\n\n      // This ensures this.options.fetchPolicy always has a string value, in\n      // case options.fetchPolicy was not provided.\n      fetchPolicy,\n      variables: this.getVariablesWithDefaults(options.variables),\n    };\n\n    this.initializeObservablesQueue();\n\n    this[\"@@observable\"] = () => this;\n    if (Symbol.observable) {\n      this[Symbol.observable] = () => this;\n    }\n\n    const opDef = getOperationDefinition(this.query);\n    this.queryName = opDef && opDef.name && opDef.name.value;\n  }\n\n  private initializeObservablesQueue() {\n    this.subject = new BehaviorSubject<\n      SubjectValue<MaybeMasked<TData>, TVariables>\n    >({\n      query: this.query,\n      variables: this.variables,\n      result: uninitialized,\n      meta: {},\n    });\n    const observable = this.subject.pipe(\n      tap({\n        subscribe: () => {\n          if (!this.subject.observed) {\n            this.reobserve();\n\n            // TODO: See if we can rework updatePolling to better handle this.\n            // reobserve calls updatePolling but this `subscribe` callback is\n            // called before the subject is subscribed to so `updatePolling`\n            // can't accurately detect if there is an active subscription.\n            // Calling it again here ensures that it can detect if it can poll\n            setTimeout(() => this.updatePolling());\n          }\n        },\n        unsubscribe: () => {\n          if (!this.subject.observed) {\n            this.tearDownQuery();\n          }\n        },\n      }),\n      filterMap(\n        (\n          { query, variables, result: current, meta },\n          context: {\n            previous?: ObservableQuery.Result<TData>;\n            previousVariables?: TVariables;\n          }\n        ) => {\n          const { shouldEmit } = meta;\n\n          if (current === uninitialized) {\n            // reset internal state after `ObservableQuery.reset()`\n            context.previous = undefined;\n            context.previousVariables = undefined;\n          }\n          if (\n            this.options.fetchPolicy === \"standby\" ||\n            shouldEmit === EmitBehavior.never\n          )\n            return;\n          if (shouldEmit === EmitBehavior.force) return emit();\n\n          const { previous, previousVariables } = context;\n\n          if (previous) {\n            const documentInfo = this.queryManager.getDocumentInfo(query);\n            const dataMasking = this.queryManager.dataMasking;\n            const maskedQuery =\n              dataMasking ? documentInfo.nonReactiveQuery : query;\n\n            const resultIsEqual =\n              dataMasking || documentInfo.hasNonreactiveDirective ?\n                equalByQuery(maskedQuery, previous, current, variables)\n              : equal(previous, current);\n\n            if (resultIsEqual && equal(previousVariables, variables)) {\n              return;\n            }\n          }\n\n          if (\n            shouldEmit === EmitBehavior.networkStatusChange &&\n            (!this.options.notifyOnNetworkStatusChange ||\n              equal(previous, current))\n          ) {\n            return;\n          }\n          return emit();\n\n          function emit() {\n            context.previous = current;\n            context.previousVariables = variables;\n            return current;\n          }\n        },\n        () => ({})\n      )\n    );\n\n    this.pipe = observable.pipe.bind(observable);\n    this.subscribe = observable.subscribe.bind(observable);\n\n    this.input = new Subject();\n    // we want to feed many streams into `this.subject`, but none of them should\n    // be able to close `this.input`\n    this.input.complete = () => {};\n    this.input.pipe(this.operator).subscribe(this.subject);\n  }\n\n  // We can't use Observable['subscribe'] here as the type as it conflicts with\n  // the ability to infer T from Subscribable<T>. This limits the surface area\n  // to the non-deprecated signature which works properly with type inference.\n  /**\n   * Subscribes to the `ObservableQuery`.\n   * @param observerOrNext - Either an RxJS `Observer` with some or all callback methods,\n   * or the `next` handler that is called for each value emitted from the subscribed Observable.\n   * @returns A subscription reference to the registered handlers.\n   */\n  public subscribe!: (\n    observerOrNext:\n      | Partial<Observer<ObservableQuery.Result<MaybeMasked<TData>>>>\n      | ((value: ObservableQuery.Result<MaybeMasked<TData>>) => void)\n  ) => Subscription;\n\n  /**\n   * Used to stitch together functional operators into a chain.\n   *\n   * @example\n   *\n   * ```ts\n   * import { filter, map } from 'rxjs';\n   *\n   * observableQuery\n   *   .pipe(\n   *     filter(...),\n   *     map(...),\n   *   )\n   *   .subscribe(x => console.log(x));\n   * ```\n   *\n   * @returns The Observable result of all the operators having been called\n   * in the order they were passed in.\n   */\n  public pipe!: Observable<ObservableQuery.Result<MaybeMasked<TData>>>[\"pipe\"];\n\n  public [Symbol.observable]!: () => Subscribable<\n    ObservableQuery.Result<MaybeMasked<TData>>\n  >;\n  public [\"@@observable\"]: () => Subscribable<\n    ObservableQuery.Result<MaybeMasked<TData>>\n  >;\n\n  /**\n   * @internal\n   */\n  public getCacheDiff({ optimistic = true } = {}) {\n    return this.queryManager.cache.diff<TData>({\n      query: this.query,\n      variables: this.variables,\n      returnPartialData: true,\n      optimistic,\n    });\n  }\n\n  private getInitialResult(\n    initialFetchPolicy?: WatchQueryFetchPolicy\n  ): ObservableQuery.Result<MaybeMasked<TData>> {\n    const fetchPolicy =\n      this.queryManager.prioritizeCacheValues ?\n        \"cache-first\"\n      : initialFetchPolicy || this.options.fetchPolicy;\n\n    const cacheResult = (): ObservableQuery.Result<TData> => {\n      const diff = this.getCacheDiff();\n      // TODO: queryInfo.getDiff should handle this since cache.diff returns a\n      // null when returnPartialData is false\n      const data =\n        this.options.returnPartialData || diff.complete ?\n          (diff.result as TData) ?? undefined\n        : undefined;\n\n      return this.maskResult({\n        data,\n        dataState:\n          diff.complete ? \"complete\"\n          : data === undefined ? \"empty\"\n          : \"partial\",\n        loading: !diff.complete,\n        networkStatus:\n          diff.complete ? NetworkStatus.ready : NetworkStatus.loading,\n        partial: !diff.complete,\n      } as ObservableQuery.Result<TData>);\n    };\n\n    switch (fetchPolicy) {\n      case \"cache-only\": {\n        return {\n          ...cacheResult(),\n          loading: false,\n          networkStatus: NetworkStatus.ready,\n        };\n      }\n      case \"cache-first\":\n        return cacheResult();\n      case \"cache-and-network\":\n        return {\n          ...cacheResult(),\n          loading: true,\n          networkStatus: NetworkStatus.loading,\n        };\n      case \"standby\":\n        return empty;\n\n      default:\n        return uninitialized;\n    }\n  }\n\n  private resubscribeCache() {\n    const { variables, fetchPolicy } = this.options;\n    const query = this.query;\n\n    const shouldUnsubscribe =\n      fetchPolicy === \"standby\" ||\n      fetchPolicy === \"no-cache\" ||\n      this.waitForNetworkResult;\n\n    const shouldResubscribe =\n      !isEqualQuery({ query, variables }, this.unsubscribeFromCache) &&\n      !this.waitForNetworkResult;\n\n    if (shouldUnsubscribe || shouldResubscribe) {\n      this.unsubscribeFromCache?.();\n    }\n\n    if (shouldUnsubscribe || !shouldResubscribe) {\n      return;\n    }\n\n    const watch: ObservableQuery.CacheWatchOptions<TData, TVariables> = {\n      query,\n      variables,\n      optimistic: true,\n      watcher: this,\n      callback: (diff) => {\n        const info = this.queryManager.getDocumentInfo(query);\n        if (info.hasClientExports || info.hasForcedResolvers) {\n          // If this is not set to something different than `diff`, we will\n          // not be notified about future cache changes with an equal `diff`.\n          // That would be the case if we are working with client-only fields\n          // that are forced or with `exports` fields that might change, causing\n          // local resovlers to return a new result.\n          // This is based on an implementation detail of `InMemoryCache`, which\n          // is not optimal - but the only alternative to this would be to\n          // resubscribe to the cache asynchonouly, which would bear the risk of\n          // missing further synchronous updates.\n          watch.lastDiff = undefined;\n        }\n        if (watch.lastOwnDiff === diff) {\n          // skip cache updates that were caused by our own writes\n          return;\n        }\n\n        const { result: previousResult } = this.subject.getValue();\n\n        if (\n          !diff.complete &&\n          // If we are trying to deliver an incomplete cache result, we avoid\n          // reporting it if the query has errored, otherwise we let the broadcast try\n          // and repair the partial result by refetching the query. This check avoids\n          // a situation where a query that errors and another succeeds with\n          // overlapping data does not report the partial data result to the errored\n          // query.\n          //\n          // See https://github.com/apollographql/apollo-client/issues/11400 for more\n          // information on this issue.\n          (previousResult.error ||\n            // Prevent to schedule a notify directly after the `ObservableQuery`\n            // has been `reset` (which will set the `previousResult` to `uninitialized` or `empty`)\n            // as in those cases, `resetCache` will manually call `refetch` with more intentional timing.\n            previousResult === uninitialized ||\n            previousResult === empty)\n        ) {\n          return;\n        }\n\n        if (!equal(previousResult.data, diff.result)) {\n          this.scheduleNotify();\n        }\n      },\n    };\n    const cancelWatch = this.queryManager.cache.watch(watch);\n\n    this.unsubscribeFromCache = Object.assign(\n      () => {\n        this.unsubscribeFromCache = undefined;\n        cancelWatch();\n      },\n      { query, variables }\n    );\n  }\n\n  private stableLastResult?: ObservableQuery.Result<MaybeMasked<TData>>;\n  public getCurrentResult(): ObservableQuery.Result<MaybeMasked<TData>> {\n    const { result: current } = this.subject.getValue();\n    let value =\n      (\n        // if the `current` result is in an error state, we will always return that\n        // error state, even if we have no observers\n        current.networkStatus === NetworkStatus.error ||\n        // if we have observers, we are watching the cache and\n        // this.subject.getValue() will always be up to date\n        this.hasObservers() ||\n        // if we are using a `no-cache` fetch policy in which case this\n        // `ObservableQuery` cannot have been updated from the outside - in\n        // that case, we prefer to keep the current value\n        this.options.fetchPolicy === \"no-cache\"\n      ) ?\n        current\n        // otherwise, the `current` value might be outdated due to missed\n        // external updates - calculate it again\n      : this.getInitialResult();\n\n    if (value === uninitialized) {\n      value = this.getInitialResult();\n    }\n    if (!equal(this.stableLastResult, value)) {\n      this.stableLastResult = value;\n    }\n    return this.stableLastResult!;\n  }\n\n  /**\n   * Update the variables of this observable query, and fetch the new results.\n   * This method should be preferred over `setVariables` in most use cases.\n   *\n   * Returns a `ResultPromise` with an additional `.retain()` method. Calling\n   * `.retain()` keeps the network operation running even if the `ObservableQuery`\n   * no longer requires the result.\n   *\n   * Note: `refetch()` guarantees that a value will be emitted from the\n   * observable, even if the result is deep equal to the previous value.\n   *\n   * @param variables - The new set of variables. If there are missing variables,\n   * the previous values of those variables will be used.\n   */\n  public refetch(\n    variables?: Partial<TVariables>\n  ): ObservableQuery.ResultPromise<ApolloClient.QueryResult<TData>> {\n    const { fetchPolicy } = this.options;\n\n    const reobserveOptions: Partial<\n      ObservableQuery.Options<TData, TVariables>\n    > = {\n      // Always disable polling for refetches.\n      pollInterval: 0,\n    };\n\n    // Unless the provided fetchPolicy always consults the network\n    // (no-cache, network-only, or cache-and-network), override it with\n    // network-only to force the refetch for this fetchQuery call.\n    if (fetchPolicy === \"no-cache\") {\n      reobserveOptions.fetchPolicy = \"no-cache\";\n    } else {\n      reobserveOptions.fetchPolicy = \"network-only\";\n    }\n\n    if (__DEV__ && variables && hasOwnProperty.call(variables, \"variables\")) {\n      const queryDef = getQueryDefinition(this.query);\n      const vars = queryDef.variableDefinitions;\n      if (!vars || !vars.some((v) => v.variable.name.value === \"variables\")) {\n        invariant.warn(\n          `Called refetch(%o) for query %o, which does not declare a $variables variable.\nDid you mean to call refetch(variables) instead of refetch({ variables })?`,\n          variables,\n          queryDef.name?.value || queryDef\n        );\n      }\n    }\n\n    if (variables && !equal(this.variables, variables)) {\n      // Update the existing options with new variables\n      reobserveOptions.variables = this.options.variables =\n        this.getVariablesWithDefaults({ ...this.variables, ...variables });\n    }\n\n    this._lastWrite = undefined;\n    return this._reobserve(reobserveOptions, {\n      newNetworkStatus: NetworkStatus.refetch,\n    });\n  }\n\n  /**\n   * A function that helps you fetch the next set of results for a [paginated list field](https://www.apollographql.com/docs/react/pagination/core-api/).\n   */\n  public fetchMore<\n    TFetchData = TData,\n    TFetchVars extends OperationVariables = TVariables,\n  >(\n    options: ObservableQuery.FetchMoreOptions<\n      TData,\n      TVariables,\n      TFetchData,\n      TFetchVars\n    >\n  ): Promise<ApolloClient.QueryResult<TFetchData>>;\n  public fetchMore<\n    TFetchData = TData,\n    TFetchVars extends OperationVariables = TVariables,\n  >({\n    query,\n    variables,\n    context,\n    errorPolicy,\n    updateQuery,\n  }: ObservableQuery.FetchMoreOptions<\n    TData,\n    TVariables,\n    TFetchData,\n    TFetchVars\n  >): Promise<ApolloClient.QueryResult<TFetchData>> {\n    invariant(\n      this.options.fetchPolicy !== \"cache-only\",\n      \"Cannot execute `fetchMore` for 'cache-only' query '%s'. Please use a different fetch policy.\",\n      getOperationName(this.query, \"(anonymous)\")\n    );\n    const combinedOptions = {\n      ...compact(\n        this.options,\n        { errorPolicy: \"none\" },\n        {\n          query,\n          context,\n          errorPolicy,\n        }\n      ),\n      variables: (query ? variables : (\n        {\n          ...this.variables,\n          ...variables,\n        }\n      )) as TFetchVars,\n      // The fetchMore request goes immediately to the network and does\n      // not automatically write its result to the cache (hence no-cache\n      // instead of network-only), because we allow the caller of\n      // fetchMore to provide an updateQuery callback that determines how\n      // the data gets written to the cache.\n      fetchPolicy: \"no-cache\",\n      notifyOnNetworkStatusChange: this.options.notifyOnNetworkStatusChange,\n    } as ApolloClient.QueryOptions<TFetchData, TFetchVars>;\n\n    combinedOptions.query = this.transformDocument(combinedOptions.query);\n\n    // If a temporary query is passed to `fetchMore`, we don't want to store\n    // it as the last query result since it may be an optimized query for\n    // pagination. We will however run the transforms on the original document\n    // as well as the document passed in `fetchMoreOptions` to ensure the cache\n    // uses the most up-to-date document which may rely on runtime conditionals.\n    this.lastQuery =\n      query ?\n        this.transformDocument(this.options.query)\n      : combinedOptions.query;\n\n    let wasUpdated = false;\n\n    const isCached = this.options.fetchPolicy !== \"no-cache\";\n\n    if (!isCached) {\n      invariant(\n        updateQuery,\n        \"You must provide an `updateQuery` function when using `fetchMore` with a `no-cache` fetch policy.\"\n      );\n    }\n\n    const { finalize, pushNotification } = this.pushOperation(\n      NetworkStatus.fetchMore\n    );\n    pushNotification(\n      {\n        source: \"newNetworkStatus\",\n        kind: \"N\",\n        value: {},\n      },\n      { shouldEmit: EmitBehavior.networkStatusChange }\n    );\n    return this.queryManager\n      .fetchQuery(combinedOptions, NetworkStatus.fetchMore)\n      .then((fetchMoreResult) => {\n        // disable the `fetchMore` override that is currently active\n        // the next updates caused by this should not be `fetchMore` anymore,\n        // but `ready` or whatever other calculated loading state is currently\n        // appropriate\n        finalize();\n\n        if (isCached) {\n          // Performing this cache update inside a cache.batch transaction ensures\n          // any affected cache.watch watchers are notified at most once about any\n          // updates. Most watchers will be using the QueryInfo class, which\n          // responds to notifications by calling reobserveCacheFirst to deliver\n          // fetchMore cache results back to this ObservableQuery.\n          this.queryManager.cache.batch({\n            update: (cache) => {\n              if (updateQuery) {\n                cache.updateQuery(\n                  {\n                    query: this.query,\n                    variables: this.variables,\n                    returnPartialData: true,\n                    optimistic: false,\n                  },\n                  (previous) =>\n                    updateQuery(previous! as any, {\n                      fetchMoreResult: fetchMoreResult.data as any,\n                      variables: combinedOptions.variables as TFetchVars,\n                    })\n                );\n              } else {\n                // If we're using a field policy instead of updateQuery, the only\n                // thing we need to do is write the new data to the cache using\n                // combinedOptions.variables (instead of this.variables, which is\n                // what this.updateQuery uses, because it works by abusing the\n                // original field value, keyed by the original variables).\n                cache.writeQuery({\n                  query: combinedOptions.query,\n                  variables: combinedOptions.variables,\n                  data: fetchMoreResult.data as Unmasked<any>,\n                });\n              }\n            },\n\n            onWatchUpdated: (watch) => {\n              if (watch.watcher === this) {\n                wasUpdated = true;\n              }\n            },\n          });\n        } else {\n          // There is a possibility `lastResult` may not be set when\n          // `fetchMore` is called which would cause this to crash. This should\n          // only happen if we haven't previously reported a result. We don't\n          // quite know what the right behavior should be here since this block\n          // of code runs after the fetch result has executed on the network.\n          // We plan to let it crash in the meantime.\n          //\n          // If we get bug reports due to the `data` property access on\n          // undefined, this should give us a real-world scenario that we can\n          // use to test against and determine the right behavior. If we do end\n          // up changing this behavior, this may require, for example, an\n          // adjustment to the types on `updateQuery` since that function\n          // expects that the first argument always contains previous result\n          // data, but not `undefined`.\n          const lastResult = this.getCurrentResult();\n          const data = updateQuery!(lastResult.data as Unmasked<TData>, {\n            fetchMoreResult: fetchMoreResult.data as Unmasked<TFetchData>,\n            variables: combinedOptions.variables as TFetchVars,\n          });\n          // was reportResult\n          pushNotification({\n            kind: \"N\",\n            value: {\n              ...lastResult,\n              networkStatus: NetworkStatus.ready,\n              // will be overwritten anyways, just here for types sake\n              loading: false,\n              data: data as any,\n              dataState:\n                lastResult.dataState === \"streaming\" ? \"streaming\" : \"complete\",\n            },\n            source: \"network\",\n          });\n        }\n\n        return this.maskResult(fetchMoreResult);\n      })\n      .finally(() => {\n        // call `finalize` a second time in case the `.then` case above was not reached\n        finalize();\n\n        // In case the cache writes above did not generate a broadcast\n        // notification (which would have been intercepted by onWatchUpdated),\n        // likely because the written data were the same as what was already in\n        // the cache, we still want fetchMore to deliver its final loading:false\n        // result with the unchanged data.\n        if (isCached && !wasUpdated) {\n          pushNotification(\n            {\n              kind: \"N\",\n              source: \"newNetworkStatus\",\n              value: {},\n            },\n            { shouldEmit: EmitBehavior.force }\n          );\n        }\n      });\n  }\n\n  // XXX the subscription variables are separate from the query variables.\n  // if you want to update subscription variables, right now you have to do that separately,\n  // and you can only do it by stopping the subscription and then subscribing again with new variables.\n  /**\n   * A function that enables you to execute a [subscription](https://www.apollographql.com/docs/react/data/subscriptions/), usually to subscribe to specific fields that were included in the query.\n   *\n   * This function returns _another_ function that you can call to terminate the subscription.\n   */\n  public subscribeToMore<\n    TSubscriptionData = TData,\n    TSubscriptionVariables extends OperationVariables = TVariables,\n  >(\n    options: ObservableQuery.SubscribeToMoreOptions<\n      TData,\n      TSubscriptionVariables,\n      TSubscriptionData,\n      TVariables\n    >\n  ): () => void {\n    const subscription = this.queryManager\n      .startGraphQLSubscription({\n        query: options.document,\n        variables: options.variables,\n        context: options.context,\n      })\n      .subscribe({\n        next: (subscriptionData) => {\n          const { updateQuery, onError } = options;\n          const { error } = subscriptionData;\n\n          if (error) {\n            if (onError) {\n              onError(error);\n            } else {\n              invariant.error(\"Unhandled GraphQL subscription error\", error);\n            }\n\n            return;\n          }\n\n          if (updateQuery) {\n            this.updateQuery((previous, updateOptions) =>\n              updateQuery(previous, {\n                subscriptionData: subscriptionData as {\n                  data: Unmasked<TSubscriptionData>;\n                },\n                ...updateOptions,\n              })\n            );\n          }\n        },\n      });\n\n    this.subscriptions.add(subscription);\n\n    return () => {\n      if (this.subscriptions.delete(subscription)) {\n        subscription.unsubscribe();\n      }\n    };\n  }\n\n  /** @internal */\n  public applyOptions(\n    newOptions: Partial<ObservableQuery.Options<TData, TVariables>>\n  ): void {\n    const mergedOptions = compact(this.options, newOptions || {});\n    assign(this.options, mergedOptions);\n    this.updatePolling();\n  }\n\n  /**\n   * Update the variables of this observable query, and fetch the new results\n   * if they've changed. Most users should prefer `refetch` instead of\n   * `setVariables` in order to to be properly notified of results even when\n   * they come from the cache.\n   *\n   * Note: `setVariables()` guarantees that a value will be emitted from the\n   * observable, even if the result is deeply equal to the previous value.\n   *\n   * Note: the promise will resolve with the last emitted result\n   * when either the variables match the current variables or there\n   * are no subscribers to the query.\n   *\n   * @param variables - The new set of variables. If there are missing variables,\n   * the previous values of those variables will be used.\n   */\n  public async setVariables(\n    variables: TVariables\n  ): Promise<ApolloClient.QueryResult<TData>> {\n    variables = this.getVariablesWithDefaults(variables);\n\n    if (equal(this.variables, variables)) {\n      // If we have no observers, then we don't actually want to make a network\n      // request. As soon as someone observes the query, the request will kick\n      // off. For now, we just store any changes. (See #1077)\n      return toQueryResult(this.getCurrentResult());\n    }\n\n    this.options.variables = variables;\n\n    // See comment above\n    if (!this.hasObservers()) {\n      return toQueryResult(this.getCurrentResult());\n    }\n\n    return this._reobserve(\n      {\n        // Reset options.fetchPolicy to its original value.\n        fetchPolicy: this.options.initialFetchPolicy,\n        variables,\n      },\n      { newNetworkStatus: NetworkStatus.setVariables }\n    );\n  }\n\n  /**\n   * A function that enables you to update the query's cached result without executing a followup GraphQL operation.\n   *\n   * See [using updateQuery and updateFragment](https://www.apollographql.com/docs/react/caching/cache-interaction/#using-updatequery-and-updatefragment) for additional information.\n   */\n  public updateQuery(mapFn: UpdateQueryMapFn<TData, TVariables>): void {\n    const { queryManager } = this;\n    const { result, complete } = this.getCacheDiff({ optimistic: false });\n\n    const newResult = mapFn(\n      result! as DeepPartial<Unmasked<TData>>,\n      {\n        variables: this.variables,\n        complete: !!complete,\n        previousData: result,\n      } as UpdateQueryOptions<TData, TVariables>\n    );\n\n    if (newResult) {\n      queryManager.cache.writeQuery({\n        query: this.options.query,\n        data: newResult,\n        variables: this.variables,\n      });\n\n      queryManager.broadcastQueries();\n    }\n  }\n\n  /**\n   * A function that instructs the query to begin re-executing at a specified interval (in milliseconds).\n   */\n  public startPolling(pollInterval: number) {\n    this.options.pollInterval = pollInterval;\n    this.updatePolling();\n  }\n\n  /**\n   * A function that instructs the query to stop polling after a previous call to `startPolling`.\n   */\n  public stopPolling() {\n    this.options.pollInterval = 0;\n    this.updatePolling();\n  }\n\n  // Update options.fetchPolicy according to options.nextFetchPolicy.\n  private applyNextFetchPolicy(\n    reason: NextFetchPolicyContext<TData, TVariables>[\"reason\"],\n    // It's possible to use this method to apply options.nextFetchPolicy to\n    // options.fetchPolicy even if options !== this.options, though that happens\n    // most often when the options are temporary, used for only one request and\n    // then thrown away, so nextFetchPolicy may not end up mattering.\n    options: ApolloClient.WatchQueryOptions<TData, TVariables>\n  ) {\n    if (options.nextFetchPolicy) {\n      const { fetchPolicy = \"cache-first\", initialFetchPolicy = fetchPolicy } =\n        options;\n\n      if (fetchPolicy === \"standby\") {\n        // Do nothing, leaving options.fetchPolicy unchanged.\n      } else if (typeof options.nextFetchPolicy === \"function\") {\n        // When someone chooses \"cache-and-network\" or \"network-only\" as their\n        // initial FetchPolicy, they often do not want future cache updates to\n        // trigger unconditional network requests, which is what repeatedly\n        // applying the \"cache-and-network\" or \"network-only\" policies would\n        // seem to imply. Instead, when the cache reports an update after the\n        // initial network request, it may be desirable for subsequent network\n        // requests to be triggered only if the cache result is incomplete. To\n        // that end, the options.nextFetchPolicy option provides an easy way to\n        // update options.fetchPolicy after the initial network request, without\n        // having to call observableQuery.reobserve.\n        options.fetchPolicy = options.nextFetchPolicy.call(\n          options as any,\n          fetchPolicy,\n          { reason, options, observable: this, initialFetchPolicy }\n        );\n      } else if (reason === \"variables-changed\") {\n        options.fetchPolicy = initialFetchPolicy;\n      } else {\n        options.fetchPolicy = options.nextFetchPolicy;\n      }\n    }\n\n    return options.fetchPolicy;\n  }\n\n  private fetch(\n    options: ObservableQuery.Options<TData, TVariables>,\n    networkStatus: NetworkStatus,\n    fetchQuery: DocumentNode,\n    operator: MonoTypeOperatorFunction<QueryNotification.Value<TData>>\n  ) {\n    // TODO Make sure we update the networkStatus (and infer fetchVariables)\n    // before actually committing to the fetch.\n    const initialFetchPolicy = this.options.fetchPolicy;\n    options.context ??= {};\n\n    let synchronouslyEmitted = false;\n    const onCacheHit = () => {\n      synchronouslyEmitted = true;\n    };\n    const fetchQueryOperator = // we cannot use `tap` here, since it allows only for a \"before subscription\"\n      // hook with `subscribe` and we care for \"directly before and after subscription\"\n      <T>(source: Observable<T>) =>\n        new Observable<T>((subscriber) => {\n          try {\n            return source.subscribe({\n              next(value) {\n                synchronouslyEmitted = true;\n                subscriber.next(value);\n              },\n              error: (error) => subscriber.error(error),\n              complete: () => subscriber.complete(),\n            });\n          } finally {\n            if (!synchronouslyEmitted) {\n              operation.override = networkStatus;\n              this.input.next({\n                kind: \"N\",\n                source: \"newNetworkStatus\",\n                value: {\n                  resetError: true,\n                },\n                query,\n                variables,\n                meta: {\n                  shouldEmit: EmitBehavior.networkStatusChange,\n                  /*\n                   * The moment this notification is emitted, `nextFetchPolicy`\n                   * might already have switched from a `network-only` to a\n                   * `cache-something` policy, so we want to ensure that the\n                   * loading state emit doesn't accidentally read from the cache\n                   * in those cases.\n                   */\n                  fetchPolicy: initialFetchPolicy,\n                },\n              });\n            }\n          }\n        });\n\n    let { observable, fromLink } = this.queryManager.fetchObservableWithInfo(\n      options,\n      {\n        networkStatus,\n        query: fetchQuery,\n        onCacheHit,\n        fetchQueryOperator,\n        observableQuery: this,\n      }\n    );\n\n    // track query and variables from the start of the operation\n    const { query, variables } = this;\n    const operation: TrackedOperation = {\n      abort: () => {\n        subscription.unsubscribe();\n      },\n      query,\n      variables,\n    };\n    this.activeOperations.add(operation);\n\n    let forceFirstValueEmit =\n      networkStatus == NetworkStatus.refetch ||\n      networkStatus == NetworkStatus.setVariables;\n    observable = observable.pipe(operator, share());\n    const subscription = observable\n      .pipe(\n        tap({\n          next: (notification) => {\n            if (\n              notification.source === \"newNetworkStatus\" ||\n              (notification.kind === \"N\" && notification.value.loading)\n            ) {\n              operation.override = networkStatus;\n            } else {\n              delete operation.override;\n            }\n          },\n          finalize: () => this.activeOperations.delete(operation),\n        })\n      )\n      .subscribe({\n        next: (value) => {\n          const meta: Meta = {};\n\n          if (\n            forceFirstValueEmit &&\n            value.kind === \"N\" &&\n            \"loading\" in value.value &&\n            !value.value.loading\n          ) {\n            forceFirstValueEmit = false;\n            meta.shouldEmit = EmitBehavior.force;\n          }\n\n          this.input.next({ ...value, query, variables, meta });\n        },\n      });\n\n    return { fromLink, subscription, observable };\n  }\n\n  // Turns polling on or off based on this.options.pollInterval.\n  private didWarnCacheOnlyPolling = false;\n  private updatePolling() {\n    // Avoid polling in SSR mode\n    if (this.queryManager.ssrMode) {\n      return;\n    }\n\n    const {\n      pollingInfo,\n      options: { fetchPolicy, pollInterval },\n    } = this;\n\n    if (!pollInterval || !this.hasObservers() || fetchPolicy === \"cache-only\") {\n      if (__DEV__) {\n        if (\n          !this.didWarnCacheOnlyPolling &&\n          pollInterval &&\n          fetchPolicy === \"cache-only\"\n        ) {\n          invariant.warn(\n            \"Cannot poll on 'cache-only' query '%s' and as such, polling is disabled. Please use a different fetch policy.\",\n            getOperationName(this.query, \"(anonymous)\")\n          );\n          this.didWarnCacheOnlyPolling = true;\n        }\n      }\n\n      this.cancelPolling();\n      return;\n    }\n\n    if (pollingInfo?.interval === pollInterval) {\n      return;\n    }\n\n    const info = pollingInfo || (this.pollingInfo = {} as any);\n    info.interval = pollInterval;\n\n    const maybeFetch = () => {\n      if (this.pollingInfo) {\n        if (\n          !isNetworkRequestInFlight(this.networkStatus) &&\n          !this.options.skipPollAttempt?.()\n        ) {\n          this._reobserve(\n            {\n              // Most fetchPolicy options don't make sense to use in a polling context, as\n              // users wouldn't want to be polling the cache directly. However, network-only and\n              // no-cache are both useful for when the user wants to control whether or not the\n              // polled results are written to the cache.\n              fetchPolicy:\n                this.options.initialFetchPolicy === \"no-cache\" ?\n                  \"no-cache\"\n                : \"network-only\",\n            },\n            {\n              newNetworkStatus: NetworkStatus.poll,\n            }\n          ).then(poll, poll);\n        } else {\n          poll();\n        }\n      }\n    };\n\n    const poll = () => {\n      const info = this.pollingInfo;\n      if (info) {\n        clearTimeout(info.timeout);\n        info.timeout = setTimeout(maybeFetch, info.interval);\n      }\n    };\n\n    poll();\n  }\n\n  // This differs from stopPolling in that it does not set pollInterval to 0\n  private cancelPolling() {\n    if (this.pollingInfo) {\n      clearTimeout(this.pollingInfo.timeout);\n      delete this.pollingInfo;\n    }\n  }\n\n  /**\n   * Reevaluate the query, optionally against new options. New options will be\n   * merged with the current options when given.\n   *\n   * Note: `variables` can be reset back to their defaults (typically empty) by calling `reobserve` with\n   * `variables: undefined`.\n   */\n  public reobserve(\n    newOptions?: Partial<ObservableQuery.Options<TData, TVariables>>\n  ): ObservableQuery.ResultPromise<\n    ApolloClient.QueryResult<MaybeMasked<TData>>\n  > {\n    return this._reobserve(newOptions);\n  }\n  private _reobserve(\n    newOptions?: Partial<ObservableQuery.Options<TData, TVariables>>,\n    internalOptions?: {\n      newNetworkStatus?: NetworkStatus;\n    }\n  ): ObservableQuery.ResultPromise<\n    ApolloClient.QueryResult<MaybeMasked<TData>>\n  > {\n    this.isTornDown = false;\n    let { newNetworkStatus } = internalOptions || {};\n\n    this.queryManager.obsQueries.add(this);\n\n    const useDisposableObservable =\n      // Refetching uses a disposable Observable to allow refetches using different\n      // options, without permanently altering the options of the\n      // original ObservableQuery.\n      newNetworkStatus === NetworkStatus.refetch ||\n      // Polling uses a disposable Observable so the polling options (which force\n      // fetchPolicy to be \"network-only\" or \"no-cache\") won't override the original options.\n      newNetworkStatus === NetworkStatus.poll;\n\n    // Save the old variables, since Object.assign may modify them below.\n    const oldVariables = this.variables;\n    const oldFetchPolicy = this.options.fetchPolicy;\n\n    const mergedOptions = compact(this.options, newOptions || {});\n    const options =\n      useDisposableObservable ?\n        // Disposable Observable fetches receive a shallow copy of this.options\n        // (merged with newOptions), leaving this.options unmodified.\n        mergedOptions\n      : assign(this.options, mergedOptions);\n\n    // Don't update options.query with the transformed query to avoid\n    // overwriting this.options.query when we aren't using a disposable concast.\n    // We want to ensure we can re-run the custom document transforms the next\n    // time a request is made against the original query.\n    const query = this.transformDocument(options.query);\n\n    this.lastQuery = query;\n\n    // Reevaluate variables to allow resetting variables with variables: undefined,\n    // otherwise `compact` will ignore the `variables` key in `newOptions`. We\n    // do this after we run the query transform to ensure we get default\n    // variables from the transformed query.\n    //\n    // Note: updating options.variables may mutate this.options.variables\n    // in the case of a non-disposable query. This is intentional.\n    if (newOptions && \"variables\" in newOptions) {\n      options.variables = this.getVariablesWithDefaults(newOptions.variables);\n    }\n\n    if (!useDisposableObservable) {\n      // We can skip calling updatePolling if we're not changing this.options.\n      this.updatePolling();\n\n      // Reset options.fetchPolicy to its original value when variables change,\n      // unless a new fetchPolicy was provided by newOptions.\n      if (\n        newOptions &&\n        newOptions.variables &&\n        !equal(newOptions.variables, oldVariables) &&\n        // Don't mess with the fetchPolicy if it's currently \"standby\".\n        options.fetchPolicy !== \"standby\" &&\n        // If we're changing the fetchPolicy anyway, don't try to change it here\n        // using applyNextFetchPolicy. The explicit options.fetchPolicy wins.\n        (options.fetchPolicy === oldFetchPolicy ||\n          // A `nextFetchPolicy` function has even higher priority, though,\n          // so in that case `applyNextFetchPolicy` must be called.\n          typeof options.nextFetchPolicy === \"function\")\n      ) {\n        // This might mutate options.fetchPolicy\n        this.applyNextFetchPolicy(\"variables-changed\", options);\n        if (newNetworkStatus === void 0) {\n          newNetworkStatus = NetworkStatus.setVariables;\n        }\n      }\n    }\n\n    const oldNetworkStatus = this.networkStatus;\n\n    if (!newNetworkStatus) {\n      newNetworkStatus = NetworkStatus.loading;\n\n      if (\n        oldNetworkStatus !== NetworkStatus.loading &&\n        newOptions?.variables &&\n        !equal(newOptions.variables, oldVariables)\n      ) {\n        newNetworkStatus = NetworkStatus.setVariables;\n      }\n\n      // QueryManager does not emit any values for standby fetch policies so we\n      // want ensure that the networkStatus remains ready.\n      if (options.fetchPolicy === \"standby\") {\n        newNetworkStatus = NetworkStatus.ready;\n      }\n    }\n\n    if (options.fetchPolicy === \"standby\") {\n      this.cancelPolling();\n    }\n\n    this.resubscribeCache();\n    const { promise, operator: promiseOperator } = getTrackingOperatorPromise(\n      (value: QueryNotification.Value<TData>) => {\n        switch (value.kind) {\n          case \"E\":\n            throw value.error;\n          case \"N\":\n            if (value.source !== \"newNetworkStatus\" && !value.value.loading)\n              return value.value;\n        }\n      },\n      // This default value should only be used when using a `fetchPolicy` of\n      // `standby` since that fetch policy completes without emitting a\n      // result. Since we are converting this to a QueryResult type, we\n      // omit the extra fields from ApolloQueryResult in the default value.\n      options.fetchPolicy === \"standby\" ?\n        ({ data: undefined } as ObservableQuery.Result<TData>)\n      : undefined\n    );\n    const { subscription, observable, fromLink } = this.fetch(\n      options,\n      newNetworkStatus,\n      query,\n      promiseOperator\n    );\n\n    if (!useDisposableObservable && (fromLink || !this.linkSubscription)) {\n      if (this.linkSubscription) {\n        this.linkSubscription.unsubscribe();\n      }\n\n      this.linkSubscription = subscription;\n    }\n\n    const ret = Object.assign(\n      preventUnhandledRejection(\n        promise\n          .then((result) => toQueryResult(this.maskResult(result)))\n          .finally(() => {\n            if (!this.hasObservers() && this.activeOperations.size === 0) {\n              // If `reobserve` was called on a query without any obervers,\n              // the teardown logic would never be called, so we need to\n              // call it here to ensure the query is properly torn down.\n              this.tearDownQuery();\n            }\n          })\n      ),\n      {\n        retain: () => {\n          const subscription = observable.subscribe({});\n          const unsubscribe = () => subscription.unsubscribe();\n          promise.then(unsubscribe, unsubscribe);\n          return ret;\n        },\n      }\n    );\n    return ret;\n  }\n\n  public hasObservers() {\n    return this.subject.observed;\n  }\n\n  /**\n   * Tears down the `ObservableQuery` and stops all active operations by sending a `complete` notification.\n   */\n  public stop() {\n    this.subject.complete();\n    this.initializeObservablesQueue();\n    this.tearDownQuery();\n  }\n\n  private tearDownQuery() {\n    if (this.isTornDown) return;\n\n    this.resetNotifications();\n    this.unsubscribeFromCache?.();\n    if (this.linkSubscription) {\n      this.linkSubscription.unsubscribe();\n      delete this.linkSubscription;\n    }\n\n    this.stopPolling();\n    // stop all active GraphQL subscriptions\n    this.subscriptions.forEach((sub) => sub.unsubscribe());\n    this.subscriptions.clear();\n    this.queryManager.obsQueries.delete(this);\n    this.isTornDown = true;\n    this.abortActiveOperations();\n    this._lastWrite = undefined;\n  }\n\n  private transformDocument(document: DocumentNode) {\n    return this.queryManager.transform(document);\n  }\n\n  private maskResult<T extends { data: any }>(result: T): T {\n    const masked = this.queryManager.maskOperation({\n      document: this.query,\n      data: result.data,\n      fetchPolicy: this.options.fetchPolicy,\n      cause: this,\n    });\n\n    // Maintain object identity as much as possible\n    return masked === result.data ? result : { ...result, data: masked };\n  }\n\n  private dirty: boolean = false;\n\n  private notifyTimeout?: ReturnType<typeof setTimeout>;\n\n  /** @internal */\n  private resetNotifications() {\n    if (this.notifyTimeout) {\n      clearTimeout(this.notifyTimeout);\n      this.notifyTimeout = void 0;\n    }\n    this.dirty = false;\n  }\n\n  /** @internal */\n  private scheduleNotify() {\n    if (this.dirty) return;\n    this.dirty = true;\n    if (!this.notifyTimeout) {\n      this.notifyTimeout = setTimeout(() => this.notify(true), 0);\n    }\n  }\n\n  /** @internal */\n  public notify(scheduled = false) {\n    if (!scheduled) {\n      // For queries with client exports or forced resolvers, we don't want to\n      // synchronously reobserve the cache on broadcast,\n      // but actually wait for the `scheduleNotify` timeout triggered by the\n      // `cache.watch` callback from `resubscribeCache`.\n      const info = this.queryManager.getDocumentInfo(this.query);\n      if (info.hasClientExports || info.hasForcedResolvers) {\n        return;\n      }\n    }\n\n    const { dirty } = this;\n    this.resetNotifications();\n\n    if (\n      dirty &&\n      (this.options.fetchPolicy == \"cache-only\" ||\n        this.options.fetchPolicy == \"cache-and-network\" ||\n        !this.activeOperations.size)\n    ) {\n      const diff = this.getCacheDiff();\n      if (\n        // `fromOptimisticTransaction` is not avaiable through the `cache.diff`\n        // code path, so we need to check it this way\n        equal(diff.result, this.getCacheDiff({ optimistic: false }).result)\n      ) {\n        //If this diff did not come from an optimistic transaction\n        // make the ObservableQuery \"reobserve\" the latest data\n        // using a temporary fetch policy of \"cache-first\", so complete cache\n        // results have a chance to be delivered without triggering additional\n        // network requests, even when options.fetchPolicy is \"network-only\"\n        // or \"cache-and-network\". All other fetch policies are preserved by\n        // this method, and are handled by calling oq.reobserve(). If this\n        // reobservation is spurious, distinctUntilChanged still has a\n        // chance to catch it before delivery to ObservableQuery subscribers.\n        this.reobserveCacheFirst();\n      } else {\n        // If this diff came from an optimistic transaction, deliver the\n        // current cache data to the ObservableQuery, but don't perform a\n        // reobservation, since oq.reobserveCacheFirst might make a network\n        // request, and we never want to trigger network requests in the\n        // middle of optimistic updates.\n        this.input.next({\n          kind: \"N\",\n          value: {\n            data: diff.result,\n            dataState:\n              diff.complete ? \"complete\"\n              : diff.result ? \"partial\"\n              : \"empty\",\n            networkStatus: NetworkStatus.ready,\n            loading: false,\n            error: undefined,\n            partial: !diff.complete,\n          } as ObservableQuery.Result<TData>,\n          source: \"cache\",\n          query: this.query,\n          variables: this.variables,\n          meta: {},\n        });\n      }\n    }\n  }\n\n  private activeOperations = new Set<TrackedOperation>();\n  private pushOperation(networkStatus: NetworkStatus): {\n    finalize: () => void;\n    pushNotification: (\n      notification: QueryNotification.Value<TData>,\n      additionalMeta?: Omit<Meta, \"query\" | \"variables\">\n    ) => void;\n  } {\n    let aborted = false;\n    // track query and variables from the start of the operation\n    const { query, variables } = this;\n    const finalize = () => {\n      this.activeOperations.delete(operation);\n    };\n    const operation: TrackedOperation = {\n      override: networkStatus,\n      abort: () => {\n        aborted = true;\n        finalize();\n      },\n      query,\n      variables,\n    };\n    this.activeOperations.add(operation);\n    return {\n      finalize,\n      pushNotification: (\n        notification: QueryNotification.Value<TData>,\n        additionalMeta?: Meta\n      ) => {\n        if (!aborted) {\n          this.input.next({\n            ...notification,\n            query,\n            variables,\n            meta: { ...additionalMeta },\n          });\n        }\n      },\n    };\n  }\n\n  private calculateNetworkStatus(baseNetworkStatus: NetworkStatus) {\n    if (baseNetworkStatus === NetworkStatus.streaming) {\n      return baseNetworkStatus;\n    }\n    // in the future, this could be more complex logic, e.g. \"refetch\" and\n    // \"fetchMore\" having priority over \"polling\" or \"loading\" network statuses\n    // as for now we just take the \"latest\" operation that is still active,\n    // as that lines up best with previous behavior[]\n\n    const operation = Array.from(this.activeOperations.values()).findLast(\n      (operation) =>\n        isEqualQuery(operation, this) && operation.override !== undefined\n    );\n    return operation?.override ?? baseNetworkStatus;\n  }\n\n  private abortActiveOperations() {\n    this.activeOperations.forEach((operation) => operation.abort());\n  }\n\n  /**\n   * @internal\n   * Called from `clearStore`.\n   *\n   * - resets the query to its initial state\n   * - cancels all active operations and their subscriptions\n   */\n  public reset() {\n    // exception for cache-only queries - we reset them into a \"ready\" state\n    // as we won't trigger a refetch for them\n    const resetToEmpty = this.options.fetchPolicy === \"cache-only\";\n    this.setResult(resetToEmpty ? empty : uninitialized, {\n      shouldEmit: resetToEmpty ? EmitBehavior.force : EmitBehavior.never,\n    });\n\n    this.abortActiveOperations();\n  }\n\n  /** @internal */\n  private setResult(\n    result: ObservableQuery.Result<TData>,\n    additionalMeta?: Meta\n  ) {\n    this.input.next({\n      source: \"setResult\",\n      kind: \"N\",\n      value: result,\n      query: this.query,\n      variables: this.variables,\n      meta: { ...additionalMeta },\n    });\n  }\n\n  private operator: OperatorFunction<\n    QueryNotification.Value<TData> & {\n      query: DocumentNode | TypedDocumentNode<TData, TVariables>;\n      variables: TVariables;\n      meta: Meta;\n    },\n    SubjectValue<TData, TVariables>\n  > = filterMap((notification) => {\n    const { query, variables, meta } = notification;\n\n    if (notification.source === \"setResult\") {\n      return { query, variables, result: notification.value, meta };\n    }\n\n    if (notification.kind === \"C\" || !isEqualQuery(notification, this)) {\n      return;\n    }\n\n    let result: ObservableQuery.Result<TData>;\n    const previous = this.subject.getValue();\n\n    if (notification.source === \"cache\") {\n      result = notification.value;\n      if (\n        result.networkStatus === NetworkStatus.ready &&\n        result.partial &&\n        (!this.options.returnPartialData ||\n          previous.result.networkStatus === NetworkStatus.error) &&\n        this.options.fetchPolicy !== \"cache-only\"\n      ) {\n        return;\n      }\n    } else if (notification.source === \"network\") {\n      if (this.waitForNetworkResult) {\n        this.waitForNetworkResult = false;\n        this.resubscribeCache();\n      }\n      result =\n        notification.kind === \"E\" ?\n          ({\n            ...(isEqualQuery(previous, notification) ?\n              previous.result\n            : { data: undefined, dataState: \"empty\", partial: true }),\n            error: notification.error,\n            networkStatus: NetworkStatus.error,\n            loading: false,\n          } as ObservableQuery.Result<TData>)\n        : notification.value;\n\n      if (notification.kind === \"E\" && result.dataState === \"streaming\") {\n        result.dataState = \"complete\" as any;\n      }\n\n      if (result.error) {\n        meta.shouldEmit = EmitBehavior.force;\n      }\n    } else if (notification.source === \"newNetworkStatus\") {\n      const baseResult =\n        isEqualQuery(previous, notification) ?\n          previous.result\n        : this.getInitialResult(meta.fetchPolicy);\n      const { resetError } = notification.value;\n      const error = resetError ? undefined : baseResult.error;\n      const networkStatus = error ? NetworkStatus.error : NetworkStatus.ready;\n      result = {\n        ...baseResult,\n        error,\n        networkStatus,\n      };\n    }\n    // every code path until here should have either returned or set a result,\n    // but typescript needs a little help\n    invariant(result!);\n\n    // normalize result shape\n    if (!result.error) delete result.error;\n    result.networkStatus = this.calculateNetworkStatus(result.networkStatus);\n    result.loading = isNetworkRequestInFlight(result.networkStatus);\n    result = this.maskResult(result);\n\n    return { query, variables, result, meta };\n  });\n\n  // Reobserve with fetchPolicy effectively set to \"cache-first\", triggering\n  // delivery of any new data from the cache, possibly falling back to the network\n  // if any cache data are missing. This allows _complete_ cache results to be\n  // delivered without also kicking off unnecessary network requests when\n  // this.options.fetchPolicy is \"cache-and-network\" or \"network-only\". When\n  // this.options.fetchPolicy is any other policy (\"cache-first\", \"cache-only\",\n  // \"standby\", or \"no-cache\"), we call this.reobserve() as usual.\n  private reobserveCacheFirst(): void {\n    const { fetchPolicy, nextFetchPolicy } = this.options;\n\n    if (fetchPolicy === \"cache-and-network\" || fetchPolicy === \"network-only\") {\n      this.reobserve({\n        fetchPolicy: \"cache-first\",\n        // Use a temporary nextFetchPolicy function that replaces itself with the\n        // previous nextFetchPolicy value and returns the original fetchPolicy.\n        nextFetchPolicy(\n          this: ApolloClient.WatchQueryOptions<TData, TVariables>,\n          currentFetchPolicy: WatchQueryFetchPolicy,\n          context: NextFetchPolicyContext<TData, TVariables>\n        ) {\n          // Replace this nextFetchPolicy function in the options object with the\n          // original this.options.nextFetchPolicy value.\n          this.nextFetchPolicy = nextFetchPolicy;\n          // If the original nextFetchPolicy value was a function, give it a\n          // chance to decide what happens here.\n          if (typeof this.nextFetchPolicy === \"function\") {\n            return this.nextFetchPolicy(currentFetchPolicy, context);\n          }\n          // Otherwise go back to the original this.options.fetchPolicy.\n          return fetchPolicy!;\n        },\n      });\n    } else {\n      this.reobserve();\n    }\n  }\n\n  private getVariablesWithDefaults(variables: TVariables | undefined) {\n    return this.queryManager.getVariables(this.query, variables);\n  }\n}\n\nexport function logMissingFieldErrors(\n  missing: MissingFieldError | MissingTree | undefined\n) {\n  if (__DEV__ && missing) {\n    invariant.debug(`Missing cache result fields: %o`, missing);\n  }\n}\n\nfunction isEqualQuery(\n  a?: { query: DocumentNode; variables: OperationVariables },\n  b?: { query: DocumentNode; variables: OperationVariables }\n) {\n  return !!(a && b && a.query === b.query && equal(a.variables, b.variables));\n}\n\nfunction getTrackingOperatorPromise<ObservedValue, ReturnValue = ObservedValue>(\n  filterMapCb: (value: ObservedValue) => ReturnValue | undefined,\n  defaultValue?: ReturnValue\n) {\n  let lastValue = defaultValue,\n    resolve: (value: ReturnValue) => void,\n    reject: (error: unknown) => void;\n  const promise = new Promise<ReturnValue>((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n  const operator: MonoTypeOperatorFunction<ObservedValue> = tap({\n    next(value) {\n      try {\n        const newValue = filterMapCb(value);\n        if (newValue !== undefined) {\n          lastValue = newValue;\n        }\n      } catch (error) {\n        reject(error);\n      }\n    },\n    finalize: () => {\n      if (lastValue) {\n        resolve(lastValue);\n      } else {\n        const message = \"The operation was aborted.\";\n        const name = \"AbortError\";\n        reject(\n          typeof DOMException !== \"undefined\" ?\n            new DOMException(message, name)\n            // some environments do not have `DOMException`, e.g. node\n            // uses a normal `Error` with a `name` property instead: https://github.com/phryneas/node/blob/d0579b64f0f6b722f8e49bf8a471dd0d0604a21e/lib/internal/errors.js#L964\n            // error.code is a legacy property that is not used anymore,\n            // and also inconsistent across environments (in supporting\n            // browsers it is `20`, in node `'ABORT_ERR'`) so we omit that.\n          : Object.assign(new Error(message), { name })\n        );\n      }\n    },\n  });\n  return { promise, operator };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}