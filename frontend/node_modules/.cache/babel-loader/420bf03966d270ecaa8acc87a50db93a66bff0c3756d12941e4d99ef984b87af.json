{"ast":null,"code":"import { equal } from \"@wry/equality\";\nimport { filter } from \"rxjs\";\nimport { createFulfilledPromise, createRejectedPromise, decoratePromise } from \"@apollo/client/utilities/internal\";\nimport { invariant } from \"@apollo/client/utilities/invariant\";\nconst QUERY_REFERENCE_SYMBOL = Symbol.for(\"apollo.internal.queryRef\");\nconst PROMISE_SYMBOL = Symbol.for(\"apollo.internal.refPromise\");\nexport function wrapQueryRef(internalQueryRef) {\n  return {\n    [QUERY_REFERENCE_SYMBOL]: internalQueryRef,\n    [PROMISE_SYMBOL]: internalQueryRef.promise\n  };\n}\nexport function assertWrappedQueryRef(queryRef) {\n  invariant(!queryRef || QUERY_REFERENCE_SYMBOL in queryRef, 27);\n}\nexport function getWrappedPromise(queryRef) {\n  const internalQueryRef = unwrapQueryRef(queryRef);\n  return internalQueryRef.promise.status === \"fulfilled\" ? internalQueryRef.promise : queryRef[PROMISE_SYMBOL];\n}\nexport function unwrapQueryRef(queryRef) {\n  return queryRef[QUERY_REFERENCE_SYMBOL];\n}\nexport function updateWrappedQueryRef(queryRef, promise) {\n  queryRef[PROMISE_SYMBOL] = promise;\n}\nconst OBSERVED_CHANGED_OPTIONS = [\"context\", \"errorPolicy\", \"fetchPolicy\", \"refetchWritePolicy\", \"returnPartialData\"];\nexport class InternalQueryReference {\n  result;\n  key = {};\n  observable;\n  promise;\n  subscription;\n  listeners = new Set();\n  autoDisposeTimeoutId;\n  resolve;\n  reject;\n  references = 0;\n  softReferences = 0;\n  constructor(observable, options) {\n    this.handleNext = this.handleNext.bind(this);\n    this.dispose = this.dispose.bind(this);\n    this.observable = observable;\n    if (options.onDispose) {\n      this.onDispose = options.onDispose;\n    }\n    this.setResult();\n    this.subscribeToQuery();\n    // Start a timer that will automatically dispose of the query if the\n    // suspended resource does not use this queryRef in the given time. This\n    // helps prevent memory leaks when a component has unmounted before the\n    // query has finished loading.\n    const startDisposeTimer = () => {\n      if (!this.references) {\n        this.autoDisposeTimeoutId = setTimeout(this.dispose, options.autoDisposeTimeoutMs ?? 30_000);\n      }\n    };\n    // We wait until the request has settled to ensure we don't dispose of the\n    // query ref before the request finishes, otherwise we would leave the\n    // promise in a pending state rendering the suspense boundary indefinitely.\n    this.promise.then(startDisposeTimer, startDisposeTimer);\n  }\n  get disposed() {\n    return this.subscription.closed;\n  }\n  get watchQueryOptions() {\n    return this.observable.options;\n  }\n  reinitialize() {\n    const {\n      observable\n    } = this;\n    const originalFetchPolicy = this.watchQueryOptions.fetchPolicy;\n    const avoidNetworkRequests = originalFetchPolicy === \"no-cache\" || originalFetchPolicy === \"standby\";\n    try {\n      if (avoidNetworkRequests) {\n        observable.applyOptions({\n          fetchPolicy: \"standby\"\n        });\n      } else {\n        observable.reset();\n        observable.applyOptions({\n          fetchPolicy: \"cache-first\"\n        });\n      }\n      if (!avoidNetworkRequests) {\n        this.setResult();\n      }\n      this.subscribeToQuery();\n    } finally {\n      observable.applyOptions({\n        fetchPolicy: originalFetchPolicy\n      });\n    }\n  }\n  retain() {\n    this.references++;\n    clearTimeout(this.autoDisposeTimeoutId);\n    let disposed = false;\n    return () => {\n      if (disposed) {\n        return;\n      }\n      disposed = true;\n      this.references--;\n      setTimeout(() => {\n        if (!this.references) {\n          this.dispose();\n        }\n      });\n    };\n  }\n  softRetain() {\n    this.softReferences++;\n    let disposed = false;\n    return () => {\n      // Tracking if this has already been called helps ensure that\n      // multiple calls to this function won't decrement the reference\n      // counter more than it should. Subsequent calls just result in a noop.\n      if (disposed) {\n        return;\n      }\n      disposed = true;\n      this.softReferences--;\n      setTimeout(() => {\n        if (!this.softReferences && !this.references) {\n          this.dispose();\n        }\n      });\n    };\n  }\n  didChangeOptions(watchQueryOptions) {\n    return OBSERVED_CHANGED_OPTIONS.some(option => option in watchQueryOptions && !equal(this.watchQueryOptions[option], watchQueryOptions[option]));\n  }\n  applyOptions(watchQueryOptions) {\n    const {\n      fetchPolicy: currentFetchPolicy\n    } = this.watchQueryOptions;\n    // \"standby\" is used when `skip` is set to `true`. Detect when we've\n    // enabled the query (i.e. `skip` is `false`) to execute a network request.\n    if (currentFetchPolicy === \"standby\" && currentFetchPolicy !== watchQueryOptions.fetchPolicy) {\n      this.initiateFetch(this.observable.reobserve(watchQueryOptions));\n    } else {\n      this.observable.applyOptions(watchQueryOptions);\n    }\n    return this.promise;\n  }\n  listen(listener) {\n    this.listeners.add(listener);\n    return () => {\n      this.listeners.delete(listener);\n    };\n  }\n  refetch(variables) {\n    return this.initiateFetch(this.observable.refetch(variables));\n  }\n  fetchMore(options) {\n    return this.initiateFetch(this.observable.fetchMore(options));\n  }\n  dispose() {\n    this.subscription.unsubscribe();\n  }\n  onDispose() {\n    // noop. overridable by options\n  }\n  handleNext(result) {\n    switch (this.promise.status) {\n      case \"pending\":\n        {\n          // Maintain the last successful `data` value if the next result does not\n          // have one.\n          // TODO: This can likely be removed once\n          // https://github.com/apollographql/apollo-client/issues/12667 is fixed\n          if (result.data === void 0) {\n            result.data = this.result.data;\n            if (result.data) {\n              result.dataState = \"complete\";\n            }\n          }\n          if (this.shouldReject(result)) {\n            this.reject?.(result.error);\n          } else {\n            this.result = result;\n            this.resolve?.(result);\n          }\n          break;\n        }\n      default:\n        {\n          // This occurs when switching to a result that is fully cached when this\n          // class is instantiated. ObservableQuery will run reobserve when\n          // subscribing, which delivers a result from the cache.\n          if (result.data === this.result.data && result.networkStatus === this.result.networkStatus) {\n            return;\n          }\n          // Maintain the last successful `data` value if the next result does not\n          // have one.\n          if (result.data === void 0) {\n            result.data = this.result.data;\n          }\n          if (this.shouldReject(result)) {\n            this.promise = createRejectedPromise(result.error);\n            this.deliver(this.promise);\n          } else {\n            this.result = result;\n            this.promise = createFulfilledPromise(result);\n            this.deliver(this.promise);\n          }\n          break;\n        }\n    }\n  }\n  deliver(promise) {\n    this.listeners.forEach(listener => listener(promise));\n  }\n  initiateFetch(returnedPromise) {\n    this.promise = this.createPendingPromise();\n    this.promise.catch(() => {});\n    // If the data returned from the fetch is deeply equal to the data already\n    // in the cache, `handleNext` will not be triggered leaving the promise we\n    // created in a pending state forever. To avoid this situtation, we attempt\n    // to resolve the promise if `handleNext` hasn't been run to ensure the\n    // promise is resolved correctly.\n    returnedPromise.then(() => {\n      // In the case of `fetchMore`, this promise is resolved before a cache\n      // result is emitted due to the fact that `fetchMore` sets a `no-cache`\n      // fetch policy and runs `cache.batch` in its `.then` handler. Because\n      // the timing is different, we accidentally run this update twice\n      // causing an additional re-render with the `fetchMore` result by\n      // itself. By wrapping in `setTimeout`, this should provide a short\n      // delay to allow the `QueryInfo.notify` handler to run before this\n      // promise is checked.\n      // See https://github.com/apollographql/apollo-client/issues/11315 for\n      // more information\n      setTimeout(() => {\n        if (this.promise.status === \"pending\") {\n          // Use the current result from the observable instead of the value\n          // resolved from the promise. This avoids issues in some cases where\n          // the raw resolved value should not be the emitted value, such as\n          // when a `fetchMore` call returns an empty array after it has\n          // reached the end of the list.\n          //\n          // See the following for more information:\n          // https://github.com/apollographql/apollo-client/issues/11642\n          this.result = this.observable.getCurrentResult();\n          this.resolve?.(this.result);\n        }\n      });\n    }).catch(error => this.reject?.(error));\n    return returnedPromise;\n  }\n  subscribeToQuery() {\n    this.subscription = this.observable.pipe(filter(result => !equal(result, this.result))).subscribe(this.handleNext);\n    // call `onDispose` when the subscription is finalized, either because it is\n    // unsubscribed as a consequence of a `dispose` call or because the\n    // ObservableQuery completes because of a `ApolloClient.stop()` call.\n    this.subscription.add(this.onDispose);\n  }\n  setResult() {\n    const result = this.observable.getCurrentResult();\n    if (equal(result, this.result)) {\n      return;\n    }\n    this.result = result;\n    this.promise = result.data ? createFulfilledPromise(result) : this.createPendingPromise();\n  }\n  shouldReject(result) {\n    const {\n      errorPolicy = \"none\"\n    } = this.watchQueryOptions;\n    return result.error && errorPolicy === \"none\";\n  }\n  createPendingPromise() {\n    return decoratePromise(new Promise((resolve, reject) => {\n      this.resolve = resolve;\n      this.reject = reject;\n    }));\n  }\n}","map":{"version":3,"names":["equal","filter","createFulfilledPromise","createRejectedPromise","decoratePromise","invariant","QUERY_REFERENCE_SYMBOL","Symbol","for","PROMISE_SYMBOL","wrapQueryRef","internalQueryRef","promise","assertWrappedQueryRef","queryRef","getWrappedPromise","unwrapQueryRef","status","updateWrappedQueryRef","OBSERVED_CHANGED_OPTIONS","InternalQueryReference","result","key","observable","subscription","listeners","Set","autoDisposeTimeoutId","resolve","reject","references","softReferences","constructor","options","handleNext","bind","dispose","onDispose","setResult","subscribeToQuery","startDisposeTimer","setTimeout","autoDisposeTimeoutMs","then","disposed","closed","watchQueryOptions","reinitialize","originalFetchPolicy","fetchPolicy","avoidNetworkRequests","applyOptions","reset","retain","clearTimeout","softRetain","didChangeOptions","some","option","currentFetchPolicy","initiateFetch","reobserve","listen","listener","add","delete","refetch","variables","fetchMore","unsubscribe","data","dataState","shouldReject","error","networkStatus","deliver","forEach","returnedPromise","createPendingPromise","catch","getCurrentResult","pipe","subscribe","errorPolicy","Promise"],"sources":["/home/saurabh-shukla/Desktop/Slack Lite/frontend/node_modules/@apollo/src/react/internal/cache/QueryReference.ts"],"sourcesContent":["import { equal } from \"@wry/equality\";\nimport type { Subscription } from \"rxjs\";\nimport { filter } from \"rxjs\";\n\nimport type {\n  ApolloClient,\n  DataState,\n  ObservableQuery,\n  OperationVariables,\n} from \"@apollo/client\";\nimport type { MaybeMasked } from \"@apollo/client/masking\";\nimport type { DecoratedPromise } from \"@apollo/client/utilities/internal\";\nimport {\n  createFulfilledPromise,\n  createRejectedPromise,\n  decoratePromise,\n} from \"@apollo/client/utilities/internal\";\nimport { invariant } from \"@apollo/client/utilities/invariant\";\n\nimport type { QueryKey } from \"./types.js\";\n\ntype QueryRefPromise<\n  TData,\n  TStates extends DataState<TData>[\"dataState\"],\n> = DecoratedPromise<ObservableQuery.Result<MaybeMasked<TData>, TStates>>;\n\ntype Listener<TData, TStates extends DataState<TData>[\"dataState\"]> = (\n  promise: QueryRefPromise<TData, TStates>\n) => void;\n\nconst QUERY_REFERENCE_SYMBOL: unique symbol = Symbol.for(\n  \"apollo.internal.queryRef\"\n);\nconst PROMISE_SYMBOL: unique symbol = Symbol.for(\"apollo.internal.refPromise\");\ndeclare const QUERY_REF_BRAND: unique symbol;\ndeclare const PRELOADED_QUERY_REF_BRAND: unique symbol;\n/**\n * A `QueryReference` is an opaque object returned by `useBackgroundQuery`.\n * A child component reading the `QueryReference` via `useReadQuery` will\n * suspend until the promise resolves.\n */\nexport interface QueryRef<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n  TStates extends DataState<TData>[\"dataState\"] = \"complete\" | \"streaming\",\n> {\n  /** @internal */\n  [QUERY_REF_BRAND]?(variables: TVariables): { data: TData; states: TStates };\n}\n\n/**\n * @internal\n * For usage in internal helpers only.\n */\ninterface WrappedQueryRef<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n  TStates extends DataState<TData>[\"dataState\"] = \"complete\" | \"streaming\",\n> extends QueryRef<TData, TVariables, TStates> {\n  /** @internal */\n  readonly [QUERY_REFERENCE_SYMBOL]: InternalQueryReference<TData, TStates>;\n  /** @internal */\n  [PROMISE_SYMBOL]: QueryRefPromise<TData, TStates>;\n}\n\n/**\n * {@inheritDoc @apollo/client/react!QueryRef:interface}\n */\nexport interface PreloadedQueryRef<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n  TStates extends DataState<TData>[\"dataState\"] = \"complete\" | \"streaming\",\n> extends QueryRef<TData, TVariables, TStates> {\n  /** @internal */\n  [PRELOADED_QUERY_REF_BRAND]: typeof PRELOADED_QUERY_REF_BRAND;\n}\n\ninterface InternalQueryReferenceOptions {\n  onDispose?: () => void;\n  autoDisposeTimeoutMs?: number;\n}\n\nexport function wrapQueryRef<\n  TData,\n  TVariables extends OperationVariables,\n  TStates extends DataState<TData>[\"dataState\"],\n>(internalQueryRef: InternalQueryReference<TData, TStates>) {\n  return {\n    [QUERY_REFERENCE_SYMBOL]: internalQueryRef,\n    [PROMISE_SYMBOL]: internalQueryRef.promise,\n  } as WrappedQueryRef<TData, TVariables, TStates>;\n}\n\nexport function assertWrappedQueryRef<\n  TData,\n  TVariables extends OperationVariables,\n  TStates extends DataState<TData>[\"dataState\"],\n>(\n  queryRef: QueryRef<TData, TVariables, TStates>\n): asserts queryRef is WrappedQueryRef<TData, TVariables, TStates>;\n\nexport function assertWrappedQueryRef<\n  TData,\n  TVariables extends OperationVariables,\n  TStates extends DataState<TData>[\"dataState\"],\n>(\n  queryRef: QueryRef<TData, TVariables, TStates> | undefined | null\n): asserts queryRef is\n  | WrappedQueryRef<TData, TVariables, TStates>\n  | undefined\n  | null;\n\nexport function assertWrappedQueryRef<\n  TData,\n  TVariables extends OperationVariables,\n  TStates extends DataState<TData>[\"dataState\"],\n>(queryRef: QueryRef<TData, TVariables, TStates> | undefined | null) {\n  invariant(\n    !queryRef || QUERY_REFERENCE_SYMBOL in queryRef,\n    \"Expected a QueryRef object, but got something else instead.\"\n  );\n}\n\nexport function getWrappedPromise<\n  TData,\n  TStates extends DataState<TData>[\"dataState\"],\n>(queryRef: WrappedQueryRef<TData, any, TStates>) {\n  const internalQueryRef = unwrapQueryRef(queryRef);\n\n  return internalQueryRef.promise.status === \"fulfilled\" ?\n      internalQueryRef.promise\n    : queryRef[PROMISE_SYMBOL];\n}\n\nexport function unwrapQueryRef<\n  TData,\n  TStates extends DataState<TData>[\"dataState\"],\n>(\n  queryRef: WrappedQueryRef<TData, any, TStates>\n): InternalQueryReference<TData, TStates>;\n\nexport function unwrapQueryRef<\n  TData,\n  TStates extends DataState<TData>[\"dataState\"],\n>(\n  queryRef: Partial<WrappedQueryRef<TData, any, TStates>>\n): undefined | InternalQueryReference<TData, TStates>;\n\nexport function unwrapQueryRef<\n  TData,\n  TStates extends DataState<TData>[\"dataState\"],\n>(queryRef: Partial<WrappedQueryRef<TData, any, TStates>>) {\n  return queryRef[QUERY_REFERENCE_SYMBOL];\n}\n\nexport function updateWrappedQueryRef<\n  TData,\n  TStates extends DataState<TData>[\"dataState\"],\n>(\n  queryRef: WrappedQueryRef<TData, any, TStates>,\n  promise: QueryRefPromise<TData, TStates>\n) {\n  queryRef[PROMISE_SYMBOL] = promise;\n}\n\nconst OBSERVED_CHANGED_OPTIONS = [\n  \"context\",\n  \"errorPolicy\",\n  \"fetchPolicy\",\n  \"refetchWritePolicy\",\n  \"returnPartialData\",\n] as const;\n\ntype ObservedOptions = Pick<\n  ApolloClient.WatchQueryOptions,\n  (typeof OBSERVED_CHANGED_OPTIONS)[number]\n>;\n\nexport class InternalQueryReference<\n  TData = unknown,\n  TStates extends DataState<TData>[\"dataState\"] = DataState<TData>[\"dataState\"],\n> {\n  public result!: ObservableQuery.Result<MaybeMasked<TData>, TStates>;\n  public readonly key: QueryKey = {};\n  public readonly observable: ObservableQuery<TData>;\n\n  public promise!: QueryRefPromise<TData, TStates>;\n\n  private subscription!: Subscription;\n  private listeners = new Set<Listener<TData, TStates>>();\n  private autoDisposeTimeoutId?: NodeJS.Timeout;\n\n  private resolve:\n    | ((result: ObservableQuery.Result<MaybeMasked<TData>, TStates>) => void)\n    | undefined;\n  private reject: ((error: unknown) => void) | undefined;\n\n  private references = 0;\n  private softReferences = 0;\n\n  constructor(\n    observable: ObservableQuery<TData, any>,\n    options: InternalQueryReferenceOptions\n  ) {\n    this.handleNext = this.handleNext.bind(this);\n    this.dispose = this.dispose.bind(this);\n    this.observable = observable;\n\n    if (options.onDispose) {\n      this.onDispose = options.onDispose;\n    }\n\n    this.setResult();\n    this.subscribeToQuery();\n\n    // Start a timer that will automatically dispose of the query if the\n    // suspended resource does not use this queryRef in the given time. This\n    // helps prevent memory leaks when a component has unmounted before the\n    // query has finished loading.\n    const startDisposeTimer = () => {\n      if (!this.references) {\n        this.autoDisposeTimeoutId = setTimeout(\n          this.dispose,\n          options.autoDisposeTimeoutMs ?? 30_000\n        );\n      }\n    };\n\n    // We wait until the request has settled to ensure we don't dispose of the\n    // query ref before the request finishes, otherwise we would leave the\n    // promise in a pending state rendering the suspense boundary indefinitely.\n    this.promise.then(startDisposeTimer, startDisposeTimer);\n  }\n\n  get disposed() {\n    return this.subscription.closed;\n  }\n\n  get watchQueryOptions() {\n    return this.observable.options;\n  }\n\n  reinitialize() {\n    const { observable } = this;\n\n    const originalFetchPolicy = this.watchQueryOptions.fetchPolicy;\n    const avoidNetworkRequests =\n      originalFetchPolicy === \"no-cache\" || originalFetchPolicy === \"standby\";\n\n    try {\n      if (avoidNetworkRequests) {\n        observable.applyOptions({ fetchPolicy: \"standby\" });\n      } else {\n        observable.reset();\n        observable.applyOptions({ fetchPolicy: \"cache-first\" });\n      }\n\n      if (!avoidNetworkRequests) {\n        this.setResult();\n      }\n      this.subscribeToQuery();\n    } finally {\n      observable.applyOptions({ fetchPolicy: originalFetchPolicy });\n    }\n  }\n\n  retain() {\n    this.references++;\n    clearTimeout(this.autoDisposeTimeoutId);\n    let disposed = false;\n\n    return () => {\n      if (disposed) {\n        return;\n      }\n\n      disposed = true;\n      this.references--;\n\n      setTimeout(() => {\n        if (!this.references) {\n          this.dispose();\n        }\n      });\n    };\n  }\n\n  softRetain() {\n    this.softReferences++;\n    let disposed = false;\n\n    return () => {\n      // Tracking if this has already been called helps ensure that\n      // multiple calls to this function won't decrement the reference\n      // counter more than it should. Subsequent calls just result in a noop.\n      if (disposed) {\n        return;\n      }\n\n      disposed = true;\n      this.softReferences--;\n      setTimeout(() => {\n        if (!this.softReferences && !this.references) {\n          this.dispose();\n        }\n      });\n    };\n  }\n\n  didChangeOptions(watchQueryOptions: ObservedOptions) {\n    return OBSERVED_CHANGED_OPTIONS.some(\n      (option) =>\n        option in watchQueryOptions &&\n        !equal(this.watchQueryOptions[option], watchQueryOptions[option])\n    );\n  }\n\n  applyOptions(watchQueryOptions: ObservedOptions) {\n    const { fetchPolicy: currentFetchPolicy } = this.watchQueryOptions;\n\n    // \"standby\" is used when `skip` is set to `true`. Detect when we've\n    // enabled the query (i.e. `skip` is `false`) to execute a network request.\n    if (\n      currentFetchPolicy === \"standby\" &&\n      currentFetchPolicy !== watchQueryOptions.fetchPolicy\n    ) {\n      this.initiateFetch(this.observable.reobserve(watchQueryOptions));\n    } else {\n      this.observable.applyOptions(watchQueryOptions);\n    }\n\n    return this.promise;\n  }\n\n  listen(listener: Listener<TData, TStates>) {\n    this.listeners.add(listener);\n\n    return () => {\n      this.listeners.delete(listener);\n    };\n  }\n\n  refetch(variables: OperationVariables | undefined) {\n    return this.initiateFetch(this.observable.refetch(variables));\n  }\n\n  fetchMore(options: ObservableQuery.FetchMoreOptions<TData, any, any, any>) {\n    return this.initiateFetch(this.observable.fetchMore<TData>(options));\n  }\n\n  private dispose() {\n    this.subscription.unsubscribe();\n  }\n\n  private onDispose() {\n    // noop. overridable by options\n  }\n\n  private handleNext(\n    result: ObservableQuery.Result<MaybeMasked<TData>, TStates>\n  ) {\n    switch (this.promise.status) {\n      case \"pending\": {\n        // Maintain the last successful `data` value if the next result does not\n        // have one.\n        // TODO: This can likely be removed once\n        // https://github.com/apollographql/apollo-client/issues/12667 is fixed\n        if (result.data === void 0) {\n          result.data = this.result.data;\n\n          if (result.data) {\n            result.dataState = \"complete\" as any;\n          }\n        }\n\n        if (this.shouldReject(result)) {\n          this.reject?.(result.error);\n        } else {\n          this.result = result;\n          this.resolve?.(result);\n        }\n        break;\n      }\n      default: {\n        // This occurs when switching to a result that is fully cached when this\n        // class is instantiated. ObservableQuery will run reobserve when\n        // subscribing, which delivers a result from the cache.\n        if (\n          result.data === this.result.data &&\n          result.networkStatus === this.result.networkStatus\n        ) {\n          return;\n        }\n\n        // Maintain the last successful `data` value if the next result does not\n        // have one.\n        if (result.data === void 0) {\n          result.data = this.result.data;\n        }\n\n        if (this.shouldReject(result)) {\n          this.promise = createRejectedPromise(result.error);\n          this.deliver(this.promise);\n        } else {\n          this.result = result;\n          this.promise = createFulfilledPromise(result);\n          this.deliver(this.promise);\n        }\n        break;\n      }\n    }\n  }\n\n  private deliver(promise: QueryRefPromise<TData, TStates>) {\n    this.listeners.forEach((listener) => listener(promise));\n  }\n\n  private initiateFetch(\n    returnedPromise: Promise<ApolloClient.QueryResult<MaybeMasked<TData>>>\n  ) {\n    this.promise = this.createPendingPromise();\n    this.promise.catch(() => {});\n\n    // If the data returned from the fetch is deeply equal to the data already\n    // in the cache, `handleNext` will not be triggered leaving the promise we\n    // created in a pending state forever. To avoid this situtation, we attempt\n    // to resolve the promise if `handleNext` hasn't been run to ensure the\n    // promise is resolved correctly.\n    returnedPromise\n      .then(() => {\n        // In the case of `fetchMore`, this promise is resolved before a cache\n        // result is emitted due to the fact that `fetchMore` sets a `no-cache`\n        // fetch policy and runs `cache.batch` in its `.then` handler. Because\n        // the timing is different, we accidentally run this update twice\n        // causing an additional re-render with the `fetchMore` result by\n        // itself. By wrapping in `setTimeout`, this should provide a short\n        // delay to allow the `QueryInfo.notify` handler to run before this\n        // promise is checked.\n        // See https://github.com/apollographql/apollo-client/issues/11315 for\n        // more information\n        setTimeout(() => {\n          if (this.promise.status === \"pending\") {\n            // Use the current result from the observable instead of the value\n            // resolved from the promise. This avoids issues in some cases where\n            // the raw resolved value should not be the emitted value, such as\n            // when a `fetchMore` call returns an empty array after it has\n            // reached the end of the list.\n            //\n            // See the following for more information:\n            // https://github.com/apollographql/apollo-client/issues/11642\n            this.result =\n              this.observable.getCurrentResult() as ObservableQuery.Result<\n                TData,\n                TStates\n              >;\n            this.resolve?.(this.result);\n          }\n        });\n      })\n      .catch((error) => this.reject?.(error));\n\n    return returnedPromise;\n  }\n\n  private subscribeToQuery() {\n    this.subscription = this.observable\n      .pipe(filter((result) => !equal(result, this.result)))\n      .subscribe(this.handleNext as any);\n    // call `onDispose` when the subscription is finalized, either because it is\n    // unsubscribed as a consequence of a `dispose` call or because the\n    // ObservableQuery completes because of a `ApolloClient.stop()` call.\n    this.subscription.add(this.onDispose);\n  }\n\n  private setResult() {\n    const result = this.observable.getCurrentResult() as ObservableQuery.Result<\n      TData,\n      TStates\n    >;\n\n    if (equal(result, this.result)) {\n      return;\n    }\n\n    this.result = result;\n    this.promise =\n      result.data ?\n        createFulfilledPromise(result)\n      : this.createPendingPromise();\n  }\n\n  private shouldReject(result: ObservableQuery.Result<any>) {\n    const { errorPolicy = \"none\" } = this.watchQueryOptions;\n\n    return result.error && errorPolicy === \"none\";\n  }\n\n  private createPendingPromise() {\n    return decoratePromise(\n      new Promise<ObservableQuery.Result<MaybeMasked<TData>, TStates>>(\n        (resolve, reject) => {\n          this.resolve = resolve;\n          this.reject = reject;\n        }\n      )\n    );\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}