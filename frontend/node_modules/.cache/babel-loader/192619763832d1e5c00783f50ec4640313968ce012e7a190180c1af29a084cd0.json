{"ast":null,"code":"import { Kind, visit } from \"graphql\";\nimport { invariant } from \"@apollo/client/utilities/invariant\";\nimport { checkDocument } from \"./checkDocument.js\";\nimport { createFragmentMap } from \"./createFragmentMap.js\";\nimport { getFragmentDefinition } from \"./getFragmentDefinition.js\";\nimport { getFragmentDefinitions } from \"./getFragmentDefinitions.js\";\nimport { getOperationDefinition } from \"./getOperationDefinition.js\";\nimport { isArray } from \"./isArray.js\";\nimport { isNonEmptyArray } from \"./isNonEmptyArray.js\";\n/**\n* @internal\n* \n* @deprecated This is an internal API and should not be used directly. This can be removed or changed at any time.\n*/\nexport function removeDirectivesFromDocument(directives, doc) {\n  checkDocument(doc);\n  // Passing empty strings to makeInUseGetterFunction means we handle anonymous\n  // operations as if their names were \"\". Anonymous fragment definitions are\n  // not supposed to be possible, but the same default naming strategy seems\n  // appropriate for that case as well.\n  const getInUseByOperationName = makeInUseGetterFunction(\"\");\n  const getInUseByFragmentName = makeInUseGetterFunction(\"\");\n  const getInUse = ancestors => {\n    for (let p = 0, ancestor; p < ancestors.length && (ancestor = ancestors[p]); ++p) {\n      if (isArray(ancestor)) continue;\n      if (ancestor.kind === Kind.OPERATION_DEFINITION) {\n        // If an operation is anonymous, we use the empty string as its key.\n        return getInUseByOperationName(ancestor.name && ancestor.name.value);\n      }\n      if (ancestor.kind === Kind.FRAGMENT_DEFINITION) {\n        return getInUseByFragmentName(ancestor.name.value);\n      }\n    }\n    invariant.error(14);\n    return null;\n  };\n  let operationCount = 0;\n  for (let i = doc.definitions.length - 1; i >= 0; --i) {\n    if (doc.definitions[i].kind === Kind.OPERATION_DEFINITION) {\n      ++operationCount;\n    }\n  }\n  const directiveMatcher = getDirectiveMatcher(directives);\n  const shouldRemoveField = nodeDirectives => isNonEmptyArray(nodeDirectives) && nodeDirectives.map(directiveMatcher).some(config => config && config.remove);\n  const originalFragmentDefsByPath = new Map();\n  // Any time the first traversal of the document below makes a change like\n  // removing a fragment (by returning null), this variable should be set to\n  // true. Once it becomes true, it should never be set to false again. If this\n  // variable remains false throughout the traversal, then we can return the\n  // original doc immediately without any modifications.\n  let firstVisitMadeChanges = false;\n  const fieldOrInlineFragmentVisitor = {\n    enter(node) {\n      if (shouldRemoveField(node.directives)) {\n        firstVisitMadeChanges = true;\n        return null;\n      }\n    }\n  };\n  const docWithoutDirectiveSubtrees = visit(doc, {\n    // These two AST node types share the same implementation, defined above.\n    Field: fieldOrInlineFragmentVisitor,\n    InlineFragment: fieldOrInlineFragmentVisitor,\n    VariableDefinition: {\n      enter() {\n        // VariableDefinition nodes do not count as variables in use, though\n        // they do contain Variable nodes that might be visited below. To avoid\n        // counting variable declarations as usages, we skip visiting the\n        // contents of this VariableDefinition node by returning false.\n        return false;\n      }\n    },\n    Variable: {\n      enter(node, _key, _parent, _path, ancestors) {\n        const inUse = getInUse(ancestors);\n        if (inUse) {\n          inUse.variables.add(node.name.value);\n        }\n      }\n    },\n    FragmentSpread: {\n      enter(node, _key, _parent, _path, ancestors) {\n        if (shouldRemoveField(node.directives)) {\n          firstVisitMadeChanges = true;\n          return null;\n        }\n        const inUse = getInUse(ancestors);\n        if (inUse) {\n          inUse.fragmentSpreads.add(node.name.value);\n        }\n        // We might like to remove this FragmentSpread by returning null here if\n        // the corresponding FragmentDefinition node is also going to be removed\n        // by the logic below, but we can't control the relative order of those\n        // events, so we have to postpone the removal of dangling FragmentSpread\n        // nodes until after the current visit of the document has finished.\n      }\n    },\n    FragmentDefinition: {\n      enter(node, _key, _parent, path) {\n        originalFragmentDefsByPath.set(JSON.stringify(path), node);\n      },\n      leave(node, _key, _parent, path) {\n        const originalNode = originalFragmentDefsByPath.get(JSON.stringify(path));\n        if (node === originalNode) {\n          // If the FragmentNode received by this leave function is identical to\n          // the one received by the corresponding enter function (above), then\n          // the visitor must not have made any changes within this\n          // FragmentDefinition node. This fragment definition may still be\n          // removed if there are no ...spread references to it, but it won't be\n          // removed just because it has only a __typename field.\n          return node;\n        }\n        if (\n        // This logic applies only if the document contains one or more\n        // operations, since removing all fragments from a document containing\n        // only fragments makes the document useless.\n        operationCount > 0 && node.selectionSet.selections.every(selection => selection.kind === Kind.FIELD && selection.name.value === \"__typename\")) {\n          // This is a somewhat opinionated choice: if a FragmentDefinition ends\n          // up having no fields other than __typename, we remove the whole\n          // fragment definition, and later prune ...spread references to it.\n          getInUseByFragmentName(node.name.value).removed = true;\n          firstVisitMadeChanges = true;\n          return null;\n        }\n      }\n    },\n    Directive: {\n      leave(node) {\n        // If a matching directive is found, remove the directive itself. Note\n        // that this does not remove the target (field, argument, etc) of the\n        // directive, but only the directive itself.\n        if (directiveMatcher(node)) {\n          firstVisitMadeChanges = true;\n          return null;\n        }\n      }\n    }\n  });\n  if (!firstVisitMadeChanges) {\n    // If our first pass did not change anything about the document, then there\n    // is no cleanup we need to do, and we can return the original doc.\n    return doc;\n  }\n  // Utility for making sure inUse.transitiveVars is recursively populated.\n  // Because this logic assumes inUse.fragmentSpreads has been completely\n  // populated and inUse.removed has been set if appropriate,\n  // populateTransitiveVars must be called after that information has been\n  // collected by the first traversal of the document.\n  const populateTransitiveVars = inUse => {\n    if (!inUse.transitiveVars) {\n      inUse.transitiveVars = new Set(inUse.variables);\n      if (!inUse.removed) {\n        inUse.fragmentSpreads.forEach(childFragmentName => {\n          populateTransitiveVars(getInUseByFragmentName(childFragmentName)).transitiveVars.forEach(varName => {\n            inUse.transitiveVars.add(varName);\n          });\n        });\n      }\n    }\n    return inUse;\n  };\n  // Since we've been keeping track of fragment spreads used by particular\n  // operations and fragment definitions, we now need to compute the set of all\n  // spreads used (transitively) by any operations in the document.\n  const allFragmentNamesUsed = new Set();\n  docWithoutDirectiveSubtrees.definitions.forEach(def => {\n    if (def.kind === Kind.OPERATION_DEFINITION) {\n      populateTransitiveVars(getInUseByOperationName(def.name && def.name.value)).fragmentSpreads.forEach(childFragmentName => {\n        allFragmentNamesUsed.add(childFragmentName);\n      });\n    } else if (def.kind === Kind.FRAGMENT_DEFINITION &&\n    // If there are no operations in the document, then all fragment\n    // definitions count as usages of their own fragment names. This heuristic\n    // prevents accidentally removing all fragment definitions from the\n    // document just because it contains no operations that use the fragments.\n    operationCount === 0 && !getInUseByFragmentName(def.name.value).removed) {\n      allFragmentNamesUsed.add(def.name.value);\n    }\n  });\n  // Now that we have added all fragment spreads used by operations to the\n  // allFragmentNamesUsed set, we can complete the set by transitively adding\n  // all fragment spreads used by those fragments, and so on.\n  allFragmentNamesUsed.forEach(fragmentName => {\n    // Once all the childFragmentName strings added here have been seen already,\n    // the top-level allFragmentNamesUsed.forEach loop will terminate.\n    populateTransitiveVars(getInUseByFragmentName(fragmentName)).fragmentSpreads.forEach(childFragmentName => {\n      allFragmentNamesUsed.add(childFragmentName);\n    });\n  });\n  const fragmentWillBeRemoved = fragmentName => !!(\n  // A fragment definition will be removed if there are no spreads that refer\n  // to it, or the fragment was explicitly removed because it had no fields\n  // other than __typename.\n  !allFragmentNamesUsed.has(fragmentName) || getInUseByFragmentName(fragmentName).removed);\n  const enterVisitor = {\n    enter(node) {\n      if (fragmentWillBeRemoved(node.name.value)) {\n        return null;\n      }\n    }\n  };\n  return nullIfDocIsEmpty(visit(docWithoutDirectiveSubtrees, {\n    // If the fragment is going to be removed, then leaving any dangling\n    // FragmentSpread nodes with the same name would be a mistake.\n    FragmentSpread: enterVisitor,\n    // This is where the fragment definition is actually removed.\n    FragmentDefinition: enterVisitor,\n    OperationDefinition: {\n      leave(node) {\n        // Upon leaving each operation in the depth-first AST traversal, prune\n        // any variables that are declared by the operation but unused within.\n        if (node.variableDefinitions) {\n          const usedVariableNames = populateTransitiveVars(\n          // If an operation is anonymous, we use the empty string as its key.\n          getInUseByOperationName(node.name && node.name.value)).transitiveVars;\n          // According to the GraphQL spec, all variables declared by an\n          // operation must either be used by that operation or used by some\n          // fragment included transitively into that operation:\n          // https://spec.graphql.org/draft/#sec-All-Variables-Used\n          //\n          // To stay on the right side of this validation rule, if/when we\n          // remove the last $var references from an operation or its fragments,\n          // we must also remove the corresponding $var declaration from the\n          // enclosing operation. This pruning applies only to operations and\n          // not fragment definitions, at the moment. Fragments may be able to\n          // declare variables eventually, but today they can only consume them.\n          if (usedVariableNames.size < node.variableDefinitions.length) {\n            return {\n              ...node,\n              variableDefinitions: node.variableDefinitions.filter(varDef => usedVariableNames.has(varDef.variable.name.value))\n            };\n          }\n        }\n      }\n    }\n  }));\n}\nfunction makeInUseGetterFunction(defaultKey) {\n  const map = new Map();\n  return function inUseGetterFunction(key = defaultKey) {\n    let inUse = map.get(key);\n    if (!inUse) {\n      map.set(key, inUse = {\n        // Variable and fragment spread names used directly within this\n        // operation or fragment definition, as identified by key. These sets\n        // will be populated during the first traversal of the document in\n        // removeDirectivesFromDocument below.\n        variables: new Set(),\n        fragmentSpreads: new Set()\n      });\n    }\n    return inUse;\n  };\n}\nfunction getDirectiveMatcher(configs) {\n  const names = new Map();\n  const tests = new Map();\n  configs.forEach(directive => {\n    if (directive) {\n      if (directive.name) {\n        names.set(directive.name, directive);\n      } else if (directive.test) {\n        tests.set(directive.test, directive);\n      }\n    }\n  });\n  return directive => {\n    let config = names.get(directive.name.value);\n    if (!config && tests.size) {\n      tests.forEach((testConfig, test) => {\n        if (test(directive)) {\n          config = testConfig;\n        }\n      });\n    }\n    return config;\n  };\n}\nfunction isEmpty(op, fragmentMap) {\n  return !op || op.selectionSet.selections.every(selection => selection.kind === Kind.FRAGMENT_SPREAD && isEmpty(fragmentMap[selection.name.value], fragmentMap));\n}\nfunction nullIfDocIsEmpty(doc) {\n  return isEmpty(getOperationDefinition(doc) || getFragmentDefinition(doc), createFragmentMap(getFragmentDefinitions(doc))) ? null : doc;\n}","map":{"version":3,"names":["Kind","visit","invariant","checkDocument","createFragmentMap","getFragmentDefinition","getFragmentDefinitions","getOperationDefinition","isArray","isNonEmptyArray","removeDirectivesFromDocument","directives","doc","getInUseByOperationName","makeInUseGetterFunction","getInUseByFragmentName","getInUse","ancestors","p","ancestor","length","kind","OPERATION_DEFINITION","name","value","FRAGMENT_DEFINITION","error","operationCount","i","definitions","directiveMatcher","getDirectiveMatcher","shouldRemoveField","nodeDirectives","map","some","config","remove","originalFragmentDefsByPath","Map","firstVisitMadeChanges","fieldOrInlineFragmentVisitor","enter","node","docWithoutDirectiveSubtrees","Field","InlineFragment","VariableDefinition","Variable","_key","_parent","_path","inUse","variables","add","FragmentSpread","fragmentSpreads","FragmentDefinition","path","set","JSON","stringify","leave","originalNode","get","selectionSet","selections","every","selection","FIELD","removed","Directive","populateTransitiveVars","transitiveVars","Set","forEach","childFragmentName","varName","allFragmentNamesUsed","def","fragmentName","fragmentWillBeRemoved","has","enterVisitor","nullIfDocIsEmpty","OperationDefinition","variableDefinitions","usedVariableNames","size","filter","varDef","variable","defaultKey","inUseGetterFunction","key","configs","names","tests","directive","test","testConfig","isEmpty","op","fragmentMap","FRAGMENT_SPREAD"],"sources":["/home/saurabh-shukla/Desktop/Slack Lite/frontend/node_modules/@apollo/src/utilities/internal/removeDirectivesFromDocument.ts"],"sourcesContent":["import type {\n  ASTNode,\n  ASTVisitFn,\n  DirectiveNode,\n  DocumentNode,\n  FieldNode,\n  FragmentDefinitionNode,\n  FragmentSpreadNode,\n  InlineFragmentNode,\n  OperationDefinitionNode,\n} from \"graphql\";\nimport { Kind, visit } from \"graphql\";\n\nimport { invariant } from \"@apollo/client/utilities/invariant\";\n\nimport { checkDocument } from \"./checkDocument.js\";\nimport { createFragmentMap } from \"./createFragmentMap.js\";\nimport { getFragmentDefinition } from \"./getFragmentDefinition.js\";\nimport { getFragmentDefinitions } from \"./getFragmentDefinitions.js\";\nimport { getOperationDefinition } from \"./getOperationDefinition.js\";\nimport { isArray } from \"./isArray.js\";\nimport { isNonEmptyArray } from \"./isNonEmptyArray.js\";\nimport type { FragmentMap } from \"./types/FragmentMap.js\";\n\n// https://github.com/graphql/graphql-js/blob/8d7c8fccf5a9846a50785de04abda58a7eb13fc0/src/language/visitor.ts#L20-L23\ninterface EnterLeaveVisitor<TVisitedNode extends ASTNode> {\n  readonly enter?: ASTVisitFn<TVisitedNode>;\n  readonly leave?: ASTVisitFn<TVisitedNode>;\n}\n\ntype RemoveDirectiveConfig = {\n  name?: string;\n  test?: (node: DirectiveNode) => boolean;\n  remove?: boolean;\n};\n\n/** @internal */\nexport function removeDirectivesFromDocument(\n  directives: RemoveDirectiveConfig[],\n  doc: DocumentNode\n): DocumentNode | null {\n  checkDocument(doc);\n\n  // Passing empty strings to makeInUseGetterFunction means we handle anonymous\n  // operations as if their names were \"\". Anonymous fragment definitions are\n  // not supposed to be possible, but the same default naming strategy seems\n  // appropriate for that case as well.\n  const getInUseByOperationName = makeInUseGetterFunction<string>(\"\");\n  const getInUseByFragmentName = makeInUseGetterFunction<string>(\"\");\n  const getInUse = (\n    ancestors: readonly (ASTNode | readonly ASTNode[])[]\n  ): InternalInUseInfo | null => {\n    for (\n      let p = 0, ancestor: ASTNode | readonly ASTNode[];\n      p < ancestors.length && (ancestor = ancestors[p]);\n      ++p\n    ) {\n      if (isArray(ancestor)) continue;\n      if (ancestor.kind === Kind.OPERATION_DEFINITION) {\n        // If an operation is anonymous, we use the empty string as its key.\n        return getInUseByOperationName(ancestor.name && ancestor.name.value);\n      }\n      if (ancestor.kind === Kind.FRAGMENT_DEFINITION) {\n        return getInUseByFragmentName(ancestor.name.value);\n      }\n    }\n    invariant.error(`Could not find operation or fragment`);\n    return null;\n  };\n\n  let operationCount = 0;\n  for (let i = doc.definitions.length - 1; i >= 0; --i) {\n    if (doc.definitions[i].kind === Kind.OPERATION_DEFINITION) {\n      ++operationCount;\n    }\n  }\n\n  const directiveMatcher = getDirectiveMatcher(directives);\n  const shouldRemoveField = (nodeDirectives: FieldNode[\"directives\"]) =>\n    isNonEmptyArray(nodeDirectives) &&\n    nodeDirectives\n      .map(directiveMatcher)\n      .some(\n        (config: RemoveDirectiveConfig | undefined) => config && config.remove\n      );\n\n  const originalFragmentDefsByPath = new Map<string, FragmentDefinitionNode>();\n\n  // Any time the first traversal of the document below makes a change like\n  // removing a fragment (by returning null), this variable should be set to\n  // true. Once it becomes true, it should never be set to false again. If this\n  // variable remains false throughout the traversal, then we can return the\n  // original doc immediately without any modifications.\n  let firstVisitMadeChanges = false;\n\n  const fieldOrInlineFragmentVisitor: EnterLeaveVisitor<\n    FieldNode | InlineFragmentNode\n  > = {\n    enter(node) {\n      if (shouldRemoveField(node.directives)) {\n        firstVisitMadeChanges = true;\n        return null;\n      }\n    },\n  };\n\n  const docWithoutDirectiveSubtrees = visit(doc, {\n    // These two AST node types share the same implementation, defined above.\n    Field: fieldOrInlineFragmentVisitor,\n    InlineFragment: fieldOrInlineFragmentVisitor,\n\n    VariableDefinition: {\n      enter() {\n        // VariableDefinition nodes do not count as variables in use, though\n        // they do contain Variable nodes that might be visited below. To avoid\n        // counting variable declarations as usages, we skip visiting the\n        // contents of this VariableDefinition node by returning false.\n        return false;\n      },\n    },\n\n    Variable: {\n      enter(node, _key, _parent, _path, ancestors) {\n        const inUse = getInUse(ancestors);\n        if (inUse) {\n          inUse.variables.add(node.name.value);\n        }\n      },\n    },\n\n    FragmentSpread: {\n      enter(node, _key, _parent, _path, ancestors) {\n        if (shouldRemoveField(node.directives)) {\n          firstVisitMadeChanges = true;\n          return null;\n        }\n        const inUse = getInUse(ancestors);\n        if (inUse) {\n          inUse.fragmentSpreads.add(node.name.value);\n        }\n        // We might like to remove this FragmentSpread by returning null here if\n        // the corresponding FragmentDefinition node is also going to be removed\n        // by the logic below, but we can't control the relative order of those\n        // events, so we have to postpone the removal of dangling FragmentSpread\n        // nodes until after the current visit of the document has finished.\n      },\n    },\n\n    FragmentDefinition: {\n      enter(node, _key, _parent, path) {\n        originalFragmentDefsByPath.set(JSON.stringify(path), node);\n      },\n      leave(node, _key, _parent, path) {\n        const originalNode = originalFragmentDefsByPath.get(\n          JSON.stringify(path)\n        );\n        if (node === originalNode) {\n          // If the FragmentNode received by this leave function is identical to\n          // the one received by the corresponding enter function (above), then\n          // the visitor must not have made any changes within this\n          // FragmentDefinition node. This fragment definition may still be\n          // removed if there are no ...spread references to it, but it won't be\n          // removed just because it has only a __typename field.\n          return node;\n        }\n\n        if (\n          // This logic applies only if the document contains one or more\n          // operations, since removing all fragments from a document containing\n          // only fragments makes the document useless.\n          operationCount > 0 &&\n          node.selectionSet.selections.every(\n            (selection) =>\n              selection.kind === Kind.FIELD &&\n              selection.name.value === \"__typename\"\n          )\n        ) {\n          // This is a somewhat opinionated choice: if a FragmentDefinition ends\n          // up having no fields other than __typename, we remove the whole\n          // fragment definition, and later prune ...spread references to it.\n          getInUseByFragmentName(node.name.value).removed = true;\n          firstVisitMadeChanges = true;\n          return null;\n        }\n      },\n    },\n\n    Directive: {\n      leave(node) {\n        // If a matching directive is found, remove the directive itself. Note\n        // that this does not remove the target (field, argument, etc) of the\n        // directive, but only the directive itself.\n        if (directiveMatcher(node)) {\n          firstVisitMadeChanges = true;\n          return null;\n        }\n      },\n    },\n  });\n\n  if (!firstVisitMadeChanges) {\n    // If our first pass did not change anything about the document, then there\n    // is no cleanup we need to do, and we can return the original doc.\n    return doc;\n  }\n\n  // Utility for making sure inUse.transitiveVars is recursively populated.\n  // Because this logic assumes inUse.fragmentSpreads has been completely\n  // populated and inUse.removed has been set if appropriate,\n  // populateTransitiveVars must be called after that information has been\n  // collected by the first traversal of the document.\n  const populateTransitiveVars = (inUse: InternalInUseInfo) => {\n    if (!inUse.transitiveVars) {\n      inUse.transitiveVars = new Set(inUse.variables);\n      if (!inUse.removed) {\n        inUse.fragmentSpreads.forEach((childFragmentName) => {\n          populateTransitiveVars(\n            getInUseByFragmentName(childFragmentName)\n          ).transitiveVars!.forEach((varName) => {\n            inUse.transitiveVars!.add(varName);\n          });\n        });\n      }\n    }\n    return inUse;\n  };\n\n  // Since we've been keeping track of fragment spreads used by particular\n  // operations and fragment definitions, we now need to compute the set of all\n  // spreads used (transitively) by any operations in the document.\n  const allFragmentNamesUsed = new Set<string>();\n  docWithoutDirectiveSubtrees.definitions.forEach((def) => {\n    if (def.kind === Kind.OPERATION_DEFINITION) {\n      populateTransitiveVars(\n        getInUseByOperationName(def.name && def.name.value)\n      ).fragmentSpreads.forEach((childFragmentName) => {\n        allFragmentNamesUsed.add(childFragmentName);\n      });\n    } else if (\n      def.kind === Kind.FRAGMENT_DEFINITION &&\n      // If there are no operations in the document, then all fragment\n      // definitions count as usages of their own fragment names. This heuristic\n      // prevents accidentally removing all fragment definitions from the\n      // document just because it contains no operations that use the fragments.\n      operationCount === 0 &&\n      !getInUseByFragmentName(def.name.value).removed\n    ) {\n      allFragmentNamesUsed.add(def.name.value);\n    }\n  });\n  // Now that we have added all fragment spreads used by operations to the\n  // allFragmentNamesUsed set, we can complete the set by transitively adding\n  // all fragment spreads used by those fragments, and so on.\n  allFragmentNamesUsed.forEach((fragmentName) => {\n    // Once all the childFragmentName strings added here have been seen already,\n    // the top-level allFragmentNamesUsed.forEach loop will terminate.\n    populateTransitiveVars(\n      getInUseByFragmentName(fragmentName)\n    ).fragmentSpreads.forEach((childFragmentName) => {\n      allFragmentNamesUsed.add(childFragmentName);\n    });\n  });\n\n  const fragmentWillBeRemoved = (fragmentName: string) =>\n    !!(\n      // A fragment definition will be removed if there are no spreads that refer\n      // to it, or the fragment was explicitly removed because it had no fields\n      // other than __typename.\n      (\n        !allFragmentNamesUsed.has(fragmentName) ||\n        getInUseByFragmentName(fragmentName).removed\n      )\n    );\n\n  const enterVisitor: EnterLeaveVisitor<\n    FragmentSpreadNode | FragmentDefinitionNode\n  > = {\n    enter(node) {\n      if (fragmentWillBeRemoved(node.name.value)) {\n        return null;\n      }\n    },\n  };\n\n  return nullIfDocIsEmpty(\n    visit(docWithoutDirectiveSubtrees, {\n      // If the fragment is going to be removed, then leaving any dangling\n      // FragmentSpread nodes with the same name would be a mistake.\n      FragmentSpread: enterVisitor,\n\n      // This is where the fragment definition is actually removed.\n      FragmentDefinition: enterVisitor,\n\n      OperationDefinition: {\n        leave(node) {\n          // Upon leaving each operation in the depth-first AST traversal, prune\n          // any variables that are declared by the operation but unused within.\n          if (node.variableDefinitions) {\n            const usedVariableNames = populateTransitiveVars(\n              // If an operation is anonymous, we use the empty string as its key.\n              getInUseByOperationName(node.name && node.name.value)\n            ).transitiveVars!;\n\n            // According to the GraphQL spec, all variables declared by an\n            // operation must either be used by that operation or used by some\n            // fragment included transitively into that operation:\n            // https://spec.graphql.org/draft/#sec-All-Variables-Used\n            //\n            // To stay on the right side of this validation rule, if/when we\n            // remove the last $var references from an operation or its fragments,\n            // we must also remove the corresponding $var declaration from the\n            // enclosing operation. This pruning applies only to operations and\n            // not fragment definitions, at the moment. Fragments may be able to\n            // declare variables eventually, but today they can only consume them.\n            if (usedVariableNames.size < node.variableDefinitions.length) {\n              return {\n                ...node,\n                variableDefinitions: node.variableDefinitions.filter((varDef) =>\n                  usedVariableNames.has(varDef.variable.name.value)\n                ),\n              };\n            }\n          }\n        },\n      },\n    })\n  );\n}\n\n// Helper interface and function used by removeDirectivesFromDocument to keep\n// track of variable references and fragments spreads found within a given\n// operation or fragment definition.\ninterface InternalInUseInfo {\n  variables: Set<string>;\n  fragmentSpreads: Set<string>;\n  // Set to true when we deliberately remove a fragment definition, so we can\n  // make sure also to remove dangling ...spreads that refer to it.\n  removed?: boolean;\n  // Populated by the populateTransitiveVars helper function below.\n  transitiveVars?: Set<string>;\n}\n\nfunction makeInUseGetterFunction<TKey>(defaultKey: TKey) {\n  const map = new Map<TKey, InternalInUseInfo>();\n\n  return function inUseGetterFunction(\n    key: TKey = defaultKey\n  ): InternalInUseInfo {\n    let inUse = map.get(key);\n    if (!inUse) {\n      map.set(\n        key,\n        (inUse = {\n          // Variable and fragment spread names used directly within this\n          // operation or fragment definition, as identified by key. These sets\n          // will be populated during the first traversal of the document in\n          // removeDirectivesFromDocument below.\n          variables: new Set(),\n          fragmentSpreads: new Set(),\n        })\n      );\n    }\n    return inUse;\n  };\n}\n\ntype GetDirectiveConfig = {\n  name?: string;\n  test?: (node: DirectiveNode) => boolean;\n};\n\nfunction getDirectiveMatcher(\n  configs: (RemoveDirectiveConfig | GetDirectiveConfig)[]\n) {\n  const names = new Map<string, RemoveDirectiveConfig | GetDirectiveConfig>();\n\n  const tests = new Map<\n    (directive: DirectiveNode) => boolean,\n    RemoveDirectiveConfig | GetDirectiveConfig\n  >();\n\n  configs.forEach((directive) => {\n    if (directive) {\n      if (directive.name) {\n        names.set(directive.name, directive);\n      } else if (directive.test) {\n        tests.set(directive.test, directive);\n      }\n    }\n  });\n\n  return (directive: DirectiveNode) => {\n    let config = names.get(directive.name.value);\n    if (!config && tests.size) {\n      tests.forEach((testConfig, test) => {\n        if (test(directive)) {\n          config = testConfig;\n        }\n      });\n    }\n    return config;\n  };\n}\n\nfunction isEmpty(\n  op: OperationDefinitionNode | FragmentDefinitionNode,\n  fragmentMap: FragmentMap\n): boolean {\n  return (\n    !op ||\n    op.selectionSet.selections.every(\n      (selection) =>\n        selection.kind === Kind.FRAGMENT_SPREAD &&\n        isEmpty(fragmentMap[selection.name.value], fragmentMap)\n    )\n  );\n}\n\nfunction nullIfDocIsEmpty(doc: DocumentNode) {\n  return (\n      isEmpty(\n        getOperationDefinition(doc) || getFragmentDefinition(doc),\n        createFragmentMap(getFragmentDefinitions(doc))\n      )\n    ) ?\n      null\n    : doc;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}