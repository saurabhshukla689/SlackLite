{"ast":null,"code":"import equal from \"@wry/equality\";\nimport { Kind } from \"graphql\";\nimport { createFragmentMap, getFragmentDefinitions } from \"@apollo/client/utilities/internal\";\nimport { invariant } from \"@apollo/client/utilities/invariant\";\nimport { maskDefinition } from \"./maskDefinition.js\";\n/**\n* @internal\n* \n* @deprecated This is an internal API and should not be used directly. This can be removed or changed at any time.\n*/\nexport function maskFragment(data, document, cache, fragmentName) {\n  const fragments = document.definitions.filter(node => node.kind === Kind.FRAGMENT_DEFINITION);\n  if (typeof fragmentName === \"undefined\") {\n    invariant(fragments.length === 1, 41, fragments.length);\n    fragmentName = fragments[0].name.value;\n  }\n  const fragment = fragments.find(fragment => fragment.name.value === fragmentName);\n  invariant(!!fragment, 42, fragmentName);\n  if (data == null) {\n    // Maintain the original `null` or `undefined` value\n    return data;\n  }\n  if (equal(data, {})) {\n    // Return early and skip the masking algorithm if we don't have any data\n    // yet. This can happen when cache.diff returns an empty object which is\n    // used from watchFragment.\n    return data;\n  }\n  return maskDefinition(data, fragment.selectionSet, {\n    operationType: \"fragment\",\n    operationName: fragment.name.value,\n    fragmentMap: createFragmentMap(getFragmentDefinitions(document)),\n    cache,\n    mutableTargets: new WeakMap(),\n    knownChanged: new WeakSet()\n  });\n}","map":{"version":3,"names":["equal","Kind","createFragmentMap","getFragmentDefinitions","invariant","maskDefinition","maskFragment","data","document","cache","fragmentName","fragments","definitions","filter","node","kind","FRAGMENT_DEFINITION","length","name","value","fragment","find","selectionSet","operationType","operationName","fragmentMap","mutableTargets","WeakMap","knownChanged","WeakSet"],"sources":["/home/saurabh-shukla/Desktop/Slack Lite/frontend/node_modules/@apollo/src/masking/maskFragment.ts"],"sourcesContent":["import equal from \"@wry/equality\";\nimport type { FragmentDefinitionNode } from \"graphql\";\nimport { Kind } from \"graphql\";\n\nimport type {\n  ApolloCache,\n  DocumentNode,\n  TypedDocumentNode,\n} from \"@apollo/client\";\nimport { __DEV__ } from \"@apollo/client/utilities/environment\";\nimport {\n  createFragmentMap,\n  getFragmentDefinitions,\n} from \"@apollo/client/utilities/internal\";\nimport { invariant } from \"@apollo/client/utilities/invariant\";\n\nimport { maskDefinition } from \"./maskDefinition.js\";\n\n/** @internal */\nexport function maskFragment<TData = unknown>(\n  data: TData,\n  document: TypedDocumentNode<TData> | DocumentNode,\n  cache: ApolloCache,\n  fragmentName?: string\n): TData {\n  const fragments = document.definitions.filter(\n    (node): node is FragmentDefinitionNode =>\n      node.kind === Kind.FRAGMENT_DEFINITION\n  );\n\n  if (typeof fragmentName === \"undefined\") {\n    invariant(\n      fragments.length === 1,\n      `Found %s fragments. \\`fragmentName\\` must be provided when there is not exactly 1 fragment.`,\n      fragments.length\n    );\n    fragmentName = fragments[0].name.value;\n  }\n\n  const fragment = fragments.find(\n    (fragment) => fragment.name.value === fragmentName\n  );\n\n  invariant(\n    !!fragment,\n    `Could not find fragment with name \"%s\".`,\n    fragmentName\n  );\n\n  if (data == null) {\n    // Maintain the original `null` or `undefined` value\n    return data;\n  }\n\n  if (equal(data, {})) {\n    // Return early and skip the masking algorithm if we don't have any data\n    // yet. This can happen when cache.diff returns an empty object which is\n    // used from watchFragment.\n    return data;\n  }\n\n  return maskDefinition(data, fragment.selectionSet, {\n    operationType: \"fragment\",\n    operationName: fragment.name.value,\n    fragmentMap: createFragmentMap(getFragmentDefinitions(document)),\n    cache,\n    mutableTargets: new WeakMap(),\n    knownChanged: new WeakSet(),\n  });\n}\n"],"mappings":"AAAA,OAAOA,KAAP,MAAkB,eAAe;AAEjC,SAASC,IAAT,QAAqB,SAAS;AAQ9B,SACEC,iBAAiB,EACjBC,sBAAsB,QACjB,mCAAmC;AAC1C,SAASC,SAAT,QAA0B,oCAAoC;AAE9D,SAASC,cAAT,QAA+B,qBAAqB;;;;;;AAGpD,gBAAgBC,YAAYA,CAC1BC,IAAW,EACXC,QAAiD,EACjDC,KAAkB,EAClBC,YAAqB,EAJvB;EAME,MAAMC,SAAR,GAAoBH,QAAQ,CAACI,WAAW,CAACC,MAAM,CAC1CC,IAAI,IACHA,IAAI,CAACC,IAFX,KAEoBd,IAAI,CAACe,mBAAmB,CACzC;EAED,IAAI,OAAON,YAAb,KAA8B,WAAW,EAAE;IACvCN,SAAJ,CACMO,SAAS,CAACM,MADhB,KAC2B,OAErBN,SAAS,CAACM,MAHhB,CAIK;IACDP,YAAJ,GAAmBC,SAAS,CAAC,CAAC,CAAC,CAACO,IAAI,CAACC,KAAK;EACxC;EAEA,MAAMC,QAAR,GAAmBT,SAAS,CAACU,IAAI,CAC5BD,QAAQ,IAAKA,QAAQ,CAACF,IAAI,CAACC,KADhC,KAC0CT,YAAY,CACnD;EAEDN,SAAF,CACI,CAAC,CAACgB,QADN,MAGIV,YAHJ,CAIG;EAED,IAAIH,IAAN,IAAc,IAAI,EAAE;IAChB;IACA,OAAOA,IAAI;EACb;EAEA,IAAIP,KAAK,CAACO,IAAI,EAAE,CAAlB,CAAoB,CAAC,EAAE;IACnB;IACA;IACA;IACA,OAAOA,IAAI;EACb;EAEA,OAAOF,cAAc,CAACE,IAAI,EAAEa,QAAQ,CAACE,YAAY,EAAE;IACjDC,aAAa,EAAE,UAAU;IACzBC,aAAa,EAAEJ,QAAQ,CAACF,IAAI,CAACC,KAAK;IAClCM,WAAW,EAAEvB,iBAAiB,CAACC,sBAAsB,CAACK,QAAQ,CAAC,CAAC;IAChEC,KAAK;IACLiB,cAAc,EAAE,IAAIC,OAAO,CAA/B,CAAiC;IAC7BC,YAAY,EAAE,IAAIC,OAAO,CAA7B;EACA,CAAG,CAAC;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}