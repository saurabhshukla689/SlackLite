{"ast":null,"code":"/**\n * Function parameters in this file try to follow a common order for the sake of\n * readability and consistency. The order is as follows:\n *\n * resultData\n * observable\n * client\n * query\n * options\n * watchQueryOptions\n * makeWatchQueryOptions\n */\n/**  */\nimport { equal } from \"@wry/equality\";\nimport * as React from \"react\";\nimport { asapScheduler, observeOn } from \"rxjs\";\nimport { NetworkStatus } from \"@apollo/client\";\nimport { maybeDeepFreeze, mergeOptions } from \"@apollo/client/utilities/internal\";\nimport { wrapHook } from \"./internal/index.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\nimport { useSyncExternalStore } from \"./useSyncExternalStore.js\";\nconst lastWatchOptions = Symbol();\nexport function useQuery(query, ...[options]) {\n  \"use no memo\";\n\n  return wrapHook(\"useQuery\",\n  // eslint-disable-next-line react-compiler/react-compiler\n  useQuery_, useApolloClient(options && options.client))(query, options);\n}\nfunction useQuery_(query, options = {}) {\n  const client = useApolloClient(options.client);\n  const {\n    skip,\n    ssr,\n    ...opts\n  } = options;\n  const watchQueryOptions = mergeOptions(client.defaultOptions.watchQuery, {\n    ...opts,\n    query\n  });\n  if (skip) {\n    // When skipping, we set watchQueryOptions.fetchPolicy initially to\n    // \"standby\", but we also need/want to preserve the initial non-standby\n    // fetchPolicy that would have been used if not skipping.\n    watchQueryOptions.initialFetchPolicy = options.initialFetchPolicy || options.fetchPolicy;\n    watchQueryOptions.fetchPolicy = \"standby\";\n  }\n  function createState(previous) {\n    const observable = client.watchQuery(watchQueryOptions);\n    return {\n      client,\n      query,\n      observable,\n      resultData: {\n        current: observable.getCurrentResult(),\n        // Reuse previousData from previous InternalState (if any) to provide\n        // continuity of previousData even if/when the query or client changes.\n        previousData: previous?.resultData.current.data,\n        variables: observable.variables\n      }\n    };\n  }\n  let [state, setState] = React.useState(createState);\n  if (client !== state.client || query !== state.query) {\n    // If the client or query have changed, we need to create a new InternalState.\n    // This will trigger a re-render with the new state, but it will also continue\n    // to run the current render function to completion.\n    // Since we sometimes trigger some side-effects in the render function, we\n    // re-assign `state` to the new state to ensure that those side-effects are\n    // triggered with the new state.\n    setState(state = createState(state));\n  }\n  const {\n    observable,\n    resultData\n  } = state;\n  useInitialFetchPolicyIfNecessary(watchQueryOptions, observable);\n  useResubscribeIfNecessary(resultData,\n  // might get mutated during render\n  observable,\n  // might get mutated during render\n  watchQueryOptions);\n  const result = useResult(observable, resultData, options.ssr);\n  const obsQueryFields = React.useMemo(() => ({\n    refetch: observable.refetch.bind(observable),\n    fetchMore: observable.fetchMore.bind(observable),\n    updateQuery: observable.updateQuery.bind(observable),\n    startPolling: observable.startPolling.bind(observable),\n    stopPolling: observable.stopPolling.bind(observable),\n    subscribeToMore: observable.subscribeToMore.bind(observable)\n  }), [observable]);\n  const previousData = resultData.previousData;\n  return React.useMemo(() => {\n    const {\n      partial,\n      ...rest\n    } = result;\n    return {\n      ...rest,\n      client,\n      observable,\n      variables: observable.variables,\n      previousData,\n      ...obsQueryFields\n    };\n  }, [result, client, observable, previousData, obsQueryFields]);\n}\nfunction useInitialFetchPolicyIfNecessary(watchQueryOptions, observable) {\n  \"use no memo\";\n\n  if (!watchQueryOptions.fetchPolicy) {\n    watchQueryOptions.fetchPolicy = observable.options.initialFetchPolicy;\n  }\n}\nfunction useResult(observable, resultData, ssr) {\n  \"use no memo\";\n\n  return useSyncExternalStore(React.useCallback(handleStoreChange => {\n    const subscription = observable\n    // We use the asapScheduler here to prevent issues with trying to\n    // update in the middle of a render. `reobserve` is kicked off in the\n    // middle of a render and because RxJS emits values synchronously,\n    // its possible for this `handleStoreChange` to be called in that same\n    // render. This allows the render to complete before trying to emit a\n    // new value.\n    .pipe(observeOn(asapScheduler)).subscribe(result => {\n      const previous = resultData.current;\n      if (\n      // Avoid rerendering if the result is the same\n      equal(previous, result) &&\n      // Force rerender if the value was emitted because variables\n      // changed, such as when calling `refetch(newVars)` which returns\n      // the same data when `notifyOnNetworkStatusChange` is `false`.\n      equal(resultData.variables, observable.variables)) {\n        return;\n      }\n      // eslint-disable-next-line react-compiler/react-compiler\n      resultData.variables = observable.variables;\n      if (previous.data && !equal(previous.data, result.data)) {\n        resultData.previousData = previous.data;\n      }\n      resultData.current = result;\n      handleStoreChange();\n    });\n    // Do the \"unsubscribe\" with a short delay.\n    // This way, an existing subscription can be reused without an additional\n    // request if \"unsubscribe\"  and \"resubscribe\" to the same ObservableQuery\n    // happen in very fast succession.\n    return () => {\n      setTimeout(() => subscription.unsubscribe());\n    };\n  }, [observable, resultData]), () => resultData.current, () => ssr === false ? useQuery.ssrDisabledResult : resultData.current);\n}\n// this hook is not compatible with any rules of React, and there's no good way to rewrite it.\n// it should stay a separate hook that will not be optimized by the compiler\nfunction useResubscribeIfNecessary(/** this hook will mutate properties on `resultData` */\nresultData, /** this hook will mutate properties on `observable` */\nobservable, watchQueryOptions) {\n  \"use no memo\";\n\n  if (observable[lastWatchOptions] && !equal(observable[lastWatchOptions], watchQueryOptions)) {\n    // Though it might be tempting to postpone this reobserve call to the\n    // useEffect block, we need getCurrentResult to return an appropriate\n    // loading:true result synchronously (later within the same call to\n    // useQuery). Since we already have this.observable here (not true for\n    // the very first call to useQuery), we are not initiating any new\n    // subscriptions, though it does feel less than ideal that reobserve\n    // (potentially) kicks off a network request (for example, when the\n    // variables have changed), which is technically a side-effect.\n    if (shouldReobserve(observable[lastWatchOptions], watchQueryOptions)) {\n      observable.reobserve(watchQueryOptions);\n    } else {\n      observable.applyOptions(watchQueryOptions);\n    }\n    // Make sure getCurrentResult returns a fresh ApolloQueryResult<TData>,\n    // but save the current data as this.previousData, just like setResult\n    // usually does.\n    const result = observable.getCurrentResult();\n    if (!equal(result.data, resultData.current.data)) {\n      resultData.previousData = resultData.current.data || resultData.previousData;\n    }\n    resultData.current = result;\n    resultData.variables = observable.variables;\n  }\n  observable[lastWatchOptions] = watchQueryOptions;\n}\nfunction shouldReobserve(previousOptions, options) {\n  return previousOptions.query !== options.query || !equal(previousOptions.variables, options.variables) || previousOptions.fetchPolicy !== options.fetchPolicy && (options.fetchPolicy === \"standby\" || previousOptions.fetchPolicy === \"standby\");\n}\nuseQuery.ssrDisabledResult = maybeDeepFreeze({\n  loading: true,\n  data: void 0,\n  dataState: \"empty\",\n  error: void 0,\n  networkStatus: NetworkStatus.loading,\n  partial: true\n});","map":{"version":3,"names":["equal","React","asapScheduler","observeOn","NetworkStatus","maybeDeepFreeze","mergeOptions","wrapHook","useApolloClient","useSyncExternalStore","lastWatchOptions","Symbol","useQuery","query","options","useQuery_","client","skip","ssr","opts","watchQueryOptions","defaultOptions","watchQuery","initialFetchPolicy","fetchPolicy","createState","previous","observable","resultData","current","getCurrentResult","previousData","data","variables","state","setState","useState","useInitialFetchPolicyIfNecessary","useResubscribeIfNecessary","result","useResult","obsQueryFields","useMemo","refetch","bind","fetchMore","updateQuery","startPolling","stopPolling","subscribeToMore","partial","rest","useCallback","handleStoreChange","subscription","pipe","subscribe","setTimeout","unsubscribe","ssrDisabledResult","shouldReobserve","reobserve","applyOptions","previousOptions","loading","dataState","error","networkStatus"],"sources":["/home/saurabh-shukla/Desktop/Slack Lite/frontend/node_modules/@apollo/src/react/hooks/useQuery.ts"],"sourcesContent":["/**\n * Function parameters in this file try to follow a common order for the sake of\n * readability and consistency. The order is as follows:\n *\n * resultData\n * observable\n * client\n * query\n * options\n * watchQueryOptions\n * makeWatchQueryOptions\n */\n/**  */\nimport { equal } from \"@wry/equality\";\nimport * as React from \"react\";\nimport { asapScheduler, observeOn } from \"rxjs\";\n\nimport type {\n  ApolloClient,\n  DataState,\n  DefaultContext,\n  DocumentNode,\n  ErrorLike,\n  ErrorPolicy,\n  GetDataState,\n  InternalTypes,\n  ObservableQuery,\n  OperationVariables,\n  RefetchWritePolicy,\n  SubscribeToMoreFunction,\n  TypedDocumentNode,\n  UpdateQueryMapFn,\n  WatchQueryFetchPolicy,\n} from \"@apollo/client\";\nimport { NetworkStatus } from \"@apollo/client\";\nimport type { MaybeMasked } from \"@apollo/client/masking\";\nimport type {\n  DocumentationTypes as UtilityDocumentationTypes,\n  NoInfer,\n  VariablesOption,\n} from \"@apollo/client/utilities/internal\";\nimport {\n  maybeDeepFreeze,\n  mergeOptions,\n} from \"@apollo/client/utilities/internal\";\n\nimport { wrapHook } from \"./internal/index.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\nimport { useSyncExternalStore } from \"./useSyncExternalStore.js\";\n\nexport declare namespace useQuery {\n  import _self = useQuery;\n  export namespace Base {\n    export interface Options<\n      TData = unknown,\n      TVariables extends OperationVariables = OperationVariables,\n    > {\n      /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#fetchPolicy:member} */\n      fetchPolicy?: WatchQueryFetchPolicy;\n\n      /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#nextFetchPolicy:member} */\n      nextFetchPolicy?:\n        | WatchQueryFetchPolicy\n        | ((\n            this: ApolloClient.WatchQueryOptions<TData, TVariables>,\n            currentFetchPolicy: WatchQueryFetchPolicy,\n            context: InternalTypes.NextFetchPolicyContext<TData, TVariables>\n          ) => WatchQueryFetchPolicy);\n      /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#initialFetchPolicy:member} */\n\n      initialFetchPolicy?: WatchQueryFetchPolicy;\n\n      /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#refetchWritePolicy:member} */\n      refetchWritePolicy?: RefetchWritePolicy;\n\n      /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#errorPolicy:member} */\n      errorPolicy?: ErrorPolicy;\n\n      /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#pollInterval:member} */\n      pollInterval?: number;\n\n      /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#notifyOnNetworkStatusChange:member} */\n      notifyOnNetworkStatusChange?: boolean;\n\n      /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#returnPartialData:member} */\n      returnPartialData?: boolean;\n\n      /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#skipPollAttempt:member} */\n      skipPollAttempt?: () => boolean;\n\n      /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#ssr:member} */\n      ssr?: boolean;\n\n      /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#client:member} */\n      client?: ApolloClient;\n\n      /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#context:member} */\n      context?: DefaultContext;\n\n      /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#skip:member} */\n      skip?: boolean;\n    }\n  }\n  export type Options<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  > = Base.Options<TData, TVariables> & VariablesOption<TVariables>;\n\n  export namespace DocumentationTypes {\n    namespace useQuery {\n      export interface Options<\n        TData = unknown,\n        TVariables extends OperationVariables = OperationVariables,\n      > extends Base.Options<TData, TVariables>,\n          UtilityDocumentationTypes.VariableOptions<TVariables> {}\n    }\n  }\n\n  export namespace Base {\n    export interface Result<\n      TData = unknown,\n      TVariables extends OperationVariables = OperationVariables,\n    > {\n      /** {@inheritDoc @apollo/client!QueryResultDocumentation#client:member} */\n      client: ApolloClient;\n\n      /** {@inheritDoc @apollo/client!QueryResultDocumentation#observable:member} */\n      observable: ObservableQuery<TData, TVariables>;\n\n      /** {@inheritDoc @apollo/client!QueryResultDocumentation#previousData:member} */\n      previousData?: MaybeMasked<TData>;\n\n      /** {@inheritDoc @apollo/client!QueryResultDocumentation#error:member} */\n      error?: ErrorLike;\n\n      /** {@inheritDoc @apollo/client!QueryResultDocumentation#loading:member} */\n      loading: boolean;\n\n      /** {@inheritDoc @apollo/client!QueryResultDocumentation#networkStatus:member} */\n      networkStatus: NetworkStatus;\n\n      /** {@inheritDoc @apollo/client!QueryResultDocumentation#startPolling:member} */\n      startPolling: (pollInterval: number) => void;\n\n      /** {@inheritDoc @apollo/client!QueryResultDocumentation#stopPolling:member} */\n      stopPolling: () => void;\n\n      /** {@inheritDoc @apollo/client!QueryResultDocumentation#subscribeToMore:member} */\n      subscribeToMore: SubscribeToMoreFunction<TData, TVariables>;\n\n      /** {@inheritDoc @apollo/client!QueryResultDocumentation#updateQuery:member} */\n      updateQuery: (mapFn: UpdateQueryMapFn<TData, TVariables>) => void;\n\n      /** {@inheritDoc @apollo/client!QueryResultDocumentation#refetch:member} */\n      refetch: (\n        variables?: Partial<TVariables>\n      ) => Promise<ApolloClient.QueryResult<MaybeMasked<TData>>>;\n\n      /** {@inheritDoc @apollo/client!QueryResultDocumentation#variables:member} */\n      variables: TVariables;\n\n      /** {@inheritDoc @apollo/client!QueryResultDocumentation#fetchMore:member} */\n      fetchMore: <\n        TFetchData = TData,\n        TFetchVars extends OperationVariables = TVariables,\n      >(\n        fetchMoreOptions: ObservableQuery.FetchMoreOptions<\n          TData,\n          TVariables,\n          TFetchData,\n          TFetchVars\n        >\n      ) => Promise<ApolloClient.QueryResult<MaybeMasked<TFetchData>>>;\n    }\n  }\n  export type Result<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n    TStates extends\n      DataState<TData>[\"dataState\"] = DataState<TData>[\"dataState\"],\n  > = Base.Result<TData, TVariables> &\n    GetDataState<MaybeMasked<TData>, TStates>;\n\n  export namespace DocumentationTypes {\n    namespace useQuery {\n      export interface Result<\n        TData = unknown,\n        TVariables extends OperationVariables = OperationVariables,\n      > extends Base.Result<TData, TVariables>,\n          UtilityDocumentationTypes.DataState<TData> {}\n    }\n  }\n\n  export namespace DocumentationTypes {\n    /** {@inheritDoc @apollo/client/react!useQuery:function(1)} */\n    export function useQuery<\n      TData = unknown,\n      TVariables extends OperationVariables = OperationVariables,\n    >(\n      query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n      options: useQuery.Options<TData, TVariables>\n    ): useQuery.Result<TData, TVariables>;\n  }\n}\n\nconst lastWatchOptions = Symbol();\n\ninterface ObsQueryWithMeta<TData, TVariables extends OperationVariables>\n  extends ObservableQuery<TData, TVariables> {\n  [lastWatchOptions]?: Readonly<\n    ApolloClient.WatchQueryOptions<TData, TVariables>\n  >;\n}\n\ninterface InternalResult<TData> {\n  // These members are populated by getCurrentResult and setResult, and it's\n  // okay/normal for them to be initially undefined.\n  current: ObservableQuery.Result<TData>;\n  previousData?: undefined | MaybeMasked<TData>;\n\n  // Track current variables separately in case a call to e.g. `refetch(newVars)`\n  // causes an emit that is deeply equal to the current result. This lets us\n  // compare if we should force rerender due to changed variables\n  variables: OperationVariables;\n}\n\ninterface InternalState<TData, TVariables extends OperationVariables> {\n  client: ReturnType<typeof useApolloClient>;\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>;\n  observable: ObsQueryWithMeta<TData, TVariables>;\n  resultData: InternalResult<TData>;\n}\n\n/**\n * A hook for executing queries in an Apollo application.\n *\n * To run a query within a React component, call `useQuery` and pass it a GraphQL query document.\n *\n * When your component renders, `useQuery` returns an object from Apollo Client that contains `loading`, `error`, `dataState`, and `data` properties you can use to render your UI.\n *\n * > Refer to the [Queries](https://www.apollographql.com/docs/react/data/queries) section for a more in-depth overview of `useQuery`.\n *\n * @example\n *\n * ```jsx\n * import { gql } from \"@apollo/client\";\n * import { useQuery } from \"@apollo/client/react\";\n *\n * const GET_GREETING = gql`\n *   query GetGreeting($language: String!) {\n *     greeting(language: $language) {\n *       message\n *     }\n *   }\n * `;\n *\n * function Hello() {\n *   const { loading, error, data } = useQuery(GET_GREETING, {\n *     variables: { language: \"english\" },\n *   });\n *   if (loading) return <p>Loading ...</p>;\n *   return <h1>Hello {data.greeting.message}!</h1>;\n * }\n * ```\n *\n * @param query - A GraphQL query document parsed into an AST by `gql`.\n * @param options - Options to control how the query is executed.\n * @returns Query result object\n */\nexport function useQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: useQuery.Options<NoInfer<TData>, NoInfer<TVariables>> & {\n    returnPartialData: true;\n  }\n): useQuery.Result<\n  TData,\n  TVariables,\n  \"empty\" | \"complete\" | \"streaming\" | \"partial\"\n>;\n\n/** {@inheritDoc @apollo/client/react!useQuery:function(1)} */\nexport function useQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: useQuery.Options<NoInfer<TData>, NoInfer<TVariables>> & {\n    returnPartialData: boolean;\n  }\n): useQuery.Result<\n  TData,\n  TVariables,\n  \"empty\" | \"complete\" | \"streaming\" | \"partial\"\n>;\n\n/** {@inheritDoc @apollo/client/react!useQuery:function(1)} */\nexport function useQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  ...[options]: {} extends TVariables ?\n    [options?: useQuery.Options<NoInfer<TData>, NoInfer<TVariables>>]\n  : [options: useQuery.Options<NoInfer<TData>, NoInfer<TVariables>>]\n): useQuery.Result<TData, TVariables, \"empty\" | \"complete\" | \"streaming\">;\n\nexport function useQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  ...[options]: {} extends TVariables ?\n    [options?: useQuery.Options<NoInfer<TData>, NoInfer<TVariables>>]\n  : [options: useQuery.Options<NoInfer<TData>, NoInfer<TVariables>>]\n): useQuery.Result<TData, TVariables> {\n  \"use no memo\";\n  return wrapHook(\n    \"useQuery\",\n    // eslint-disable-next-line react-compiler/react-compiler\n    useQuery_,\n    useApolloClient(options && options.client)\n  )(query, options);\n}\n\nfunction useQuery_<TData, TVariables extends OperationVariables>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: useQuery.Options<\n    NoInfer<TData>,\n    NoInfer<TVariables>\n  > = {} as useQuery.Options<TData, TVariables>\n): useQuery.Result<TData, TVariables> {\n  const client = useApolloClient(options.client);\n  const { skip, ssr, ...opts } = options;\n\n  const watchQueryOptions: ApolloClient.WatchQueryOptions<TData, TVariables> =\n    mergeOptions(client.defaultOptions.watchQuery as any, { ...opts, query });\n\n  if (skip) {\n    // When skipping, we set watchQueryOptions.fetchPolicy initially to\n    // \"standby\", but we also need/want to preserve the initial non-standby\n    // fetchPolicy that would have been used if not skipping.\n    watchQueryOptions.initialFetchPolicy =\n      options.initialFetchPolicy || options.fetchPolicy;\n    watchQueryOptions.fetchPolicy = \"standby\";\n  }\n\n  function createState(\n    previous?: InternalState<TData, TVariables>\n  ): InternalState<TData, TVariables> {\n    const observable = client.watchQuery(watchQueryOptions);\n\n    return {\n      client,\n      query,\n      observable,\n      resultData: {\n        current: observable.getCurrentResult(),\n        // Reuse previousData from previous InternalState (if any) to provide\n        // continuity of previousData even if/when the query or client changes.\n        previousData: previous?.resultData.current.data as TData,\n        variables: observable.variables,\n      },\n    };\n  }\n\n  let [state, setState] = React.useState(createState);\n\n  if (client !== state.client || query !== state.query) {\n    // If the client or query have changed, we need to create a new InternalState.\n    // This will trigger a re-render with the new state, but it will also continue\n    // to run the current render function to completion.\n    // Since we sometimes trigger some side-effects in the render function, we\n    // re-assign `state` to the new state to ensure that those side-effects are\n    // triggered with the new state.\n    setState((state = createState(state)));\n  }\n\n  const { observable, resultData } = state;\n\n  useInitialFetchPolicyIfNecessary<TData, TVariables>(\n    watchQueryOptions,\n    observable\n  );\n\n  useResubscribeIfNecessary<TData, TVariables>(\n    resultData, // might get mutated during render\n    observable, // might get mutated during render\n    watchQueryOptions\n  );\n\n  const result = useResult<TData, TVariables>(\n    observable,\n    resultData,\n    options.ssr\n  );\n\n  const obsQueryFields = React.useMemo(\n    () => ({\n      refetch: observable.refetch.bind(observable),\n      fetchMore: observable.fetchMore.bind(observable),\n      updateQuery: observable.updateQuery.bind(observable),\n      startPolling: observable.startPolling.bind(observable),\n      stopPolling: observable.stopPolling.bind(observable),\n      subscribeToMore: observable.subscribeToMore.bind(observable),\n    }),\n    [observable]\n  );\n\n  const previousData = resultData.previousData;\n  return React.useMemo(() => {\n    const { partial, ...rest } = result;\n\n    return {\n      ...rest,\n      client,\n      observable,\n      variables: observable.variables,\n      previousData,\n      ...obsQueryFields,\n    };\n  }, [result, client, observable, previousData, obsQueryFields]);\n}\n\nfunction useInitialFetchPolicyIfNecessary<\n  TData,\n  TVariables extends OperationVariables,\n>(\n  watchQueryOptions: ApolloClient.WatchQueryOptions<TData, TVariables>,\n  observable: ObsQueryWithMeta<TData, TVariables>\n) {\n  \"use no memo\";\n  if (!watchQueryOptions.fetchPolicy) {\n    watchQueryOptions.fetchPolicy = observable.options.initialFetchPolicy;\n  }\n}\n\nfunction useResult<TData, TVariables extends OperationVariables>(\n  observable: ObsQueryWithMeta<TData, TVariables>,\n  resultData: InternalResult<TData>,\n  ssr: boolean | undefined\n) {\n  \"use no memo\";\n  return useSyncExternalStore(\n    React.useCallback(\n      (handleStoreChange) => {\n        const subscription = observable\n          // We use the asapScheduler here to prevent issues with trying to\n          // update in the middle of a render. `reobserve` is kicked off in the\n          // middle of a render and because RxJS emits values synchronously,\n          // its possible for this `handleStoreChange` to be called in that same\n          // render. This allows the render to complete before trying to emit a\n          // new value.\n          .pipe(observeOn(asapScheduler))\n          .subscribe((result) => {\n            const previous = resultData.current;\n\n            if (\n              // Avoid rerendering if the result is the same\n              equal(previous, result) &&\n              // Force rerender if the value was emitted because variables\n              // changed, such as when calling `refetch(newVars)` which returns\n              // the same data when `notifyOnNetworkStatusChange` is `false`.\n              equal(resultData.variables, observable.variables)\n            ) {\n              return;\n            }\n\n            // eslint-disable-next-line react-compiler/react-compiler\n            resultData.variables = observable.variables;\n\n            if (previous.data && !equal(previous.data, result.data)) {\n              resultData.previousData = previous.data as TData;\n            }\n\n            resultData.current = result;\n            handleStoreChange();\n          });\n\n        // Do the \"unsubscribe\" with a short delay.\n        // This way, an existing subscription can be reused without an additional\n        // request if \"unsubscribe\"  and \"resubscribe\" to the same ObservableQuery\n        // happen in very fast succession.\n        return () => {\n          setTimeout(() => subscription.unsubscribe());\n        };\n      },\n\n      [observable, resultData]\n    ),\n    () => resultData.current,\n    () => (ssr === false ? useQuery.ssrDisabledResult : resultData.current)\n  );\n}\n\n// this hook is not compatible with any rules of React, and there's no good way to rewrite it.\n// it should stay a separate hook that will not be optimized by the compiler\nfunction useResubscribeIfNecessary<\n  TData,\n  TVariables extends OperationVariables,\n>(\n  /** this hook will mutate properties on `resultData` */\n  resultData: InternalResult<TData>,\n  /** this hook will mutate properties on `observable` */\n  observable: ObsQueryWithMeta<TData, TVariables>,\n  watchQueryOptions: Readonly<ApolloClient.WatchQueryOptions<TData, TVariables>>\n) {\n  \"use no memo\";\n  if (\n    observable[lastWatchOptions] &&\n    !equal(observable[lastWatchOptions], watchQueryOptions)\n  ) {\n    // Though it might be tempting to postpone this reobserve call to the\n    // useEffect block, we need getCurrentResult to return an appropriate\n    // loading:true result synchronously (later within the same call to\n    // useQuery). Since we already have this.observable here (not true for\n    // the very first call to useQuery), we are not initiating any new\n    // subscriptions, though it does feel less than ideal that reobserve\n    // (potentially) kicks off a network request (for example, when the\n    // variables have changed), which is technically a side-effect.\n    if (shouldReobserve(observable[lastWatchOptions], watchQueryOptions)) {\n      observable.reobserve(watchQueryOptions);\n    } else {\n      observable.applyOptions(watchQueryOptions);\n    }\n\n    // Make sure getCurrentResult returns a fresh ApolloQueryResult<TData>,\n    // but save the current data as this.previousData, just like setResult\n    // usually does.\n    const result = observable.getCurrentResult();\n\n    if (!equal(result.data, resultData.current.data)) {\n      resultData.previousData = (resultData.current.data ||\n        (resultData.previousData as TData)) as TData;\n    }\n    resultData.current = result;\n    resultData.variables = observable.variables;\n  }\n  observable[lastWatchOptions] = watchQueryOptions;\n}\n\nfunction shouldReobserve<TData, TVariables extends OperationVariables>(\n  previousOptions: Readonly<ApolloClient.WatchQueryOptions<TData, TVariables>>,\n  options: Readonly<ApolloClient.WatchQueryOptions<TData, TVariables>>\n) {\n  return (\n    previousOptions.query !== options.query ||\n    !equal(previousOptions.variables, options.variables) ||\n    (previousOptions.fetchPolicy !== options.fetchPolicy &&\n      (options.fetchPolicy === \"standby\" ||\n        previousOptions.fetchPolicy === \"standby\"))\n  );\n}\n\nuseQuery.ssrDisabledResult = maybeDeepFreeze({\n  loading: true,\n  data: void 0 as any,\n  dataState: \"empty\",\n  error: void 0,\n  networkStatus: NetworkStatus.loading,\n  partial: true,\n}) satisfies ObservableQuery.Result<any> as ObservableQuery.Result<any>;\n"],"mappings":"AAAA;;;;;;;;;;;;AAYA;AACA,SAASA,KAAK,QAAQ,eAAe;AACrC,OAAO,KAAKC,KAAK,MAAM,OAAO;AAC9B,SAASC,aAAa,EAAEC,SAAS,QAAQ,MAAM;AAmB/C,SAASC,aAAa,QAAQ,gBAAgB;AAO9C,SACEC,eAAe,EACfC,YAAY,QACP,mCAAmC;AAE1C,SAASC,QAAQ,QAAQ,qBAAqB;AAC9C,SAASC,eAAe,QAAQ,sBAAsB;AACtD,SAASC,oBAAoB,QAAQ,2BAA2B;AA6JhE,MAAMC,gBAAgB,GAAGC,MAAM,EAAE;AAwGjC,OAAM,SAAUC,QAAQA,CAItBC,KAA0D,EAC1D,GAAG,CAACC,OAAO,CAEuD;EAElE,aAAa;;EACb,OAAOP,QAAQ,CACb,UAAU;EACV;EACAQ,SAAS,EACTP,eAAe,CAACM,OAAO,IAAIA,OAAO,CAACE,MAAM,CAAC,CAC3C,CAACH,KAAK,EAAEC,OAAO,CAAC;AACnB;AAEA,SAASC,SAASA,CAChBF,KAA0D,EAC1DC,OAAA,GAGI,EAAyC;EAE7C,MAAME,MAAM,GAAGR,eAAe,CAACM,OAAO,CAACE,MAAM,CAAC;EAC9C,MAAM;IAAEC,IAAI;IAAEC,GAAG;IAAE,GAAGC;EAAI,CAAE,GAAGL,OAAO;EAEtC,MAAMM,iBAAiB,GACrBd,YAAY,CAACU,MAAM,CAACK,cAAc,CAACC,UAAiB,EAAE;IAAE,GAAGH,IAAI;IAAEN;EAAK,CAAE,CAAC;EAE3E,IAAII,IAAI,EAAE;IACR;IACA;IACA;IACAG,iBAAiB,CAACG,kBAAkB,GAClCT,OAAO,CAACS,kBAAkB,IAAIT,OAAO,CAACU,WAAW;IACnDJ,iBAAiB,CAACI,WAAW,GAAG,SAAS;EAC3C;EAEA,SAASC,WAAWA,CAClBC,QAA2C;IAE3C,MAAMC,UAAU,GAAGX,MAAM,CAACM,UAAU,CAACF,iBAAiB,CAAC;IAEvD,OAAO;MACLJ,MAAM;MACNH,KAAK;MACLc,UAAU;MACVC,UAAU,EAAE;QACVC,OAAO,EAAEF,UAAU,CAACG,gBAAgB,EAAE;QACtC;QACA;QACAC,YAAY,EAAEL,QAAQ,EAAEE,UAAU,CAACC,OAAO,CAACG,IAAa;QACxDC,SAAS,EAAEN,UAAU,CAACM;;KAEzB;EACH;EAEA,IAAI,CAACC,KAAK,EAAEC,QAAQ,CAAC,GAAGlC,KAAK,CAACmC,QAAQ,CAACX,WAAW,CAAC;EAEnD,IAAIT,MAAM,KAAKkB,KAAK,CAAClB,MAAM,IAAIH,KAAK,KAAKqB,KAAK,CAACrB,KAAK,EAAE;IACpD;IACA;IACA;IACA;IACA;IACA;IACAsB,QAAQ,CAAED,KAAK,GAAGT,WAAW,CAACS,KAAK,CAAE,CAAC;EACxC;EAEA,MAAM;IAAEP,UAAU;IAAEC;EAAU,CAAE,GAAGM,KAAK;EAExCG,gCAAgC,CAC9BjB,iBAAiB,EACjBO,UAAU,CACX;EAEDW,yBAAyB,CACvBV,UAAU;EAAE;EACZD,UAAU;EAAE;EACZP,iBAAiB,CAClB;EAED,MAAMmB,MAAM,GAAGC,SAAS,CACtBb,UAAU,EACVC,UAAU,EACVd,OAAO,CAACI,GAAG,CACZ;EAED,MAAMuB,cAAc,GAAGxC,KAAK,CAACyC,OAAO,CAClC,OAAO;IACLC,OAAO,EAAEhB,UAAU,CAACgB,OAAO,CAACC,IAAI,CAACjB,UAAU,CAAC;IAC5CkB,SAAS,EAAElB,UAAU,CAACkB,SAAS,CAACD,IAAI,CAACjB,UAAU,CAAC;IAChDmB,WAAW,EAAEnB,UAAU,CAACmB,WAAW,CAACF,IAAI,CAACjB,UAAU,CAAC;IACpDoB,YAAY,EAAEpB,UAAU,CAACoB,YAAY,CAACH,IAAI,CAACjB,UAAU,CAAC;IACtDqB,WAAW,EAAErB,UAAU,CAACqB,WAAW,CAACJ,IAAI,CAACjB,UAAU,CAAC;IACpDsB,eAAe,EAAEtB,UAAU,CAACsB,eAAe,CAACL,IAAI,CAACjB,UAAU;GAC5D,CAAC,EACF,CAACA,UAAU,CAAC,CACb;EAED,MAAMI,YAAY,GAAGH,UAAU,CAACG,YAAY;EAC5C,OAAO9B,KAAK,CAACyC,OAAO,CAAC,MAAK;IACxB,MAAM;MAAEQ,OAAO;MAAE,GAAGC;IAAI,CAAE,GAAGZ,MAAM;IAEnC,OAAO;MACL,GAAGY,IAAI;MACPnC,MAAM;MACNW,UAAU;MACVM,SAAS,EAAEN,UAAU,CAACM,SAAS;MAC/BF,YAAY;MACZ,GAAGU;KACJ;EACH,CAAC,EAAE,CAACF,MAAM,EAAEvB,MAAM,EAAEW,UAAU,EAAEI,YAAY,EAAEU,cAAc,CAAC,CAAC;AAChE;AAEA,SAASJ,gCAAgCA,CAIvCjB,iBAAoE,EACpEO,UAA+C;EAE/C,aAAa;;EACb,IAAI,CAACP,iBAAiB,CAACI,WAAW,EAAE;IAClCJ,iBAAiB,CAACI,WAAW,GAAGG,UAAU,CAACb,OAAO,CAACS,kBAAkB;EACvE;AACF;AAEA,SAASiB,SAASA,CAChBb,UAA+C,EAC/CC,UAAiC,EACjCV,GAAwB;EAExB,aAAa;;EACb,OAAOT,oBAAoB,CACzBR,KAAK,CAACmD,WAAW,CACdC,iBAAiB,IAAI;IACpB,MAAMC,YAAY,GAAG3B;IACnB;IACA;IACA;IACA;IACA;IACA;IAAA,CACC4B,IAAI,CAACpD,SAAS,CAACD,aAAa,CAAC,CAAC,CAC9BsD,SAAS,CAAEjB,MAAM,IAAI;MACpB,MAAMb,QAAQ,GAAGE,UAAU,CAACC,OAAO;MAEnC;MACE;MACA7B,KAAK,CAAC0B,QAAQ,EAAEa,MAAM,CAAC;MACvB;MACA;MACA;MACAvC,KAAK,CAAC4B,UAAU,CAACK,SAAS,EAAEN,UAAU,CAACM,SAAS,CAAC,EACjD;QACA;MACF;MAEA;MACAL,UAAU,CAACK,SAAS,GAAGN,UAAU,CAACM,SAAS;MAE3C,IAAIP,QAAQ,CAACM,IAAI,IAAI,CAAChC,KAAK,CAAC0B,QAAQ,CAACM,IAAI,EAAEO,MAAM,CAACP,IAAI,CAAC,EAAE;QACvDJ,UAAU,CAACG,YAAY,GAAGL,QAAQ,CAACM,IAAa;MAClD;MAEAJ,UAAU,CAACC,OAAO,GAAGU,MAAM;MAC3Bc,iBAAiB,EAAE;IACrB,CAAC,CAAC;IAEJ;IACA;IACA;IACA;IACA,OAAO,MAAK;MACVI,UAAU,CAAC,MAAMH,YAAY,CAACI,WAAW,EAAE,CAAC;IAC9C,CAAC;EACH,CAAC,EAED,CAAC/B,UAAU,EAAEC,UAAU,CAAC,CACzB,EACD,MAAMA,UAAU,CAACC,OAAO,EACxB,MAAOX,GAAG,KAAK,KAAK,GAAGN,QAAQ,CAAC+C,iBAAiB,GAAG/B,UAAU,CAACC,OAAQ,CACxE;AACH;AAEA;AACA;AACA,SAASS,yBAAyBA,CAIhC;AACAV,UAAiC,EACjC;AACAD,UAA+C,EAC/CP,iBAA8E;EAE9E,aAAa;;EACb,IACEO,UAAU,CAACjB,gBAAgB,CAAC,IAC5B,CAACV,KAAK,CAAC2B,UAAU,CAACjB,gBAAgB,CAAC,EAAEU,iBAAiB,CAAC,EACvD;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAIwC,eAAe,CAACjC,UAAU,CAACjB,gBAAgB,CAAC,EAAEU,iBAAiB,CAAC,EAAE;MACpEO,UAAU,CAACkC,SAAS,CAACzC,iBAAiB,CAAC;IACzC,CAAC,MAAM;MACLO,UAAU,CAACmC,YAAY,CAAC1C,iBAAiB,CAAC;IAC5C;IAEA;IACA;IACA;IACA,MAAMmB,MAAM,GAAGZ,UAAU,CAACG,gBAAgB,EAAE;IAE5C,IAAI,CAAC9B,KAAK,CAACuC,MAAM,CAACP,IAAI,EAAEJ,UAAU,CAACC,OAAO,CAACG,IAAI,CAAC,EAAE;MAChDJ,UAAU,CAACG,YAAY,GAAIH,UAAU,CAACC,OAAO,CAACG,IAAI,IAC/CJ,UAAU,CAACG,YAAgC;IAChD;IACAH,UAAU,CAACC,OAAO,GAAGU,MAAM;IAC3BX,UAAU,CAACK,SAAS,GAAGN,UAAU,CAACM,SAAS;EAC7C;EACAN,UAAU,CAACjB,gBAAgB,CAAC,GAAGU,iBAAiB;AAClD;AAEA,SAASwC,eAAeA,CACtBG,eAA4E,EAC5EjD,OAAoE;EAEpE,OACEiD,eAAe,CAAClD,KAAK,KAAKC,OAAO,CAACD,KAAK,IACvC,CAACb,KAAK,CAAC+D,eAAe,CAAC9B,SAAS,EAAEnB,OAAO,CAACmB,SAAS,CAAC,IACnD8B,eAAe,CAACvC,WAAW,KAAKV,OAAO,CAACU,WAAW,KACjDV,OAAO,CAACU,WAAW,KAAK,SAAS,IAChCuC,eAAe,CAACvC,WAAW,KAAK,SAAS,CAAE;AAEnD;AAEAZ,QAAQ,CAAC+C,iBAAiB,GAAGtD,eAAe,CAAC;EAC3C2D,OAAO,EAAE,IAAI;EACbhC,IAAI,EAAE,KAAK,CAAQ;EACnBiC,SAAS,EAAE,OAAO;EAClBC,KAAK,EAAE,KAAK,CAAC;EACbC,aAAa,EAAE/D,aAAa,CAAC4D,OAAO;EACpCd,OAAO,EAAE;CACV,CAAsE","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}