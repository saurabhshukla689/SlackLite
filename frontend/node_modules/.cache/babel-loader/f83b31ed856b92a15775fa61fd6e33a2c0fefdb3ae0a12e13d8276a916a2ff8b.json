{"ast":null,"code":"import { argumentsObjectFromField, DeepMerger, isArray, isNonEmptyArray, isNonNullObject } from \"@apollo/client/utilities/internal\";\nimport { invariant } from \"@apollo/client/utilities/invariant\";\nimport { hasOwn } from \"./helpers.js\";\n// Mapping from JSON-encoded KeySpecifier strings to associated information.\nconst specifierInfoCache = {};\nfunction lookupSpecifierInfo(spec) {\n  // It's safe to encode KeySpecifier arrays with JSON.stringify, since they're\n  // just arrays of strings or nested KeySpecifier arrays, and the order of the\n  // array elements is important (and suitably preserved by JSON.stringify).\n  const cacheKey = JSON.stringify(spec);\n  return specifierInfoCache[cacheKey] || (specifierInfoCache[cacheKey] = {});\n}\nexport function keyFieldsFnFromSpecifier(specifier) {\n  const info = lookupSpecifierInfo(specifier);\n  return info.keyFieldsFn || (info.keyFieldsFn = (object, context) => {\n    const extract = (from, key) => context.readField(key, from);\n    const keyObject = context.keyObject = collectSpecifierPaths(specifier, schemaKeyPath => {\n      let extracted = extractKeyPath(context.storeObject, schemaKeyPath,\n      // Using context.readField to extract paths from context.storeObject\n      // allows the extraction to see through Reference objects and respect\n      // custom read functions.\n      extract);\n      if (extracted === void 0 && object !== context.storeObject && hasOwn.call(object, schemaKeyPath[0])) {\n        // If context.storeObject fails to provide a value for the requested\n        // path, fall back to the raw result object, if it has a top-level key\n        // matching the first key in the path (schemaKeyPath[0]). This allows\n        // key fields included in the written data to be saved in the cache\n        // even if they are not selected explicitly in context.selectionSet.\n        // Not being mentioned by context.selectionSet is convenient here,\n        // since it means these extra fields cannot be affected by field\n        // aliasing, which is why we can use extractKey instead of\n        // context.readField for this extraction.\n        extracted = extractKeyPath(object, schemaKeyPath, extractKey);\n      }\n      invariant(extracted !== void 0, 98, schemaKeyPath.join(\".\"), object);\n      return extracted;\n    });\n    return `${context.typename}:${JSON.stringify(keyObject)}`;\n  });\n}\n// The keyArgs extraction process is roughly analogous to keyFields extraction,\n// but there are no aliases involved, missing fields are tolerated (by merely\n// omitting them from the key), and drawing from field.directives or variables\n// is allowed (in addition to drawing from the field's arguments object).\n// Concretely, these differences mean passing a different key path extractor\n// function to collectSpecifierPaths, reusing the shared extractKeyPath helper\n// wherever possible.\nexport function keyArgsFnFromSpecifier(specifier) {\n  const info = lookupSpecifierInfo(specifier);\n  return info.keyArgsFn || (info.keyArgsFn = (args, {\n    field,\n    variables,\n    fieldName\n  }) => {\n    const collected = collectSpecifierPaths(specifier, keyPath => {\n      const firstKey = keyPath[0];\n      const firstChar = firstKey.charAt(0);\n      if (firstChar === \"@\") {\n        if (field && isNonEmptyArray(field.directives)) {\n          const directiveName = firstKey.slice(1);\n          // If the directive appears multiple times, only the first\n          // occurrence's arguments will be used. TODO Allow repetition?\n          // TODO Cache this work somehow, a la aliasMap?\n          const d = field.directives.find(d => d.name.value === directiveName);\n          // Fortunately argumentsObjectFromField works for DirectiveNode!\n          const directiveArgs = d && argumentsObjectFromField(d, variables);\n          // For directives without arguments (d defined, but directiveArgs ===\n          // null), the presence or absence of the directive still counts as\n          // part of the field key, so we return null in those cases. If no\n          // directive with this name was found for this field (d undefined and\n          // thus directiveArgs undefined), we return undefined, which causes\n          // this value to be omitted from the key object returned by\n          // collectSpecifierPaths.\n          return directiveArgs && extractKeyPath(directiveArgs,\n          // If keyPath.length === 1, this code calls extractKeyPath with an\n          // empty path, which works because it uses directiveArgs as the\n          // extracted value.\n          keyPath.slice(1));\n        }\n        // If the key started with @ but there was no corresponding directive,\n        // we want to omit this value from the key object, not fall through to\n        // treating @whatever as a normal argument name.\n        return;\n      }\n      if (firstChar === \"$\") {\n        const variableName = firstKey.slice(1);\n        if (variables && hasOwn.call(variables, variableName)) {\n          const varKeyPath = keyPath.slice(0);\n          varKeyPath[0] = variableName;\n          return extractKeyPath(variables, varKeyPath);\n        }\n        // If the key started with $ but there was no corresponding variable, we\n        // want to omit this value from the key object, not fall through to\n        // treating $whatever as a normal argument name.\n        return;\n      }\n      if (args) {\n        return extractKeyPath(args, keyPath);\n      }\n    });\n    const suffix = JSON.stringify(collected);\n    // If no arguments were passed to this field, and it didn't have any other\n    // field key contributions from directives or variables, hide the empty\n    // :{} suffix from the field key. However, a field passed no arguments can\n    // still end up with a non-empty :{...} suffix if its key configuration\n    // refers to directives or variables.\n    if (args || suffix !== \"{}\") {\n      fieldName += \":\" + suffix;\n    }\n    return fieldName;\n  });\n}\nexport function collectSpecifierPaths(specifier, extractor) {\n  // For each path specified by specifier, invoke the extractor, and repeatedly\n  // merge the results together, with appropriate ancestor context.\n  const merger = new DeepMerger();\n  return getSpecifierPaths(specifier).reduce((collected, path) => {\n    let toMerge = extractor(path);\n    if (toMerge !== void 0) {\n      // This path is not expected to contain array indexes, so the toMerge\n      // reconstruction will not contain arrays. TODO Fix this?\n      for (let i = path.length - 1; i >= 0; --i) {\n        toMerge = {\n          [path[i]]: toMerge\n        };\n      }\n      collected = merger.merge(collected, toMerge);\n    }\n    return collected;\n  }, {});\n}\nexport function getSpecifierPaths(spec) {\n  const info = lookupSpecifierInfo(spec);\n  if (!info.paths) {\n    const paths = info.paths = [];\n    const currentPath = [];\n    spec.forEach((s, i) => {\n      if (isArray(s)) {\n        getSpecifierPaths(s).forEach(p => paths.push(currentPath.concat(p)));\n        currentPath.length = 0;\n      } else {\n        currentPath.push(s);\n        if (!isArray(spec[i + 1])) {\n          paths.push(currentPath.slice(0));\n          currentPath.length = 0;\n        }\n      }\n    });\n  }\n  return info.paths;\n}\nfunction extractKey(object, key) {\n  return object[key];\n}\nexport function extractKeyPath(object, path, extract) {\n  // For each key in path, extract the corresponding child property from obj,\n  // flattening arrays if encountered (uncommon for keyFields and keyArgs, but\n  // possible). The final result of path.reduce is normalized so unexpected leaf\n  // objects have their keys safely sorted. That final result is difficult to\n  // type as anything other than any. You're welcome to try to improve the\n  // return type, but keep in mind extractKeyPath is not a public function\n  // (exported only for testing), so the effort may not be worthwhile unless the\n  // limited set of actual callers (see above) pass arguments that TypeScript\n  // can statically type. If we know only that path is some array of strings\n  // (and not, say, a specific tuple of statically known strings), any (or\n  // possibly unknown) is the honest answer.\n  extract = extract || extractKey;\n  return normalize(path.reduce(function reducer(obj, key) {\n    return isArray(obj) ? obj.map(child => reducer(child, key)) : obj && extract(obj, key);\n  }, object));\n}\nfunction normalize(value) {\n  // Usually the extracted value will be a scalar value, since most primary\n  // key fields are scalar, but just in case we get an object or an array, we\n  // need to do some normalization of the order of (nested) keys.\n  if (isNonNullObject(value)) {\n    if (isArray(value)) {\n      return value.map(normalize);\n    }\n    return collectSpecifierPaths(Object.keys(value).sort(), path => extractKeyPath(value, path));\n  }\n  return value;\n}","map":{"version":3,"names":["argumentsObjectFromField","DeepMerger","isArray","isNonEmptyArray","isNonNullObject","invariant","hasOwn","specifierInfoCache","lookupSpecifierInfo","spec","cacheKey","JSON","stringify","keyFieldsFnFromSpecifier","specifier","info","keyFieldsFn","object","context","extract","from","key","readField","keyObject","collectSpecifierPaths","schemaKeyPath","extracted","extractKeyPath","storeObject","call","extractKey","join","typename","keyArgsFnFromSpecifier","keyArgsFn","args","field","variables","fieldName","collected","keyPath","firstKey","firstChar","charAt","directives","directiveName","slice","d","find","name","value","directiveArgs","variableName","varKeyPath","suffix","extractor","merger","getSpecifierPaths","reduce","path","toMerge","i","length","merge","paths","currentPath","forEach","s","p","push","concat","normalize","reducer","obj","map","child","Object","keys","sort"],"sources":["/home/saurabh-shukla/Desktop/Slack Lite/frontend/node_modules/@apollo/src/cache/inmemory/key-extractor.ts"],"sourcesContent":["import {\n  argumentsObjectFromField,\n  DeepMerger,\n  isArray,\n  isNonEmptyArray,\n  isNonNullObject,\n} from \"@apollo/client/utilities/internal\";\nimport { invariant } from \"@apollo/client/utilities/invariant\";\n\nimport { hasOwn } from \"./helpers.js\";\nimport type {\n  KeyArgsFunction,\n  KeyFieldsFunction,\n  KeySpecifier,\n} from \"./policies.js\";\n\n// Mapping from JSON-encoded KeySpecifier strings to associated information.\nconst specifierInfoCache: Record<\n  string,\n  {\n    paths?: string[][];\n    keyFieldsFn?: KeyFieldsFunction;\n    keyArgsFn?: KeyArgsFunction;\n  }\n> = {};\n\nfunction lookupSpecifierInfo(spec: KeySpecifier) {\n  // It's safe to encode KeySpecifier arrays with JSON.stringify, since they're\n  // just arrays of strings or nested KeySpecifier arrays, and the order of the\n  // array elements is important (and suitably preserved by JSON.stringify).\n  const cacheKey = JSON.stringify(spec);\n  return specifierInfoCache[cacheKey] || (specifierInfoCache[cacheKey] = {});\n}\n\nexport function keyFieldsFnFromSpecifier(\n  specifier: KeySpecifier\n): KeyFieldsFunction {\n  const info = lookupSpecifierInfo(specifier);\n\n  return (\n    info.keyFieldsFn ||\n    (info.keyFieldsFn = (object, context) => {\n      const extract: typeof extractKey = (from, key) =>\n        context.readField(key, from);\n\n      const keyObject = (context.keyObject = collectSpecifierPaths(\n        specifier,\n        (schemaKeyPath) => {\n          let extracted = extractKeyPath(\n            context.storeObject,\n            schemaKeyPath,\n            // Using context.readField to extract paths from context.storeObject\n            // allows the extraction to see through Reference objects and respect\n            // custom read functions.\n            extract\n          );\n\n          if (\n            extracted === void 0 &&\n            object !== context.storeObject &&\n            hasOwn.call(object, schemaKeyPath[0])\n          ) {\n            // If context.storeObject fails to provide a value for the requested\n            // path, fall back to the raw result object, if it has a top-level key\n            // matching the first key in the path (schemaKeyPath[0]). This allows\n            // key fields included in the written data to be saved in the cache\n            // even if they are not selected explicitly in context.selectionSet.\n            // Not being mentioned by context.selectionSet is convenient here,\n            // since it means these extra fields cannot be affected by field\n            // aliasing, which is why we can use extractKey instead of\n            // context.readField for this extraction.\n            extracted = extractKeyPath(object, schemaKeyPath, extractKey);\n          }\n\n          invariant(\n            extracted !== void 0,\n            `Missing field '%s' while extracting keyFields from %s`,\n            schemaKeyPath.join(\".\"),\n            object\n          );\n\n          return extracted;\n        }\n      ));\n\n      return `${context.typename}:${JSON.stringify(keyObject)}`;\n    })\n  );\n}\n\n// The keyArgs extraction process is roughly analogous to keyFields extraction,\n// but there are no aliases involved, missing fields are tolerated (by merely\n// omitting them from the key), and drawing from field.directives or variables\n// is allowed (in addition to drawing from the field's arguments object).\n// Concretely, these differences mean passing a different key path extractor\n// function to collectSpecifierPaths, reusing the shared extractKeyPath helper\n// wherever possible.\nexport function keyArgsFnFromSpecifier(\n  specifier: KeySpecifier\n): KeyArgsFunction {\n  const info = lookupSpecifierInfo(specifier);\n\n  return (\n    info.keyArgsFn ||\n    (info.keyArgsFn = (args, { field, variables, fieldName }) => {\n      const collected = collectSpecifierPaths(specifier, (keyPath) => {\n        const firstKey = keyPath[0];\n        const firstChar = firstKey.charAt(0);\n\n        if (firstChar === \"@\") {\n          if (field && isNonEmptyArray(field.directives)) {\n            const directiveName = firstKey.slice(1);\n            // If the directive appears multiple times, only the first\n            // occurrence's arguments will be used. TODO Allow repetition?\n            // TODO Cache this work somehow, a la aliasMap?\n            const d = field.directives.find(\n              (d) => d.name.value === directiveName\n            );\n            // Fortunately argumentsObjectFromField works for DirectiveNode!\n            const directiveArgs = d && argumentsObjectFromField(d, variables);\n            // For directives without arguments (d defined, but directiveArgs ===\n            // null), the presence or absence of the directive still counts as\n            // part of the field key, so we return null in those cases. If no\n            // directive with this name was found for this field (d undefined and\n            // thus directiveArgs undefined), we return undefined, which causes\n            // this value to be omitted from the key object returned by\n            // collectSpecifierPaths.\n            return (\n              directiveArgs &&\n              extractKeyPath(\n                directiveArgs,\n                // If keyPath.length === 1, this code calls extractKeyPath with an\n                // empty path, which works because it uses directiveArgs as the\n                // extracted value.\n                keyPath.slice(1)\n              )\n            );\n          }\n          // If the key started with @ but there was no corresponding directive,\n          // we want to omit this value from the key object, not fall through to\n          // treating @whatever as a normal argument name.\n          return;\n        }\n\n        if (firstChar === \"$\") {\n          const variableName = firstKey.slice(1);\n          if (variables && hasOwn.call(variables, variableName)) {\n            const varKeyPath = keyPath.slice(0);\n            varKeyPath[0] = variableName;\n            return extractKeyPath(variables, varKeyPath);\n          }\n          // If the key started with $ but there was no corresponding variable, we\n          // want to omit this value from the key object, not fall through to\n          // treating $whatever as a normal argument name.\n          return;\n        }\n\n        if (args) {\n          return extractKeyPath(args, keyPath);\n        }\n      });\n\n      const suffix = JSON.stringify(collected);\n\n      // If no arguments were passed to this field, and it didn't have any other\n      // field key contributions from directives or variables, hide the empty\n      // :{} suffix from the field key. However, a field passed no arguments can\n      // still end up with a non-empty :{...} suffix if its key configuration\n      // refers to directives or variables.\n      if (args || suffix !== \"{}\") {\n        fieldName += \":\" + suffix;\n      }\n\n      return fieldName;\n    })\n  );\n}\n\nexport function collectSpecifierPaths(\n  specifier: KeySpecifier,\n  extractor: (path: string[]) => any\n): Record<string, any> {\n  // For each path specified by specifier, invoke the extractor, and repeatedly\n  // merge the results together, with appropriate ancestor context.\n  const merger = new DeepMerger();\n  return getSpecifierPaths(specifier).reduce((collected, path) => {\n    let toMerge = extractor(path);\n    if (toMerge !== void 0) {\n      // This path is not expected to contain array indexes, so the toMerge\n      // reconstruction will not contain arrays. TODO Fix this?\n      for (let i = path.length - 1; i >= 0; --i) {\n        toMerge = { [path[i]]: toMerge };\n      }\n      collected = merger.merge(collected, toMerge);\n    }\n    return collected;\n  }, {});\n}\n\nexport function getSpecifierPaths(spec: KeySpecifier): string[][] {\n  const info = lookupSpecifierInfo(spec);\n\n  if (!info.paths) {\n    const paths: string[][] = (info.paths = []);\n    const currentPath: string[] = [];\n\n    spec.forEach((s, i) => {\n      if (isArray(s)) {\n        getSpecifierPaths(s).forEach((p) => paths.push(currentPath.concat(p)));\n        currentPath.length = 0;\n      } else {\n        currentPath.push(s);\n        if (!isArray(spec[i + 1])) {\n          paths.push(currentPath.slice(0));\n          currentPath.length = 0;\n        }\n      }\n    });\n  }\n\n  return info.paths!;\n}\n\nfunction extractKey<TObj extends Record<string, any>, TKey extends string>(\n  object: TObj,\n  key: TKey\n): TObj[TKey] | undefined {\n  return object[key];\n}\n\nexport function extractKeyPath(\n  object: Record<string, any>,\n  path: string[],\n  extract?: typeof extractKey\n): any {\n  // For each key in path, extract the corresponding child property from obj,\n  // flattening arrays if encountered (uncommon for keyFields and keyArgs, but\n  // possible). The final result of path.reduce is normalized so unexpected leaf\n  // objects have their keys safely sorted. That final result is difficult to\n  // type as anything other than any. You're welcome to try to improve the\n  // return type, but keep in mind extractKeyPath is not a public function\n  // (exported only for testing), so the effort may not be worthwhile unless the\n  // limited set of actual callers (see above) pass arguments that TypeScript\n  // can statically type. If we know only that path is some array of strings\n  // (and not, say, a specific tuple of statically known strings), any (or\n  // possibly unknown) is the honest answer.\n  extract = extract || extractKey;\n  return normalize(\n    path.reduce(function reducer(obj, key): any {\n      return isArray(obj) ?\n          obj.map((child) => reducer(child, key))\n        : obj && extract!(obj, key);\n    }, object)\n  );\n}\n\nfunction normalize<T>(value: T): T {\n  // Usually the extracted value will be a scalar value, since most primary\n  // key fields are scalar, but just in case we get an object or an array, we\n  // need to do some normalization of the order of (nested) keys.\n  if (isNonNullObject(value)) {\n    if (isArray(value)) {\n      return value.map(normalize) as any;\n    }\n    return collectSpecifierPaths(Object.keys(value).sort(), (path) =>\n      extractKeyPath(value, path)\n    ) as T;\n  }\n  return value;\n}\n"],"mappings":"AAAA,SACEA,wBAAwB,EACxBC,UAAU,EACVC,OAAO,EACPC,eAAe,EACfC,eAAe,QACV,mCAAmC;AAC1C,SAASC,SAAT,QAA0B,oCAAoC;AAE9D,SAASC,MAAT,QAAuB,cAAc;AAOrC;AACA,MAAMC,kBAAN,GAOI,CAPJ,CAOM;AAEN,SAASC,mBAAmBA,CAACC,IAAkB,EAA/C;EACE;EACA;EACA;EACA,MAAMC,QAAR,GAAmBC,IAAI,CAACC,SAAS,CAACH,IAAI,CAAC;EACrC,OAAOF,kBAAkB,CAACG,QAAQ,MAAMH,kBAAkB,CAACG,QAAQ,IAAI,CAAzE,CAA2E,CAAC;AAC5E;AAEA,gBAAgBG,wBAAwBA,CACtCC,SAAuB,EADzB;EAGE,MAAMC,IAAR,GAAeP,mBAAmB,CAACM,SAAS,CAAC;SAGzCC,IAAI,CAACC,WADT,KAEKD,IAAI,CAACC,WAAV,GAAwB,CAACC,MAAM,EAAEC,OAAO,KAAxC;IACM,MAAMC,OAAZ,GAAyCA,CAACC,IAAI,EAAEC,GAAG,KAC3CH,OAAO,CAACI,SAAS,CAACD,GAAG,EAAED,IAAI,CAAC;IAE9B,MAAMG,SAAZ,GAAyBL,OAAO,CAACK,SAAjC,GAA6CC,qBAAqB,CAC1DV,SAAS,EACRW,aAAa,IAFtB;MAGU,IAAIC,SAAd,GAA0BC,cAAc,CAC5BT,OAAO,CAACU,WAAW,EACnBH,aAAa;MACb;MACA;MACA;MACAN,OAAO,CACR;MAED,IACEO,SADZ,KAC0B,KAAK,KACnBT,MAAZ,KAAuBC,OAAO,CAACU,WAA/B,IACYtB,MAAM,CAACuB,IAAI,CAACZ,MAAM,EAAEQ,aAAa,CAAC,CAAC,CAAC,CAAC,EACrC;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACAC,SAAZ,GAAwBC,cAAc,CAACV,MAAM,EAAEQ,aAAa,EAAEK,UAAU,CAAC;MAC/D;MAEAzB,SAAV,CACYqB,SADZ,KAC0B,KAAK,OAEnBD,aAAa,CAACM,IAAI,CAAC,GAAG,GACtBd,MAJZ,CAKW;MAED,OAAOS,SAAS;IAClB,CAAC,CACD;IAEF,OAAO,GAAGR,OAAO,CAACc,QAAQ,IAAIrB,IAAI,CAACC,SAAS,CAACW,SAAS,CAAC,EAAE;EAC3D;AAEJ;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgBU,sBAAsBA,CACpCnB,SAAuB,EADzB;EAGE,MAAMC,IAAR,GAAeP,mBAAmB,CAACM,SAAS,CAAC;EAE3C,OACEC,IAAI,CAACmB,SADT,KAEKnB,IAAI,CAACmB,SAAV,GAAsB,CAACC,IAAI,EAAE;IAAEC,KAAK;IAAEC,SAAS;IAAEC;EAAjD,CAA4D,KAA5D;IACM,MAAMC,SAAZ,GAAwBf,qBAAqB,CAACV,SAAS,EAAG0B,OAAO,IAAjE;MACQ,MAAMC,QAAd,GAAyBD,OAAO,CAAC,CAAC,CAAC;MAC3B,MAAME,SAAd,GAA0BD,QAAQ,CAACE,MAAM,CAAC,CAAC,CAAC;MAEpC,IAAID,SAAZ,KAA0B,GAAG,EAAE;QACrB,IAAIN,KAAd,IAAuBjC,eAAe,CAACiC,KAAK,CAACQ,UAAU,CAAC,EAAE;UAC9C,MAAMC,aAAlB,GAAkCJ,QAAQ,CAACK,KAAK,CAAC,CAAC,CAAC;UACvC;UACA;UACA;UACA,MAAMC,CAAA,GAAIX,KAAK,CAACQ,UAAU,CAACI,IAAI,CAC5BD,CAAC,IAAKA,CAAC,CAACE,IAAI,CAACC,KAD5B,KACsCL,aAAa,CACtC;UACD;UACA,MAAMM,aAAlB,GAAkCJ,CAAA,IAAK/C,wBAAwB,CAAC+C,CAAC,EAAEV,SAAS,CAAC;UACjE;UACA;UACA;UACA;UACA;UACA;UACA;UACA,OACEc,aADd,IAEcxB,cAAc,CACZwB,aAAa;UACb;UACA;UACA;UACAX,OAAO,CAACM,KAAK,CAAC,CAAC,CAAC,CACjB;QAEL;QACA;QACA;QACA;QACA;MACF;MAEA,IAAIJ,SAAZ,KAA0B,GAAG,EAAE;QACrB,MAAMU,YAAhB,GAA+BX,QAAQ,CAACK,KAAK,CAAC,CAAC,CAAC;QACtC,IAAIT,SAAd,IAA2B/B,MAAM,CAACuB,IAAI,CAACQ,SAAS,EAAEe,YAAY,CAAC,EAAE;UACrD,MAAMC,UAAlB,GAA+Bb,OAAO,CAACM,KAAK,CAAC,CAAC,CAAC;UACnCO,UAAU,CAAC,CAAC,IAAID,YAAY;UAC5B,OAAOzB,cAAc,CAACU,SAAS,EAAEgB,UAAU,CAAC;QAC9C;QACA;QACA;QACA;QACA;MACF;MAEA,IAAIlB,IAAI,EAAE;QACR,OAAOR,cAAc,CAACQ,IAAI,EAAEK,OAAO,CAAC;MACtC;IACF,CAAC,CAAC;IAEF,MAAMc,MAAZ,GAAqB3C,IAAI,CAACC,SAAS,CAAC2B,SAAS,CAAC;IAExC;IACA;IACA;IACA;IACA;IACA,IAAIJ,IAAV,IAAkBmB,MAAlB,KAA6B,IAAI,EAAE;MAC3BhB,SAAR,IAAqB,GAArB,GAA2BgB,MAAM;IAC3B;IAEA,OAAOhB,SAAS;EAClB,CAAC,CAAC;AAEN;AAEA,gBAAgBd,qBAAqBA,CACnCV,SAAuB,EACvByC,SAAkC,EAFpC;EAIE;EACA;EACA,MAAMC,MAAR,GAAiB,IAAIvD,UAAU,CAA/B,CAAiC;EAC/B,OAAOwD,iBAAiB,CAAC3C,SAAS,CAAC,CAAC4C,MAAM,CAAC,CAACnB,SAAS,EAAEoB,IAAI,KAA7D;IACI,IAAIC,OAAR,GAAkBL,SAAS,CAACI,IAAI,CAAC;IAC7B,IAAIC,OAAR,KAAoB,KAAK,CAAC,EAAE;MACtB;MACA;MACA,KAAK,IAAIC,CAAA,GAAIF,IAAI,CAACG,MAAxB,GAAiC,CAAC,EAAED,CAAA,IAAK,CAAC,EAAE,EAAEA,CAAC,EAAE;QACzCD,OAAR,GAAkB;UAAE,CAACD,IAAI,CAACE,CAAC,CAAC,GAAGD;QAA/B,CAAwC;MAClC;MACArB,SAAN,GAAkBiB,MAAM,CAACO,KAAK,CAACxB,SAAS,EAAEqB,OAAO,CAAC;IAC9C;IACA,OAAOrB,SAAS;EAClB,CAAC,EAAE,CAAL,CAAO,CAAC;AACR;AAEA,gBAAgBkB,iBAAiBA,CAAChD,IAAkB,EAApD;EACE,MAAMM,IAAR,GAAeP,mBAAmB,CAACC,IAAI,CAAC;EAEtC,IAAI,CAACM,IAAI,CAACiD,KAAK,EAAE;IACf,MAAMA,KAAV,GAA+BjD,IAAI,CAACiD,KAApC,GAA4C,EAAG;IAC3C,MAAMC,WAAV,GAAkC,EAAE;IAEhCxD,IAAI,CAACyD,OAAO,CAAC,CAACC,CAAC,EAAEN,CAAC,KAAtB;MACM,IAAI3D,OAAO,CAACiE,CAAC,CAAC,EAAE;QACdV,iBAAiB,CAACU,CAAC,CAAC,CAACD,OAAO,CAAEE,CAAC,IAAKJ,KAAK,CAACK,IAAI,CAACJ,WAAW,CAACK,MAAM,CAACF,CAAC,CAAC,CAAC,CAAC;QACtEH,WAAW,CAACH,MAApB,GAA6B,CAAC;MACxB,OAAO;QACLG,WAAW,CAACI,IAAI,CAACF,CAAC,CAAC;QACnB,IAAI,CAACjE,OAAO,CAACO,IAAI,CAACoD,CAAA,GAAI,CAAC,CAAC,CAAC,EAAE;UACzBG,KAAK,CAACK,IAAI,CAACJ,WAAW,CAACnB,KAAK,CAAC,CAAC,CAAC,CAAC;UAChCmB,WAAW,CAACH,MAAtB,GAA+B,CAAC;QACxB;MACF;IACF,CAAC,CAAC;EACJ;EAEA,OAAO/C,IAAI,CAACiD,KAAM;AACpB;AAEA,SAASlC,UAAUA,CACjBb,MAAY,EACZI,GAAS,EAFX;EAIE,OAAOJ,MAAM,CAACI,GAAG,CAAC;AACpB;AAEA,gBAAgBM,cAAcA,CAC5BV,MAA2B,EAC3B0C,IAAc,EACdxC,OAA2B,EAH7B;EAKE;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACAA,OAAF,GAAYA,OAAZ,IAAuBW,UAAU;EAC/B,OAAOyC,SAAS,CACdZ,IAAI,CAACD,MAAM,CAAC,SAASc,OAAOA,CAACC,GAAG,EAAEpD,GAAG,EADzC;IAEM,OAAOnB,OAAO,CAACuE,GAAG,IACdA,GAAG,CAACC,GAAG,CAAEC,KAAK,IAAKH,OAAO,CAACG,KAAK,EAAEtD,GAAG,CAAC,IACtCoD,GAAV,IAAiBtD,OAAQ,CAACsD,GAAG,EAAEpD,GAAG,CAAC;EAC/B,CAAC,EAAEJ,MAAM,CAAC,CACX;AACH;AAEA,SAASsD,SAASA,CAAIrB,KAAQ,EAA9B;EACE;EACA;EACA;EACA,IAAI9C,eAAe,CAAC8C,KAAK,CAAC,EAAE;IAC1B,IAAIhD,OAAO,CAACgD,KAAK,CAAC,EAAE;MAClB,OAAOA,KAAK,CAACwB,GAAG,CAACH,SAAS,CAAQ;IACpC;IACA,OAAO/C,qBAAqB,CAACoD,MAAM,CAACC,IAAI,CAAC3B,KAAK,CAAC,CAAC4B,IAAI,CAAxD,CAA0D,EAAGnB,IAAI,IAC3DhC,cAAc,CAACuB,KAAK,EAAES,IAAI,CAAC,CACvB;EACR;EACA,OAAOT,KAAK;AACd","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}