{"ast":null,"code":"import { Kind } from \"graphql\";\nimport { __DEV__ } from \"@apollo/client/utilities/environment\";\nimport { maybeDeepFreeze, resultKeyNameFromField } from \"@apollo/client/utilities/internal\";\nimport { invariant } from \"@apollo/client/utilities/invariant\";\nimport { disableWarningsSlot, getFragmentMaskMode } from \"./utils.js\";\nexport function maskDefinition(data, selectionSet, context) {\n  return disableWarningsSlot.withValue(true, () => {\n    const masked = maskSelectionSet(data, selectionSet, context, false);\n    if (Object.isFrozen(data)) {\n      maybeDeepFreeze(masked);\n    }\n    return masked;\n  });\n}\nfunction getMutableTarget(data, mutableTargets) {\n  if (mutableTargets.has(data)) {\n    return mutableTargets.get(data);\n  }\n  const mutableTarget = Array.isArray(data) ? [] : {};\n  mutableTargets.set(data, mutableTarget);\n  return mutableTarget;\n}\nfunction maskSelectionSet(data, selectionSet, context, migration, path) {\n  const {\n    knownChanged\n  } = context;\n  const memo = getMutableTarget(data, context.mutableTargets);\n  if (Array.isArray(data)) {\n    for (const [index, item] of Array.from(data.entries())) {\n      if (item === null) {\n        memo[index] = null;\n        continue;\n      }\n      const masked = maskSelectionSet(item, selectionSet, context, migration, __DEV__ ? `${path || \"\"}[${index}]` : void 0);\n      if (knownChanged.has(masked)) {\n        knownChanged.add(memo);\n      }\n      memo[index] = masked;\n    }\n    return knownChanged.has(memo) ? memo : data;\n  }\n  for (const selection of selectionSet.selections) {\n    let value;\n    // we later want to add acessor warnings to the final result\n    // so we need a new object to add the accessor warning to\n    if (migration) {\n      knownChanged.add(memo);\n    }\n    if (selection.kind === Kind.FIELD) {\n      const keyName = resultKeyNameFromField(selection);\n      const childSelectionSet = selection.selectionSet;\n      value = memo[keyName] || data[keyName];\n      if (value === void 0) {\n        continue;\n      }\n      if (childSelectionSet && value !== null) {\n        const masked = maskSelectionSet(data[keyName], childSelectionSet, context, migration, __DEV__ ? `${path || \"\"}.${keyName}` : void 0);\n        if (knownChanged.has(masked)) {\n          value = masked;\n        }\n      }\n      if (!__DEV__) {\n        memo[keyName] = value;\n      }\n      if (__DEV__) {\n        if (migration && keyName !== \"__typename\" &&\n        // either the field is not present in the memo object\n        // or it has a `get` descriptor, not a `value` descriptor\n        // => it is a warning accessor and we can overwrite it\n        // with another accessor\n        !Object.getOwnPropertyDescriptor(memo, keyName)?.value) {\n          Object.defineProperty(memo, keyName, getAccessorWarningDescriptor(keyName, value, path || \"\", context.operationName, context.operationType));\n        } else {\n          delete memo[keyName];\n          memo[keyName] = value;\n        }\n      }\n    }\n    if (selection.kind === Kind.INLINE_FRAGMENT && (!selection.typeCondition || context.cache.fragmentMatches(selection, data.__typename))) {\n      value = maskSelectionSet(data, selection.selectionSet, context, migration, path);\n    }\n    if (selection.kind === Kind.FRAGMENT_SPREAD) {\n      const fragmentName = selection.name.value;\n      const fragment = context.fragmentMap[fragmentName] || (context.fragmentMap[fragmentName] = context.cache.lookupFragment(fragmentName));\n      invariant(fragment, 39, fragmentName);\n      const mode = getFragmentMaskMode(selection);\n      if (mode !== \"mask\") {\n        value = maskSelectionSet(data, fragment.selectionSet, context, mode === \"migrate\", path);\n      }\n    }\n    if (knownChanged.has(value)) {\n      knownChanged.add(memo);\n    }\n  }\n  if (\"__typename\" in data && !(\"__typename\" in memo)) {\n    memo.__typename = data.__typename;\n  }\n  // This check prevents cases where masked fields may accidentally be\n  // returned as part of this object when the fragment also selects\n  // additional fields from the same child selection.\n  if (Object.keys(memo).length !== Object.keys(data).length) {\n    knownChanged.add(memo);\n  }\n  return knownChanged.has(memo) ? memo : data;\n}\nfunction getAccessorWarningDescriptor(fieldName, value, path, operationName, operationType) {\n  let getValue = () => {\n    if (disableWarningsSlot.getValue()) {\n      return value;\n    }\n    __DEV__ && invariant.warn(40, operationName ? `${operationType} '${operationName}'` : `anonymous ${operationType}`, `${path}.${fieldName}`.replace(/^\\./, \"\"));\n    getValue = () => value;\n    return value;\n  };\n  return {\n    get() {\n      return getValue();\n    },\n    set(newValue) {\n      getValue = () => newValue;\n    },\n    enumerable: true,\n    configurable: true\n  };\n}","map":{"version":3,"names":["Kind","__DEV__","maybeDeepFreeze","resultKeyNameFromField","invariant","disableWarningsSlot","getFragmentMaskMode","maskDefinition","data","selectionSet","context","withValue","masked","maskSelectionSet","Object","isFrozen","getMutableTarget","mutableTargets","has","get","mutableTarget","Array","isArray","set","migration","path","knownChanged","memo","index","item","from","entries","add","selection","selections","value","kind","FIELD","keyName","childSelectionSet","getOwnPropertyDescriptor","defineProperty","getAccessorWarningDescriptor","operationName","operationType","INLINE_FRAGMENT","typeCondition","cache","fragmentMatches","__typename","FRAGMENT_SPREAD","fragmentName","name","fragment","fragmentMap","lookupFragment","mode","keys","length","fieldName","getValue","warn","replace","newValue","enumerable","configurable"],"sources":["/home/saurabh-shukla/Desktop/Slack Lite/frontend/node_modules/@apollo/src/masking/maskDefinition.ts"],"sourcesContent":["import type { FragmentDefinitionNode, SelectionSetNode } from \"graphql\";\nimport { Kind } from \"graphql\";\n\nimport type { ApolloCache } from \"@apollo/client/cache\";\nimport { __DEV__ } from \"@apollo/client/utilities/environment\";\nimport type { FragmentMap } from \"@apollo/client/utilities/internal\";\nimport {\n  maybeDeepFreeze,\n  resultKeyNameFromField,\n} from \"@apollo/client/utilities/internal\";\nimport { invariant } from \"@apollo/client/utilities/invariant\";\n\nimport { disableWarningsSlot, getFragmentMaskMode } from \"./utils.js\";\n\ninterface MaskingContext {\n  operationType: \"query\" | \"mutation\" | \"subscription\" | \"fragment\";\n  operationName: string | undefined;\n  fragmentMap: FragmentMap;\n  cache: ApolloCache;\n  mutableTargets: WeakMap<any, any>;\n  knownChanged: WeakSet<any>;\n}\n\nexport function maskDefinition(\n  data: Record<string, any>,\n  selectionSet: SelectionSetNode,\n  context: MaskingContext\n) {\n  return disableWarningsSlot.withValue(true, () => {\n    const masked = maskSelectionSet(data, selectionSet, context, false);\n\n    if (Object.isFrozen(data)) {\n      maybeDeepFreeze(masked);\n    }\n    return masked;\n  });\n}\n\nfunction getMutableTarget(\n  data: Record<string, any>,\n  mutableTargets: WeakMap<any, any>\n): typeof data {\n  if (mutableTargets.has(data)) {\n    return mutableTargets.get(data);\n  }\n\n  const mutableTarget = Array.isArray(data) ? [] : {};\n  mutableTargets.set(data, mutableTarget);\n  return mutableTarget;\n}\n\nfunction maskSelectionSet(\n  data: any,\n  selectionSet: SelectionSetNode,\n  context: MaskingContext,\n  migration: boolean,\n  path?: string | undefined\n): typeof data {\n  const { knownChanged } = context;\n  const memo = getMutableTarget(data, context.mutableTargets);\n\n  if (Array.isArray(data)) {\n    for (const [index, item] of Array.from(data.entries())) {\n      if (item === null) {\n        memo[index] = null;\n        continue;\n      }\n\n      const masked = maskSelectionSet(\n        item,\n        selectionSet,\n        context,\n        migration,\n        __DEV__ ? `${path || \"\"}[${index}]` : void 0\n      );\n      if (knownChanged.has(masked)) {\n        knownChanged.add(memo);\n      }\n\n      memo[index] = masked;\n    }\n\n    return knownChanged.has(memo) ? memo : data;\n  }\n\n  for (const selection of selectionSet.selections) {\n    let value: any;\n\n    // we later want to add acessor warnings to the final result\n    // so we need a new object to add the accessor warning to\n    if (migration) {\n      knownChanged.add(memo);\n    }\n\n    if (selection.kind === Kind.FIELD) {\n      const keyName = resultKeyNameFromField(selection);\n      const childSelectionSet = selection.selectionSet;\n\n      value = memo[keyName] || data[keyName];\n\n      if (value === void 0) {\n        continue;\n      }\n\n      if (childSelectionSet && value !== null) {\n        const masked = maskSelectionSet(\n          data[keyName],\n          childSelectionSet,\n          context,\n          migration,\n          __DEV__ ? `${path || \"\"}.${keyName}` : void 0\n        );\n\n        if (knownChanged.has(masked)) {\n          value = masked;\n        }\n      }\n\n      if (!__DEV__) {\n        memo[keyName] = value;\n      }\n      if (__DEV__) {\n        if (\n          migration &&\n          keyName !== \"__typename\" &&\n          // either the field is not present in the memo object\n          // or it has a `get` descriptor, not a `value` descriptor\n          // => it is a warning accessor and we can overwrite it\n          // with another accessor\n          !Object.getOwnPropertyDescriptor(memo, keyName)?.value\n        ) {\n          Object.defineProperty(\n            memo,\n            keyName,\n            getAccessorWarningDescriptor(\n              keyName,\n              value,\n              path || \"\",\n              context.operationName,\n              context.operationType\n            )\n          );\n        } else {\n          delete memo[keyName];\n          memo[keyName] = value;\n        }\n      }\n    }\n\n    if (\n      selection.kind === Kind.INLINE_FRAGMENT &&\n      (!selection.typeCondition ||\n        context.cache.fragmentMatches(selection, data.__typename))\n    ) {\n      value = maskSelectionSet(\n        data,\n        selection.selectionSet,\n        context,\n        migration,\n        path\n      );\n    }\n\n    if (selection.kind === Kind.FRAGMENT_SPREAD) {\n      const fragmentName = selection.name.value;\n      const fragment: FragmentDefinitionNode | null =\n        context.fragmentMap[fragmentName] ||\n        (context.fragmentMap[fragmentName] =\n          context.cache.lookupFragment(fragmentName)!);\n      invariant(\n        fragment,\n        \"Could not find fragment with name '%s'.\",\n        fragmentName\n      );\n\n      const mode = getFragmentMaskMode(selection);\n\n      if (mode !== \"mask\") {\n        value = maskSelectionSet(\n          data,\n          fragment.selectionSet,\n          context,\n          mode === \"migrate\",\n          path\n        );\n      }\n    }\n\n    if (knownChanged.has(value)) {\n      knownChanged.add(memo);\n    }\n  }\n\n  if (\"__typename\" in data && !(\"__typename\" in memo)) {\n    memo.__typename = data.__typename;\n  }\n\n  // This check prevents cases where masked fields may accidentally be\n  // returned as part of this object when the fragment also selects\n  // additional fields from the same child selection.\n  if (Object.keys(memo).length !== Object.keys(data).length) {\n    knownChanged.add(memo);\n  }\n\n  return knownChanged.has(memo) ? memo : data;\n}\n\nfunction getAccessorWarningDescriptor(\n  fieldName: string,\n  value: any,\n  path: string,\n  operationName: string | undefined,\n  operationType: string\n): PropertyDescriptor {\n  let getValue = () => {\n    if (disableWarningsSlot.getValue()) {\n      return value;\n    }\n\n    invariant.warn(\n      \"Accessing unmasked field on %s at path '%s'. This field will not be available when masking is enabled. Please read the field from the fragment instead.\",\n      operationName ?\n        `${operationType} '${operationName}'`\n      : `anonymous ${operationType}`,\n      `${path}.${fieldName}`.replace(/^\\./, \"\")\n    );\n\n    getValue = () => value;\n\n    return value;\n  };\n\n  return {\n    get() {\n      return getValue();\n    },\n    set(newValue) {\n      getValue = () => newValue;\n    },\n    enumerable: true,\n    configurable: true,\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}