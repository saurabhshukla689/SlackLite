{"ast":null,"code":"import { CombinedProtocolErrors, PROTOCOL_ERRORS_SYMBOL, ServerError, ServerParseError } from \"@apollo/client/errors\";\nimport { isNonNullObject } from \"@apollo/client/utilities/internal\";\nimport { invariant } from \"@apollo/client/utilities/invariant\";\nconst {\n  hasOwnProperty\n} = Object.prototype;\n/**\n * This function detects an Apollo payload result before it is transformed\n * into a FetchResult via HttpLink; it cannot detect an ApolloPayloadResult\n * once it leaves the link chain.\n */\nfunction isApolloPayloadResult(value) {\n  return isNonNullObject(value) && \"payload\" in value;\n}\nasync function* consumeMultipartBody(response) {\n  const decoder = new TextDecoder(\"utf-8\");\n  const contentType = response.headers?.get(\"content-type\");\n  // parse boundary value and ignore any subsequent name/value pairs after ;\n  // https://www.rfc-editor.org/rfc/rfc9110.html#name-parameters\n  // e.g. multipart/mixed;boundary=\"graphql\";deferSpec=20220824\n  // if no boundary is specified, default to -\n  const match = contentType?.match(\n  /*\n    ;\\s*boundary=                # Match the boundary parameter\n    (?:                          # either\n      '([^']*)'                  # a string starting with ' doesn't contain ', ends with '\n      |                          # or\n      \"([^\"]*)\"                  # a string starting with \" doesn't contain \", ends with \"\n      |                          # or\n      ([^\"'].*?)                 # a string that doesn't start with ' or \", parsed non-greedily\n      )                          # end of the group\n    \\s*                          # optional whitespace\n    (?:;|$)                        # match a semicolon or end of string\n  */\n  /;\\s*boundary=(?:'([^']+)'|\"([^\"]+)\"|([^\"'].+?))\\s*(?:;|$)/i);\n  const boundary = \"\\r\\n--\" + (match?.findLast(val => !!val) || \"-\");\n  let buffer = \"\";\n  invariant(response.body && typeof response.body.getReader === \"function\", 60);\n  const stream = response.body;\n  const reader = stream.getReader();\n  let done = false;\n  let encounteredBoundary = false;\n  let value;\n  // check to see if we received the final boundary, which is a normal boundary followed by \"--\"\n  // as described in https://www.rfc-editor.org/rfc/rfc2046#section-5.1.1\n  const passedFinalBoundary = () => encounteredBoundary && buffer[0] == \"-\" && buffer[1] == \"-\";\n  try {\n    while (!done) {\n      ({\n        value,\n        done\n      } = await reader.read());\n      const chunk = typeof value === \"string\" ? value : decoder.decode(value);\n      const searchFrom = buffer.length - boundary.length + 1;\n      buffer += chunk;\n      let bi = buffer.indexOf(boundary, searchFrom);\n      while (bi > -1 && !passedFinalBoundary()) {\n        encounteredBoundary = true;\n        let message;\n        [message, buffer] = [buffer.slice(0, bi), buffer.slice(bi + boundary.length)];\n        const i = message.indexOf(\"\\r\\n\\r\\n\");\n        const headers = parseHeaders(message.slice(0, i));\n        const contentType = headers[\"content-type\"];\n        if (contentType && contentType.toLowerCase().indexOf(\"application/json\") === -1) {\n          throw new Error(\"Unsupported patch content type: application/json is required.\");\n        }\n        // nb: Technically you'd want to slice off the beginning \"\\r\\n\" but since\n        // this is going to be `JSON.parse`d there is no need.\n        const body = message.slice(i);\n        if (body) {\n          yield body;\n        }\n        bi = buffer.indexOf(boundary);\n      }\n      if (passedFinalBoundary()) {\n        return;\n      }\n    }\n    throw new Error(\"premature end of multipart body\");\n  } finally {\n    reader.cancel();\n  }\n}\nexport async function readMultipartBody(response, nextValue) {\n  for await (const body of consumeMultipartBody(response)) {\n    const result = parseJsonEncoding(response, body);\n    if (Object.keys(result).length == 0) continue;\n    if (isApolloPayloadResult(result)) {\n      if (Object.keys(result).length === 1 && result.payload === null) {\n        return;\n      }\n      let next = {\n        ...result.payload\n      };\n      if (\"errors\" in result) {\n        next.extensions = {\n          ...next.extensions,\n          [PROTOCOL_ERRORS_SYMBOL]: new CombinedProtocolErrors(result.errors ?? [])\n        };\n      }\n      nextValue(next);\n    } else {\n      nextValue(result);\n    }\n  }\n}\nfunction parseHeaders(headerText) {\n  const headersInit = {};\n  headerText.split(\"\\n\").forEach(line => {\n    const i = line.indexOf(\":\");\n    if (i > -1) {\n      // normalize headers to lowercase\n      const name = line.slice(0, i).trim().toLowerCase();\n      const value = line.slice(i + 1).trim();\n      headersInit[name] = value;\n    }\n  });\n  return headersInit;\n}\nfunction parseJsonEncoding(response, bodyText) {\n  if (response.status >= 300) {\n    throw new ServerError(`Response not successful: Received status code ${response.status}`, {\n      response,\n      bodyText\n    });\n  }\n  try {\n    return JSON.parse(bodyText);\n  } catch (err) {\n    throw new ServerParseError(err, {\n      response,\n      bodyText\n    });\n  }\n}\nfunction parseGraphQLResponseJsonEncoding(response, bodyText) {\n  try {\n    return JSON.parse(bodyText);\n  } catch (err) {\n    throw new ServerParseError(err, {\n      response,\n      bodyText\n    });\n  }\n}\nfunction parseResponse(response, bodyText) {\n  const contentType = response.headers.get(\"content-type\");\n  if (contentType?.includes(\"application/graphql-response+json\")) {\n    return parseGraphQLResponseJsonEncoding(response, bodyText);\n  }\n  return parseJsonEncoding(response, bodyText);\n}\nexport function parseAndCheckHttpResponse(operations) {\n  return response => response.text().then(bodyText => {\n    const result = parseResponse(response, bodyText);\n    if (!Array.isArray(result) && !hasOwnProperty.call(result, \"data\") && !hasOwnProperty.call(result, \"errors\")) {\n      throw new ServerError(`Server response was malformed for query '${Array.isArray(operations) ? operations.map(op => op.operationName) : operations.operationName}'.`, {\n        response,\n        bodyText\n      });\n    }\n    return result;\n  });\n}","map":{"version":3,"names":["CombinedProtocolErrors","PROTOCOL_ERRORS_SYMBOL","ServerError","ServerParseError","isNonNullObject","invariant","hasOwnProperty","Object","prototype","isApolloPayloadResult","value","consumeMultipartBody","response","decoder","TextDecoder","contentType","headers","get","match","boundary","findLast","val","buffer","body","getReader","stream","reader","done","encounteredBoundary","passedFinalBoundary","read","chunk","decode","searchFrom","length","bi","indexOf","message","slice","i","parseHeaders","toLowerCase","Error","cancel","readMultipartBody","nextValue","result","parseJsonEncoding","keys","payload","next","extensions","errors","headerText","headersInit","split","forEach","line","name","trim","bodyText","status","JSON","parse","err","parseGraphQLResponseJsonEncoding","parseResponse","includes","parseAndCheckHttpResponse","operations","text","then","Array","isArray","call","map","op","operationName"],"sources":["/home/saurabh-shukla/Desktop/Slack Lite/frontend/node_modules/@apollo/src/link/http/parseAndCheckHttpResponse.ts"],"sourcesContent":["import {\n  CombinedProtocolErrors,\n  PROTOCOL_ERRORS_SYMBOL,\n  ServerError,\n  ServerParseError,\n} from \"@apollo/client/errors\";\nimport type { ApolloLink, ApolloPayloadResult } from \"@apollo/client/link\";\nimport { isNonNullObject } from \"@apollo/client/utilities/internal\";\nimport { invariant } from \"@apollo/client/utilities/invariant\";\n\nconst { hasOwnProperty } = Object.prototype;\n\n/**\n * This function detects an Apollo payload result before it is transformed\n * into a FetchResult via HttpLink; it cannot detect an ApolloPayloadResult\n * once it leaves the link chain.\n */\nfunction isApolloPayloadResult(value: unknown): value is ApolloPayloadResult {\n  return isNonNullObject(value) && \"payload\" in value;\n}\n\nasync function* consumeMultipartBody(\n  response: Response\n): AsyncGenerator<string, void, void> {\n  const decoder = new TextDecoder(\"utf-8\");\n  const contentType = response.headers?.get(\"content-type\");\n\n  // parse boundary value and ignore any subsequent name/value pairs after ;\n  // https://www.rfc-editor.org/rfc/rfc9110.html#name-parameters\n  // e.g. multipart/mixed;boundary=\"graphql\";deferSpec=20220824\n  // if no boundary is specified, default to -\n  const match = contentType?.match(\n    /*\n      ;\\s*boundary=                # Match the boundary parameter\n      (?:                          # either\n        '([^']*)'                  # a string starting with ' doesn't contain ', ends with '\n        |                          # or\n        \"([^\"]*)\"                  # a string starting with \" doesn't contain \", ends with \"\n        |                          # or\n        ([^\"'].*?)                 # a string that doesn't start with ' or \", parsed non-greedily\n        )                          # end of the group\n      \\s*                          # optional whitespace\n      (?:;|$)                        # match a semicolon or end of string\n    */\n    /;\\s*boundary=(?:'([^']+)'|\"([^\"]+)\"|([^\"'].+?))\\s*(?:;|$)/i\n  );\n  const boundary = \"\\r\\n--\" + (match?.findLast((val) => !!val) || \"-\");\n  let buffer = \"\";\n  invariant(\n    response.body && typeof response.body.getReader === \"function\",\n    \"Unknown type for `response.body`. Please use a `fetch` implementation that is WhatWG-compliant and that uses WhatWG ReadableStreams for `body`.\"\n  );\n\n  const stream = response.body;\n  const reader = stream.getReader();\n  let done = false;\n  let encounteredBoundary = false;\n  let value: Uint8Array<ArrayBufferLike> | string | undefined;\n\n  // check to see if we received the final boundary, which is a normal boundary followed by \"--\"\n  // as described in https://www.rfc-editor.org/rfc/rfc2046#section-5.1.1\n  const passedFinalBoundary = () =>\n    encounteredBoundary && buffer[0] == \"-\" && buffer[1] == \"-\";\n\n  try {\n    while (!done) {\n      ({ value, done } = await reader.read());\n      const chunk = typeof value === \"string\" ? value : decoder.decode(value);\n      const searchFrom = buffer.length - boundary.length + 1;\n      buffer += chunk;\n      let bi = buffer.indexOf(boundary, searchFrom);\n      while (bi > -1 && !passedFinalBoundary()) {\n        encounteredBoundary = true;\n        let message: string;\n        [message, buffer] = [\n          buffer.slice(0, bi),\n          buffer.slice(bi + boundary.length),\n        ];\n        const i = message.indexOf(\"\\r\\n\\r\\n\");\n        const headers = parseHeaders(message.slice(0, i));\n        const contentType = headers[\"content-type\"];\n        if (\n          contentType &&\n          contentType.toLowerCase().indexOf(\"application/json\") === -1\n        ) {\n          throw new Error(\n            \"Unsupported patch content type: application/json is required.\"\n          );\n        }\n        // nb: Technically you'd want to slice off the beginning \"\\r\\n\" but since\n        // this is going to be `JSON.parse`d there is no need.\n        const body = message.slice(i);\n\n        if (body) {\n          yield body;\n        }\n        bi = buffer.indexOf(boundary);\n      }\n      if (passedFinalBoundary()) {\n        return;\n      }\n    }\n    throw new Error(\"premature end of multipart body\");\n  } finally {\n    reader.cancel();\n  }\n}\n\nexport async function readMultipartBody<\n  T extends object = Record<string, unknown>,\n>(response: Response, nextValue: (value: T) => void) {\n  for await (const body of consumeMultipartBody(response)) {\n    const result = parseJsonEncoding(response, body);\n    if (Object.keys(result).length == 0) continue;\n    if (isApolloPayloadResult(result)) {\n      if (Object.keys(result).length === 1 && result.payload === null) {\n        return;\n      }\n      let next = { ...result.payload };\n      if (\"errors\" in result) {\n        next.extensions = {\n          ...next.extensions,\n          [PROTOCOL_ERRORS_SYMBOL]: new CombinedProtocolErrors(\n            result.errors ?? []\n          ),\n        };\n      }\n      nextValue(next as T);\n    } else {\n      nextValue(result);\n    }\n  }\n}\n\nfunction parseHeaders(headerText: string): Record<string, string> {\n  const headersInit: Record<string, string> = {};\n  headerText.split(\"\\n\").forEach((line) => {\n    const i = line.indexOf(\":\");\n    if (i > -1) {\n      // normalize headers to lowercase\n      const name = line.slice(0, i).trim().toLowerCase();\n      const value = line.slice(i + 1).trim();\n      headersInit[name] = value;\n    }\n  });\n  return headersInit;\n}\n\nfunction parseJsonEncoding(response: Response, bodyText: string) {\n  if (response.status >= 300) {\n    throw new ServerError(\n      `Response not successful: Received status code ${response.status}`,\n      { response, bodyText }\n    );\n  }\n\n  try {\n    return JSON.parse(bodyText);\n  } catch (err) {\n    throw new ServerParseError(err, { response, bodyText });\n  }\n}\n\nfunction parseGraphQLResponseJsonEncoding(\n  response: Response,\n  bodyText: string\n) {\n  try {\n    return JSON.parse(bodyText);\n  } catch (err) {\n    throw new ServerParseError(err, { response, bodyText });\n  }\n}\n\nfunction parseResponse(response: Response, bodyText: string) {\n  const contentType = response.headers.get(\"content-type\");\n\n  if (contentType?.includes(\"application/graphql-response+json\")) {\n    return parseGraphQLResponseJsonEncoding(response, bodyText);\n  }\n\n  return parseJsonEncoding(response, bodyText);\n}\n\nexport function parseAndCheckHttpResponse(\n  operations: ApolloLink.Operation | ApolloLink.Operation[]\n) {\n  return (response: Response) =>\n    response.text().then((bodyText) => {\n      const result = parseResponse(response, bodyText);\n\n      if (\n        !Array.isArray(result) &&\n        !hasOwnProperty.call(result, \"data\") &&\n        !hasOwnProperty.call(result, \"errors\")\n      ) {\n        throw new ServerError(\n          `Server response was malformed for query '${\n            Array.isArray(operations) ?\n              operations.map((op) => op.operationName)\n            : operations.operationName\n          }'.`,\n          { response, bodyText }\n        );\n      }\n      return result;\n    });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}