{"ast":null,"code":"import { invariant, newInvariantError } from \"@apollo/client/utilities/invariant\";\n/**\n* Returns a query document which adds a single query operation that only\n* spreads the target fragment inside of it.\n*\n* So for example a document of:\n*\n* ```graphql\n* fragment foo on Foo {\n*   a\n*   b\n*   c\n* }\n* ```\n*\n* Turns into:\n*\n* ```graphql\n* {\n*   ...foo\n* }\n*\n* fragment foo on Foo {\n*   a\n*   b\n*   c\n* }\n* ```\n*\n* The target fragment will either be the only fragment in the document, or a\n* fragment specified by the provided `fragmentName`. If there is more than one\n* fragment, but a `fragmentName` was not defined then an error will be thrown.\n*\n* @internal\n* \n* @deprecated This is an internal API and should not be used directly. This can be removed or changed at any time.\n*/\nexport function getFragmentQueryDocument(document, fragmentName) {\n  let actualFragmentName = fragmentName;\n  // Build an array of all our fragment definitions that will be used for\n  // validations. We also do some validations on the other definitions in the\n  // document while building this list.\n  const fragments = [];\n  document.definitions.forEach(definition => {\n    // Throw an error if we encounter an operation definition because we will\n    // define our own operation definition later on.\n    if (definition.kind === \"OperationDefinition\") {\n      throw newInvariantError(10, definition.operation, definition.name ? ` named '${definition.name.value}'` : \"\");\n    }\n    // Add our definition to the fragments array if it is a fragment\n    // definition.\n    if (definition.kind === \"FragmentDefinition\") {\n      fragments.push(definition);\n    }\n  });\n  // If the user did not give us a fragment name then let us try to get a\n  // name from a single fragment in the definition.\n  if (typeof actualFragmentName === \"undefined\") {\n    invariant(fragments.length === 1, 11, fragments.length);\n    actualFragmentName = fragments[0].name.value;\n  }\n  // Generate a query document with an operation that simply spreads the\n  // fragment inside of it.\n  const query = {\n    ...document,\n    definitions: [{\n      kind: \"OperationDefinition\",\n      // OperationTypeNode is an enum\n      operation: \"query\",\n      selectionSet: {\n        kind: \"SelectionSet\",\n        selections: [{\n          kind: \"FragmentSpread\",\n          name: {\n            kind: \"Name\",\n            value: actualFragmentName\n          }\n        }]\n      }\n    }, ...document.definitions]\n  };\n  return query;\n}","map":{"version":3,"names":["invariant","newInvariantError","getFragmentQueryDocument","document","fragmentName","actualFragmentName","fragments","definitions","forEach","definition","kind","operation","name","value","push","length","query","selectionSet","selections"],"sources":["/home/saurabh-shukla/Desktop/Slack Lite/frontend/node_modules/@apollo/src/utilities/internal/getFragmentQueryDocument.ts"],"sourcesContent":["import type {\n  DocumentNode,\n  FragmentDefinitionNode,\n  Kind,\n  OperationTypeNode,\n} from \"graphql\";\n\nimport {\n  invariant,\n  newInvariantError,\n} from \"@apollo/client/utilities/invariant\";\n\n/**\n * Returns a query document which adds a single query operation that only\n * spreads the target fragment inside of it.\n *\n * So for example a document of:\n *\n * ```graphql\n * fragment foo on Foo {\n *   a\n *   b\n *   c\n * }\n * ```\n *\n * Turns into:\n *\n * ```graphql\n * {\n *   ...foo\n * }\n *\n * fragment foo on Foo {\n *   a\n *   b\n *   c\n * }\n * ```\n *\n * The target fragment will either be the only fragment in the document, or a\n * fragment specified by the provided `fragmentName`. If there is more than one\n * fragment, but a `fragmentName` was not defined then an error will be thrown.\n *\n * @internal\n */\nexport function getFragmentQueryDocument(\n  document: DocumentNode,\n  fragmentName?: string\n): DocumentNode {\n  let actualFragmentName = fragmentName;\n\n  // Build an array of all our fragment definitions that will be used for\n  // validations. We also do some validations on the other definitions in the\n  // document while building this list.\n  const fragments: Array<FragmentDefinitionNode> = [];\n  document.definitions.forEach((definition) => {\n    // Throw an error if we encounter an operation definition because we will\n    // define our own operation definition later on.\n    if (definition.kind === \"OperationDefinition\") {\n      throw newInvariantError(\n        `Found a %s operation%s. ` +\n          \"No operations are allowed when using a fragment as a query. Only fragments are allowed.\",\n        definition.operation,\n        definition.name ? ` named '${definition.name.value}'` : \"\"\n      );\n    }\n    // Add our definition to the fragments array if it is a fragment\n    // definition.\n    if (definition.kind === \"FragmentDefinition\") {\n      fragments.push(definition);\n    }\n  });\n\n  // If the user did not give us a fragment name then let us try to get a\n  // name from a single fragment in the definition.\n  if (typeof actualFragmentName === \"undefined\") {\n    invariant(\n      fragments.length === 1,\n      `Found %s fragments. \\`fragmentName\\` must be provided when there is not exactly 1 fragment.`,\n      fragments.length\n    );\n    actualFragmentName = fragments[0].name.value;\n  }\n\n  // Generate a query document with an operation that simply spreads the\n  // fragment inside of it.\n  const query: DocumentNode = {\n    ...document,\n    definitions: [\n      {\n        kind: \"OperationDefinition\" as Kind.OPERATION_DEFINITION,\n        // OperationTypeNode is an enum\n        operation: \"query\" as OperationTypeNode,\n        selectionSet: {\n          kind: \"SelectionSet\" as Kind.SELECTION_SET,\n          selections: [\n            {\n              kind: \"FragmentSpread\" as Kind.FRAGMENT_SPREAD,\n              name: {\n                kind: \"Name\" as Kind.NAME,\n                value: actualFragmentName,\n              },\n            },\n          ],\n        },\n      },\n      ...document.definitions,\n    ],\n  };\n\n  return query;\n}\n"],"mappings":"AAOA,SACEA,SAAS,EACTC,iBAAiB,QACZ,oCAAoC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAoC3C,gBAAgBC,wBAAwBA,CACtCC,QAAsB,EACtBC,YAAqB,EAFvB;EAIE,IAAIC,kBAAN,GAA2BD,YAAY;EAErC;EACA;EACA;EACA,MAAME,SAAR,GAAmD,EAAE;EACnDH,QAAQ,CAACI,WAAW,CAACC,OAAO,CAAEC,UAAU,IAA1C;IACI;IACA;IACA,IAAIA,UAAU,CAACC,IAAnB,KAA4B,qBAAqB,EAAE;MAC7C,MAAMT,iBAAZ,C,IAGQQ,UAAU,CAACE,SADnB,EAEQF,UAAU,CAACG,IAFnB,GAE0B,WAAWH,UAAU,CAACG,IAAI,CAACC,KAAK,GAF1D,GAEgE,E,CACzD;IACH;IACA;IACA;IACA,IAAIJ,UAAU,CAACC,IAAnB,KAA4B,oBAAoB,EAAE;MAC5CJ,SAAS,CAACQ,IAAI,CAACL,UAAU,CAAC;IAC5B;EACF,CAAC,CAAC;EAEF;EACA;EACA,IAAI,OAAOJ,kBAAb,KAAoC,WAAW,EAAE;IAC7CL,SAAJ,CACMM,SAAS,CAACS,MADhB,KAC2B,OAErBT,SAAS,CAACS,MAHhB,CAIK;IACDV,kBAAJ,GAAyBC,SAAS,CAAC,CAAC,CAAC,CAACM,IAAI,CAACC,KAAK;EAC9C;EAEA;EACA;EACA,MAAMG,KAAR,GAA8B;IAC1B,GAAGb,QAAQ;IACXI,WAAW,EAAE,CACX;MACEG,IAAI,EAAE,qBAAkD;MACxD;MACAC,SAAS,EAAE,OAA4B;MACvCM,YAAY,EAAE;QACZP,IAAI,EAAE,cAAoC;QAC1CQ,UAAU,EAAE,CACV;UACER,IAAI,EAAE,gBAAwC;UAC9CE,IAAI,EAAE;YACJF,IAAI,EAAE,MAAmB;YACzBG,KAAK,EAAER;UACvB;QACA,CAAa;MAEb;IACA,CAAO,EACD,GAAGF,QAAQ,CAACI,WAAW;EAE7B,CAAG;EAED,OAAOS,KAAK;AACd","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}