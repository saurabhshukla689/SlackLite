{"ast":null,"code":"import { equal } from \"@wry/equality\";\nimport * as React from \"react\";\nimport { NetworkStatus } from \"@apollo/client\";\nimport { maybeDeepFreeze } from \"@apollo/client/utilities/internal\";\nimport { invariant } from \"@apollo/client/utilities/invariant\";\nimport { useRenderGuard } from \"./internal/index.js\";\nimport { useDeepMemo } from \"./internal/useDeepMemo.js\";\nimport { useIsomorphicLayoutEffect } from \"./internal/useIsomorphicLayoutEffect.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\nimport { useSyncExternalStore } from \"./useSyncExternalStore.js\";\n// The following methods, when called will execute the query, regardless of\n// whether the useLazyQuery execute function was called before.\nconst EAGER_METHODS = [\"refetch\", \"fetchMore\", \"updateQuery\", \"startPolling\", \"stopPolling\", \"subscribeToMore\"];\nexport function useLazyQuery(query, options) {\n  const client = useApolloClient(options?.client);\n  const previousDataRef = React.useRef(undefined);\n  const resultRef = React.useRef(undefined);\n  const stableOptions = useDeepMemo(() => options, [options]);\n  const calledDuringRender = useRenderGuard();\n  function createObservable() {\n    return client.watchQuery({\n      ...options,\n      query,\n      initialFetchPolicy: options?.fetchPolicy,\n      fetchPolicy: \"standby\"\n    });\n  }\n  const [currentClient, setCurrentClient] = React.useState(client);\n  const [observable, setObservable] = React.useState(createObservable);\n  if (currentClient !== client) {\n    setCurrentClient(client);\n    setObservable(createObservable());\n  }\n  // TODO: Revisit after we have RxJS in place. We should be able to use\n  // observable.getCurrentResult() (or equivalent) to get these values which\n  // will hopefully alleviate the need for us to use refs to track these values.\n  const updateResult = React.useCallback((result, forceUpdate) => {\n    const previousData = resultRef.current?.data;\n    if (previousData && !equal(previousData, result.data)) {\n      previousDataRef.current = previousData;\n    }\n    resultRef.current = result;\n    forceUpdate();\n  }, []);\n  const observableResult = useSyncExternalStore(React.useCallback(forceUpdate => {\n    const subscription = observable.subscribe(result => {\n      if (!equal(resultRef.current, result)) {\n        updateResult(result, forceUpdate);\n      }\n    });\n    return () => {\n      subscription.unsubscribe();\n    };\n  }, [observable, updateResult]), () => resultRef.current || initialResult, () => initialResult);\n  // We use useMemo here to make sure the eager methods have a stable identity.\n  const eagerMethods = React.useMemo(() => {\n    const eagerMethods = {};\n    for (const key of EAGER_METHODS) {\n      eagerMethods[key] = function (...args) {\n        invariant(resultRef.current, 29, key);\n        // @ts-expect-error this is just to generic to type\n        return observable[key](...args);\n      };\n    }\n    return eagerMethods;\n  }, [observable]);\n  React.useEffect(() => {\n    const updatedOptions = {\n      query,\n      errorPolicy: stableOptions?.errorPolicy,\n      refetchWritePolicy: stableOptions?.refetchWritePolicy,\n      returnPartialData: stableOptions?.returnPartialData,\n      notifyOnNetworkStatusChange: stableOptions?.notifyOnNetworkStatusChange,\n      nextFetchPolicy: options?.nextFetchPolicy,\n      skipPollAttempt: options?.skipPollAttempt\n    };\n    // Wait to apply the changed fetch policy until after the execute\n    // function has been called. The execute function will handle setting the\n    // the fetch policy away from standby for us when called for the first time.\n    if (observable.options.fetchPolicy !== \"standby\" && stableOptions?.fetchPolicy) {\n      updatedOptions.fetchPolicy = stableOptions.fetchPolicy;\n    }\n    observable.applyOptions(updatedOptions);\n  }, [query, observable, stableOptions,\n  // Ensure inline functions don't suffer from stale closures by checking for\n  // these deps separately. @wry/equality doesn't compare function identity\n  // so `stableOptions` isn't updated when using inline functions.\n  options?.nextFetchPolicy, options?.skipPollAttempt]);\n  const execute = React.useCallback((...args) => {\n    invariant(!calledDuringRender(), 30);\n    const [executeOptions] = args;\n    let fetchPolicy = observable.options.fetchPolicy;\n    if (fetchPolicy === \"standby\") {\n      fetchPolicy = observable.options.initialFetchPolicy;\n    }\n    return observable.reobserve({\n      fetchPolicy,\n      // If `variables` is not given, reset back to empty variables by\n      // ensuring the key exists in options\n      variables: executeOptions?.variables,\n      context: executeOptions?.context ?? {}\n    });\n  }, [observable, calledDuringRender]);\n  const executeRef = React.useRef(execute);\n  useIsomorphicLayoutEffect(() => {\n    executeRef.current = execute;\n  });\n  const stableExecute = React.useCallback((...args) => executeRef.current(...args), []);\n  const result = React.useMemo(() => {\n    const {\n      partial,\n      ...result\n    } = observableResult;\n    return {\n      ...eagerMethods,\n      ...result,\n      client,\n      previousData: previousDataRef.current,\n      variables: observable.variables,\n      observable,\n      called: !!resultRef.current\n    };\n  }, [client, observableResult, eagerMethods, observable]);\n  return [stableExecute, result];\n}\nconst initialResult = maybeDeepFreeze({\n  data: undefined,\n  dataState: \"empty\",\n  loading: false,\n  networkStatus: NetworkStatus.ready,\n  partial: true\n});","map":{"version":3,"names":["equal","React","NetworkStatus","maybeDeepFreeze","invariant","useRenderGuard","useDeepMemo","useIsomorphicLayoutEffect","useApolloClient","useSyncExternalStore","EAGER_METHODS","useLazyQuery","query","options","client","previousDataRef","useRef","undefined","resultRef","stableOptions","calledDuringRender","createObservable","watchQuery","initialFetchPolicy","fetchPolicy","currentClient","setCurrentClient","useState","observable","setObservable","updateResult","useCallback","result","forceUpdate","previousData","current","data","observableResult","subscription","subscribe","unsubscribe","initialResult","eagerMethods","useMemo","key","args","useEffect","updatedOptions","errorPolicy","refetchWritePolicy","returnPartialData","notifyOnNetworkStatusChange","nextFetchPolicy","skipPollAttempt","applyOptions","execute","executeOptions","reobserve","variables","context","executeRef","stableExecute","partial","called","dataState","loading","networkStatus","ready"],"sources":["/home/saurabh-shukla/Desktop/Slack Lite/frontend/node_modules/@apollo/src/react/hooks/useLazyQuery.ts"],"sourcesContent":["import type { TypedDocumentNode } from \"@graphql-typed-document-node/core\";\nimport { equal } from \"@wry/equality\";\nimport type { DocumentNode } from \"graphql\";\nimport * as React from \"react\";\n\nimport type {\n  ApolloClient,\n  DataState,\n  DefaultContext,\n  ErrorLike,\n  ErrorPolicy,\n  GetDataState,\n  InternalTypes,\n  MaybeMasked,\n  ObservableQuery,\n  OperationVariables,\n  RefetchWritePolicy,\n  SubscribeToMoreFunction,\n  UpdateQueryMapFn,\n  WatchQueryFetchPolicy,\n} from \"@apollo/client\";\nimport { NetworkStatus } from \"@apollo/client\";\nimport type {\n  DocumentationTypes as UtilityDocumentationTypes,\n  NoInfer,\n  VariablesOption,\n} from \"@apollo/client/utilities/internal\";\nimport { maybeDeepFreeze } from \"@apollo/client/utilities/internal\";\nimport { invariant } from \"@apollo/client/utilities/invariant\";\n\nimport { useRenderGuard } from \"./internal/index.js\";\nimport { useDeepMemo } from \"./internal/useDeepMemo.js\";\nimport { useIsomorphicLayoutEffect } from \"./internal/useIsomorphicLayoutEffect.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\nimport { useSyncExternalStore } from \"./useSyncExternalStore.js\";\nexport declare namespace useLazyQuery {\n  import _self = useLazyQuery;\n  export interface Options<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  > {\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#fetchPolicy:member} */\n    fetchPolicy?: WatchQueryFetchPolicy;\n\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#nextFetchPolicy:member} */\n    nextFetchPolicy?:\n      | WatchQueryFetchPolicy\n      | ((\n          this: ApolloClient.WatchQueryOptions<TData, TVariables>,\n          currentFetchPolicy: WatchQueryFetchPolicy,\n          context: InternalTypes.NextFetchPolicyContext<TData, TVariables>\n        ) => WatchQueryFetchPolicy);\n\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#refetchWritePolicy:member} */\n    refetchWritePolicy?: RefetchWritePolicy;\n\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#errorPolicy:member} */\n    errorPolicy?: ErrorPolicy;\n\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#pollInterval:member} */\n    pollInterval?: number;\n\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#notifyOnNetworkStatusChange:member} */\n    notifyOnNetworkStatusChange?: boolean;\n\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#returnPartialData:member} */\n    returnPartialData?: boolean;\n\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#skipPollAttempt:member} */\n    skipPollAttempt?: () => boolean;\n\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#client:member} */\n    client?: ApolloClient;\n  }\n  namespace DocumentationTypes {\n    namespace useLazyQuery {\n      export interface Options<\n        TData = unknown,\n        TVariables extends OperationVariables = OperationVariables,\n      > extends _self.Options<TData, TVariables> {}\n    }\n  }\n\n  namespace Base {\n    export interface Result<TData, TVariables extends OperationVariables> {\n      /** {@inheritDoc @apollo/client!QueryResultDocumentation#startPolling:member} */\n      startPolling: (pollInterval: number) => void;\n\n      /** {@inheritDoc @apollo/client!QueryResultDocumentation#stopPolling:member} */\n      stopPolling: () => void;\n\n      /** {@inheritDoc @apollo/client!QueryResultDocumentation#subscribeToMore:member} */\n      subscribeToMore: SubscribeToMoreFunction<TData, TVariables>;\n\n      /** {@inheritDoc @apollo/client!QueryResultDocumentation#updateQuery:member} */\n      updateQuery: (mapFn: UpdateQueryMapFn<TData, TVariables>) => void;\n\n      /** {@inheritDoc @apollo/client!QueryResultDocumentation#refetch:member} */\n      refetch: (\n        variables?: Partial<TVariables>\n      ) => Promise<ApolloClient.QueryResult<MaybeMasked<TData>>>;\n\n      /** {@inheritDoc @apollo/client!QueryResultDocumentation#fetchMore:member} */\n      fetchMore: <\n        TFetchData = TData,\n        TFetchVars extends OperationVariables = TVariables,\n      >(\n        fetchMoreOptions: ObservableQuery.FetchMoreOptions<\n          TData,\n          TVariables,\n          TFetchData,\n          TFetchVars\n        >\n      ) => Promise<ApolloClient.QueryResult<MaybeMasked<TFetchData>>>;\n\n      /** {@inheritDoc @apollo/client!QueryResultDocumentation#client:member} */\n      client: ApolloClient;\n\n      /** {@inheritDoc @apollo/client!QueryResultDocumentation#observable:member} */\n      observable: ObservableQuery<TData, TVariables>;\n\n      /** {@inheritDoc @apollo/client!QueryResultDocumentation#previousData:member} */\n      previousData?: MaybeMasked<TData>;\n\n      /** {@inheritDoc @apollo/client!QueryResultDocumentation#error:member} */\n      error?: ErrorLike;\n\n      /** {@inheritDoc @apollo/client!QueryResultDocumentation#loading:member} */\n      loading: boolean;\n\n      /** {@inheritDoc @apollo/client!QueryResultDocumentation#networkStatus:member} */\n      networkStatus: NetworkStatus;\n    }\n  }\n\n  export type Result<\n    TData,\n    TVariables extends OperationVariables,\n    TStates extends\n      DataState<TData>[\"dataState\"] = DataState<TData>[\"dataState\"],\n  > = Base.Result<TData, TVariables> &\n    (\n      | ({\n          /**\n           * If `true`, the associated lazy query has been executed.\n           *\n           * @docGroup 2. Network info\n           */\n          called: true;\n\n          /** {@inheritDoc @apollo/client!QueryResultDocumentation#variables:member} */\n          variables: TVariables;\n        } & GetDataState<MaybeMasked<TData>, TStates>)\n      | {\n          /**\n           * If `true`, the associated lazy query has been executed.\n           *\n           * @docGroup 2. Network info\n           */\n          called: false;\n\n          /** {@inheritDoc @apollo/client!QueryResultDocumentation#variables:member} */\n          variables: Partial<TVariables>;\n\n          /** {@inheritDoc @apollo/client!QueryResultDocumentation#data:member} */\n          data: undefined;\n          /** {@inheritDoc @apollo/client!QueryResultDocumentation#dataState:member} */\n          dataState: \"empty\";\n        }\n    );\n\n  namespace DocumentationTypes {\n    namespace useLazyQuery {\n      export interface Result<TData, TVariables extends OperationVariables>\n        extends Base.Result<TData, TVariables>,\n          UtilityDocumentationTypes.DataState<TData>,\n          UtilityDocumentationTypes.VariableOptions<TVariables> {\n        /**\n         * If `true`, the associated lazy query has been executed.\n         *\n         * @docGroup 2. Network info\n         */\n        called: boolean;\n      }\n    }\n  }\n\n  export type ExecOptions<\n    TVariables extends OperationVariables = OperationVariables,\n  > = {\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#context:member} */\n    context?: DefaultContext;\n  } & VariablesOption<TVariables>;\n\n  namespace DocumentationTypes {\n    namespace useLazyQuery {\n      export interface ExecOptions<TVariables extends OperationVariables>\n        extends UtilityDocumentationTypes.VariableOptions<TVariables> {\n        /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#context:member} */\n        context?: DefaultContext;\n      }\n    }\n  }\n\n  export type ResultTuple<\n    TData,\n    TVariables extends OperationVariables,\n    TStates extends\n      DataState<TData>[\"dataState\"] = DataState<TData>[\"dataState\"],\n  > = [\n    execute: ExecFunction<TData, TVariables>,\n    result: useLazyQuery.Result<TData, TVariables, TStates>,\n  ];\n\n  export type ExecFunction<TData, TVariables extends OperationVariables> = (\n    ...args: {} extends TVariables ?\n      [options?: useLazyQuery.ExecOptions<TVariables>]\n    : [options: useLazyQuery.ExecOptions<TVariables>]\n  ) => ObservableQuery.ResultPromise<ApolloClient.QueryResult<TData>>;\n\n  namespace DocumentationTypes {\n    namespace useLazyQuery {\n      export import ResultTuple = _self.ResultTuple;\n    }\n  }\n\n  namespace DocumentationTypes {\n    /** {@inheritDoc @apollo/client/react!useLazyQuery:function(1)} */\n    export function useLazyQuery<\n      TData = unknown,\n      TVariables extends OperationVariables = OperationVariables,\n    >(\n      query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n      options: useLazyQuery.Options<TData, TVariables>\n    ): useLazyQuery.ResultTuple<TData, TVariables>;\n  }\n}\n\n// The following methods, when called will execute the query, regardless of\n// whether the useLazyQuery execute function was called before.\nconst EAGER_METHODS = [\n  \"refetch\",\n  \"fetchMore\",\n  \"updateQuery\",\n  \"startPolling\",\n  \"stopPolling\",\n  \"subscribeToMore\",\n] as const;\n\n/**\n * A hook for imperatively executing queries in an Apollo application, e.g. in response to user interaction.\n *\n * > Refer to the [Queries - Manual execution with useLazyQuery](https://www.apollographql.com/docs/react/data/queries#manual-execution-with-uselazyquery) section for a more in-depth overview of `useLazyQuery`.\n *\n * @example\n *\n * ```jsx\n * import { gql } from \"@apollo/client\";\n * import { useLazyQuery } from \"@apollo/client/react\";\n *\n * const GET_GREETING = gql`\n *   query GetGreeting($language: String!) {\n *     greeting(language: $language) {\n *       message\n *     }\n *   }\n * `;\n *\n * function Hello() {\n *   const [loadGreeting, { called, loading, data }] = useLazyQuery(GET_GREETING, {\n *     variables: { language: \"english\" },\n *   });\n *   if (called && loading) return <p>Loading ...</p>;\n *   if (!called) {\n *     return <button onClick={() => loadGreeting()}>Load greeting</button>;\n *   }\n *   return <h1>Hello {data.greeting.message}!</h1>;\n * }\n * ```\n *\n * @param query - A GraphQL query document parsed into an AST by `gql`.\n * @param options - Default options to control how the query is executed.\n * @returns A tuple in the form of `[execute, result]`\n */\nexport function useLazyQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: useLazyQuery.Options<NoInfer<TData>, NoInfer<TVariables>> & {\n    returnPartialData: true;\n  }\n): useLazyQuery.ResultTuple<\n  TData,\n  TVariables,\n  \"empty\" | \"complete\" | \"streaming\" | \"partial\"\n>;\n\n/** {@inheritDoc @apollo/client/react!useLazyQuery:function(1)} */\nexport function useLazyQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: useLazyQuery.Options<NoInfer<TData>, NoInfer<TVariables>> & {\n    returnPartialData: boolean;\n  }\n): useLazyQuery.ResultTuple<\n  TData,\n  TVariables,\n  \"empty\" | \"complete\" | \"streaming\" | \"partial\"\n>;\n\n/** {@inheritDoc @apollo/client/react!useLazyQuery:function(1)} */\nexport function useLazyQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options?: useLazyQuery.Options<NoInfer<TData>, NoInfer<TVariables>>\n): useLazyQuery.ResultTuple<\n  TData,\n  TVariables,\n  \"empty\" | \"complete\" | \"streaming\"\n>;\n\nexport function useLazyQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n  TStates extends DataState<TData>[\"dataState\"] = DataState<TData>[\"dataState\"],\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options?: useLazyQuery.Options<NoInfer<TData>, NoInfer<TVariables>>\n): useLazyQuery.ResultTuple<TData, TVariables, TStates> {\n  const client = useApolloClient(options?.client);\n  const previousDataRef = React.useRef<TData>(undefined);\n  const resultRef = React.useRef<ObservableQuery.Result<TData>>(undefined);\n  const stableOptions = useDeepMemo(() => options, [options]);\n  const calledDuringRender = useRenderGuard();\n\n  function createObservable() {\n    return client.watchQuery({\n      ...options,\n      query,\n      initialFetchPolicy: options?.fetchPolicy,\n      fetchPolicy: \"standby\",\n    } as ApolloClient.WatchQueryOptions<TData, TVariables>);\n  }\n\n  const [currentClient, setCurrentClient] = React.useState(client);\n  const [observable, setObservable] = React.useState(createObservable);\n\n  if (currentClient !== client) {\n    setCurrentClient(client);\n    setObservable(createObservable());\n  }\n\n  // TODO: Revisit after we have RxJS in place. We should be able to use\n  // observable.getCurrentResult() (or equivalent) to get these values which\n  // will hopefully alleviate the need for us to use refs to track these values.\n  const updateResult = React.useCallback(\n    (result: ObservableQuery.Result<TData>, forceUpdate: () => void) => {\n      const previousData = resultRef.current?.data;\n\n      if (previousData && !equal(previousData, result.data)) {\n        previousDataRef.current = previousData as TData;\n      }\n\n      resultRef.current = result;\n\n      forceUpdate();\n    },\n    []\n  );\n\n  const observableResult = useSyncExternalStore(\n    React.useCallback(\n      (forceUpdate) => {\n        const subscription = observable.subscribe((result) => {\n          if (!equal(resultRef.current, result)) {\n            updateResult(result, forceUpdate);\n          }\n        });\n\n        return () => {\n          subscription.unsubscribe();\n        };\n      },\n      [observable, updateResult]\n    ),\n    () => resultRef.current || initialResult,\n    () => initialResult\n  );\n\n  // We use useMemo here to make sure the eager methods have a stable identity.\n  const eagerMethods = React.useMemo(() => {\n    const eagerMethods: Record<string, any> = {};\n    for (const key of EAGER_METHODS) {\n      eagerMethods[key] = function (...args: any[]) {\n        invariant(\n          resultRef.current,\n          \"useLazyQuery: '%s' cannot be called before executing the query.\",\n          key\n        );\n\n        // @ts-expect-error this is just to generic to type\n        return observable[key](...args);\n      };\n    }\n\n    return eagerMethods as Pick<\n      useLazyQuery.Result<TData, TVariables>,\n      (typeof EAGER_METHODS)[number]\n    >;\n  }, [observable]);\n\n  React.useEffect(() => {\n    const updatedOptions: Partial<ObservableQuery.Options<TData, TVariables>> =\n      {\n        query,\n        errorPolicy: stableOptions?.errorPolicy,\n        refetchWritePolicy: stableOptions?.refetchWritePolicy,\n        returnPartialData: stableOptions?.returnPartialData,\n        notifyOnNetworkStatusChange: stableOptions?.notifyOnNetworkStatusChange,\n        nextFetchPolicy: options?.nextFetchPolicy,\n        skipPollAttempt: options?.skipPollAttempt,\n      };\n\n    // Wait to apply the changed fetch policy until after the execute\n    // function has been called. The execute function will handle setting the\n    // the fetch policy away from standby for us when called for the first time.\n    if (\n      observable.options.fetchPolicy !== \"standby\" &&\n      stableOptions?.fetchPolicy\n    ) {\n      updatedOptions.fetchPolicy = stableOptions.fetchPolicy;\n    }\n\n    observable.applyOptions(updatedOptions);\n  }, [\n    query,\n    observable,\n    stableOptions,\n    // Ensure inline functions don't suffer from stale closures by checking for\n    // these deps separately. @wry/equality doesn't compare function identity\n    // so `stableOptions` isn't updated when using inline functions.\n    options?.nextFetchPolicy,\n    options?.skipPollAttempt,\n  ]);\n\n  const execute: useLazyQuery.ExecFunction<TData, TVariables> =\n    React.useCallback(\n      (...args) => {\n        invariant(\n          !calledDuringRender(),\n          \"useLazyQuery: 'execute' should not be called during render. To start a query during render, use the 'useQuery' hook.\"\n        );\n\n        const [executeOptions] = args;\n\n        let fetchPolicy = observable.options.fetchPolicy;\n\n        if (fetchPolicy === \"standby\") {\n          fetchPolicy = observable.options.initialFetchPolicy;\n        }\n\n        return observable.reobserve({\n          fetchPolicy,\n          // If `variables` is not given, reset back to empty variables by\n          // ensuring the key exists in options\n          variables: executeOptions?.variables,\n          context: executeOptions?.context ?? {},\n        });\n      },\n      [observable, calledDuringRender]\n    );\n\n  const executeRef = React.useRef(execute);\n  useIsomorphicLayoutEffect(() => {\n    executeRef.current = execute;\n  });\n\n  const stableExecute = React.useCallback<typeof execute>(\n    (...args) => executeRef.current(...args),\n    []\n  );\n\n  const result = React.useMemo(() => {\n    const { partial, ...result } = observableResult;\n\n    return {\n      ...eagerMethods,\n      ...result,\n      client,\n      previousData: previousDataRef.current,\n      variables: observable.variables,\n      observable,\n      called: !!resultRef.current,\n    };\n  }, [client, observableResult, eagerMethods, observable]);\n\n  return [stableExecute, result as any];\n}\n\nconst initialResult: ObservableQuery.Result<any> = maybeDeepFreeze({\n  data: undefined,\n  dataState: \"empty\",\n  loading: false,\n  networkStatus: NetworkStatus.ready,\n  partial: true,\n});\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}